This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.hintrc
client/.gitignore
client/COMPONENT_UPDATES.md
client/eslint.config.mjs
client/FRONTEND_ARCHITECTURE.md
client/MIDDLEWARE_GUIDE.md
client/next.config.ts
client/package.json
client/postcss.config.js
client/public/images/arrowDown.png
client/public/images/arrowUp.png
client/public/images/auth-img.png
client/public/images/avatar.png
client/public/images/bg.jpg
client/public/images/camera.png
client/public/images/download.png
client/public/images/edit.png
client/public/images/emoji.png
client/public/images/favicon.png
client/public/images/img.png
client/public/images/info.png
client/public/images/mic.png
client/public/images/minus.png
client/public/images/more.png
client/public/images/pattern-05.png
client/public/images/phone.png
client/public/images/plus.png
client/public/images/search.png
client/public/images/theme.png
client/public/images/video.png
client/README.md
client/SERVICES_HOOKS_REFERENCE.md
client/src/app/(auth)/forgotPassword/page.tsx
client/src/app/(auth)/google-callback/page.tsx
client/src/app/(auth)/layout.tsx
client/src/app/(auth)/resetPassword/page.tsx
client/src/app/(auth)/signIn/page.tsx
client/src/app/(auth)/signUp/page.tsx
client/src/app/(auth)/verifyEmail/page.tsx
client/src/app/(main)/chats/page.tsx
client/src/app/(main)/friendsRequests/page.tsx
client/src/app/(main)/layout.tsx
client/src/app/(main)/profile/page.tsx
client/src/app/favicon.ico
client/src/app/layout.tsx
client/src/app/page.tsx
client/src/components/layout/authLayout.tsx
client/src/components/layout/mainLayout.tsx
client/src/components/pages/auth/forgotPassword/index.tsx
client/src/components/pages/auth/forgotPassword/useForgotPassword.ts
client/src/components/pages/auth/googleCallback/index.tsx
client/src/components/pages/auth/googleCallback/useGoogleCallback.ts
client/src/components/pages/auth/resetPassword/index.tsx
client/src/components/pages/auth/resetPassword/useResetPasswordForm.ts
client/src/components/pages/auth/signIn/index.tsx
client/src/components/pages/auth/signIn/useSignIn.ts
client/src/components/pages/auth/signUp/index.tsx
client/src/components/pages/auth/signUp/useSignUp.ts
client/src/components/pages/auth/verifyEmail/index.tsx
client/src/components/pages/auth/verifyEmail/useVerifyEmailForm.ts
client/src/components/pages/main/chats/index.tsx
client/src/components/pages/main/friendsRequests/index.tsx
client/src/components/pages/main/profile/index.tsx
client/src/components/ui/buttons/AddButton.tsx
client/src/components/ui/buttons/index.ts
client/src/components/ui/display/AuthContainer.tsx
client/src/components/ui/display/Panel.tsx
client/src/components/ui/feedback/ErrorAlert.tsx
client/src/components/ui/form/AuthSwitchLink.tsx
client/src/components/ui/form/Button.tsx
client/src/components/ui/form/ForgetPassword.tsx
client/src/components/ui/form/FormHeader.tsx
client/src/components/ui/form/GoogleButton.tsx
client/src/components/ui/form/index.ts
client/src/components/ui/form/Input.tsx
client/src/components/ui/form/Milestone.tsx
client/src/components/ui/navigation/Sidebar.tsx
client/src/hooks/useAuth.ts
client/src/hooks/useConversations.ts
client/src/hooks/useFriends.ts
client/src/hooks/useGoogleAuth.ts
client/src/hooks/useMessages.ts
client/src/lib/axios.ts
client/src/middleware.ts
client/src/providers/index.tsx
client/src/services/auth.service.ts
client/src/services/conversations.service.ts
client/src/services/friends.service.ts
client/src/services/messages.service.ts
client/src/styles/dark-mode-transitions.css
client/src/styles/globals.css
client/tailwind.config.js
client/tsconfig.json
DARK_MODE_GUIDE.md
README.md
server/.gitignore
server/dist/app.d.ts
server/dist/app.d.ts.map
server/dist/app.js
server/dist/app.js.map
server/dist/config/cloudinary.config.d.ts
server/dist/config/cloudinary.config.d.ts.map
server/dist/config/cloudinary.config.js
server/dist/config/cloudinary.config.js.map
server/dist/config/db.d.ts
server/dist/config/db.d.ts.map
server/dist/config/db.js
server/dist/config/db.js.map
server/dist/config/env.config.d.ts
server/dist/config/env.config.d.ts.map
server/dist/config/env.config.js
server/dist/config/env.config.js.map
server/dist/config/google-auth.config.d.ts
server/dist/config/google-auth.config.d.ts.map
server/dist/config/google-auth.config.js
server/dist/config/google-auth.config.js.map
server/dist/controllers/auth.controller.d.ts
server/dist/controllers/auth.controller.d.ts.map
server/dist/controllers/auth.controller.js
server/dist/controllers/auth.controller.js.map
server/dist/controllers/call.controller.d.ts
server/dist/controllers/call.controller.d.ts.map
server/dist/controllers/call.controller.js
server/dist/controllers/call.controller.js.map
server/dist/controllers/conversation.controller.d.ts
server/dist/controllers/conversation.controller.d.ts.map
server/dist/controllers/conversation.controller.js
server/dist/controllers/conversation.controller.js.map
server/dist/controllers/friend.controller.d.ts
server/dist/controllers/friend.controller.d.ts.map
server/dist/controllers/friend.controller.js
server/dist/controllers/friend.controller.js.map
server/dist/controllers/google-auth.controller.d.ts
server/dist/controllers/google-auth.controller.d.ts.map
server/dist/controllers/google-auth.controller.js
server/dist/controllers/google-auth.controller.js.map
server/dist/controllers/message.controller.d.ts
server/dist/controllers/message.controller.d.ts.map
server/dist/controllers/message.controller.js
server/dist/controllers/message.controller.js.map
server/dist/controllers/user.controller.d.ts
server/dist/controllers/user.controller.d.ts.map
server/dist/controllers/user.controller.js
server/dist/controllers/user.controller.js.map
server/dist/dto/auth.dto.d.ts
server/dist/dto/auth.dto.d.ts.map
server/dist/dto/auth.dto.js
server/dist/dto/auth.dto.js.map
server/dist/dto/conversation.dto.d.ts
server/dist/dto/conversation.dto.d.ts.map
server/dist/dto/conversation.dto.js
server/dist/dto/conversation.dto.js.map
server/dist/dto/friend.dto.d.ts
server/dist/dto/friend.dto.d.ts.map
server/dist/dto/friend.dto.js
server/dist/dto/friend.dto.js.map
server/dist/dto/message.dto.d.ts
server/dist/dto/message.dto.d.ts.map
server/dist/dto/message.dto.js
server/dist/dto/message.dto.js.map
server/dist/dto/user.dto.d.ts
server/dist/dto/user.dto.d.ts.map
server/dist/dto/user.dto.js
server/dist/dto/user.dto.js.map
server/dist/middleware/auth.middleware.d.ts
server/dist/middleware/auth.middleware.d.ts.map
server/dist/middleware/auth.middleware.js
server/dist/middleware/auth.middleware.js.map
server/dist/middleware/error.middleware.d.ts
server/dist/middleware/error.middleware.d.ts.map
server/dist/middleware/error.middleware.js
server/dist/middleware/error.middleware.js.map
server/dist/middleware/upload.middleware.d.ts
server/dist/middleware/upload.middleware.d.ts.map
server/dist/middleware/upload.middleware.js
server/dist/middleware/upload.middleware.js.map
server/dist/middleware/validate.middleware.d.ts
server/dist/middleware/validate.middleware.d.ts.map
server/dist/middleware/validate.middleware.js
server/dist/middleware/validate.middleware.js.map
server/dist/routes/auth.route.d.ts
server/dist/routes/auth.route.d.ts.map
server/dist/routes/auth.route.js
server/dist/routes/auth.route.js.map
server/dist/routes/call.route.d.ts
server/dist/routes/call.route.d.ts.map
server/dist/routes/call.route.js
server/dist/routes/call.route.js.map
server/dist/routes/conversation.route.d.ts
server/dist/routes/conversation.route.d.ts.map
server/dist/routes/conversation.route.js
server/dist/routes/conversation.route.js.map
server/dist/routes/friend.route.d.ts
server/dist/routes/friend.route.d.ts.map
server/dist/routes/friend.route.js
server/dist/routes/friend.route.js.map
server/dist/routes/google-auth.route.d.ts
server/dist/routes/google-auth.route.d.ts.map
server/dist/routes/google-auth.route.js
server/dist/routes/google-auth.route.js.map
server/dist/routes/message.route.d.ts
server/dist/routes/message.route.d.ts.map
server/dist/routes/message.route.js
server/dist/routes/message.route.js.map
server/dist/routes/user.route.d.ts
server/dist/routes/user.route.d.ts.map
server/dist/routes/user.route.js
server/dist/routes/user.route.js.map
server/dist/server.d.ts
server/dist/server.d.ts.map
server/dist/server.js
server/dist/server.js.map
server/dist/services/auth.service.d.ts
server/dist/services/auth.service.d.ts.map
server/dist/services/auth.service.js
server/dist/services/auth.service.js.map
server/dist/services/call.service.d.ts
server/dist/services/call.service.d.ts.map
server/dist/services/call.service.js
server/dist/services/call.service.js.map
server/dist/services/conversation.service.d.ts
server/dist/services/conversation.service.d.ts.map
server/dist/services/conversation.service.js
server/dist/services/conversation.service.js.map
server/dist/services/email.service.d.ts
server/dist/services/email.service.d.ts.map
server/dist/services/email.service.js
server/dist/services/email.service.js.map
server/dist/services/friend.service.d.ts
server/dist/services/friend.service.d.ts.map
server/dist/services/friend.service.js
server/dist/services/friend.service.js.map
server/dist/services/message.service.d.ts
server/dist/services/message.service.d.ts.map
server/dist/services/message.service.js
server/dist/services/message.service.js.map
server/dist/services/user.service.d.ts
server/dist/services/user.service.d.ts.map
server/dist/services/user.service.js
server/dist/services/user.service.js.map
server/dist/socket/chat.socket.d.ts
server/dist/socket/chat.socket.d.ts.map
server/dist/socket/chat.socket.js
server/dist/socket/chat.socket.js.map
server/dist/types/error.types.d.ts
server/dist/types/error.types.d.ts.map
server/dist/types/error.types.js
server/dist/types/error.types.js.map
server/dist/utils/cloudinary.util.d.ts
server/dist/utils/cloudinary.util.d.ts.map
server/dist/utils/cloudinary.util.js
server/dist/utils/cloudinary.util.js.map
server/dist/utils/email.util.d.ts
server/dist/utils/email.util.d.ts.map
server/dist/utils/email.util.js
server/dist/utils/email.util.js.map
server/dist/utils/jwt.util.d.ts
server/dist/utils/jwt.util.d.ts.map
server/dist/utils/jwt.util.js
server/dist/utils/jwt.util.js.map
server/dist/utils/response.util.d.ts
server/dist/utils/response.util.d.ts.map
server/dist/utils/response.util.js
server/dist/utils/response.util.js.map
server/dist/utils/templates/email.templates.d.ts
server/dist/utils/templates/email.templates.d.ts.map
server/dist/utils/templates/email.templates.js
server/dist/utils/templates/email.templates.js.map
server/package.json
server/prisma/migrations/20251124110710_add_refresh_token/migration.sql
server/prisma/migrations/20251125084108_add_password_reset_model/migration.sql
server/prisma/migrations/20251125085636_add_user_role/migration.sql
server/prisma/migrations/20251126085837_add_google_oauth/migration.sql
server/prisma/migrations/20251213091718_add_chat_system/migration.sql
server/prisma/migrations/migration_lock.toml
server/prisma/schema.prisma
server/README.md
server/src/app.ts
server/src/config/cloudinary.config.ts
server/src/config/db.ts
server/src/config/env.config.ts
server/src/config/google-auth.config.ts
server/src/controllers/auth.controller.ts
server/src/controllers/call.controller.ts
server/src/controllers/conversation.controller.ts
server/src/controllers/friend.controller.ts
server/src/controllers/google-auth.controller.ts
server/src/controllers/message.controller.ts
server/src/controllers/user.controller.ts
server/src/dto/auth.dto.ts
server/src/dto/conversation.dto.ts
server/src/dto/friend.dto.ts
server/src/dto/message.dto.ts
server/src/dto/user.dto.ts
server/src/middleware/auth.middleware.ts
server/src/middleware/error.middleware.ts
server/src/middleware/upload.middleware.ts
server/src/middleware/validate.middleware.ts
server/src/routes/auth.route.ts
server/src/routes/call.route.ts
server/src/routes/conversation.route.ts
server/src/routes/friend.route.ts
server/src/routes/google-auth.route.ts
server/src/routes/message.route.ts
server/src/routes/user.route.ts
server/src/server.ts
server/src/services/auth.service.ts
server/src/services/call.service.ts
server/src/services/conversation.service.ts
server/src/services/email.service.ts
server/src/services/friend.service.ts
server/src/services/message.service.ts
server/src/services/user.service.ts
server/src/socket/chat.socket.ts
server/src/types/error.types.ts
server/src/utils/cloudinary.util.ts
server/src/utils/email.util.ts
server/src/utils/jwt.util.ts
server/src/utils/response.util.ts
server/src/utils/templates/email.templates.ts
server/tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".hintrc">
{
  "extends": [
    "development"
  ],
  "hints": {
    "typescript-config/consistent-casing": "off"
  }
}
</file>

<file path="client/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="client/COMPONENT_UPDATES.md">
# Component Updates & TypeScript Fixes - December 21, 2025

## Overview
Fixed TypeScript type errors, created reusable AddButton component, and improved type safety across components.

---

## Changes Made

### 1. Created Reusable AddButton Component ‚úÖ
**File:** `client/src/components/ui/buttons/AddButton.tsx`

**Features:**
- Reusable button component with Plus icon from lucide-react
- Two size variants: `sm` (w-5 h-5) and `md` (w-7 h-7)
- Proper `type="button"` attribute to prevent form submission
- Hover and transition effects
- Full TypeScript support with `AddButtonProps` interface

**Props:**
```typescript
interface AddButtonProps {
  onClick?: () => void;
  size?: "sm" | "md";
  className?: string;
  title?: string;
}
```

**Usage Examples:**
```tsx
// Header/large button
<AddButton size="md" title="Start new chat" />

// Section button
<AddButton size="sm" title="New conversation" />

// With click handler
<AddButton 
  size="md" 
  onClick={() => handleAddClick()} 
  title="Add new item"
/>
```

### 2. Updated Chats Component ‚úÖ
**File:** `client/src/components/pages/main/chats/index.tsx`

**Fixes:**
- Fixed property error: Changed `conversations?.participants?.[1]?.name` to `conversations?.otherUser?.name`
  - Response type is `ConversationListItem[]` which has `otherUser` property, not `participants`
- Added proper TypeScript import: `import type { ConversationListItem }`
- Fixed button type attributes: All buttons now have `type="button"`
- Fixed implicit `any` type: `ConversationItem` now accepts `ConversationListItem` type
- Removed unused imports: `Pin` from lucide-react
- Replaced manual Plus button markup with `<AddButton />` component in 2 locations

**Before:**
```tsx
const conversations = conversationsData?.conversations || [];
const filteredConversations = conversations.filter((conv) =>
  conv.participants?.[1]?.name  // ‚ùå WRONG PROPERTY
);

// Manual button code
<button className="w-7 h-7 rounded-md bg-primaryColor/10...">
  <Plus className="w-4 h-4" />
</button>

// Untyped props
function ConversationItem({
  conversation,  // ‚ùå any type
  onClick,
})
```

**After:**
```tsx
const conversations = conversationsData?.conversations || [];
const filteredConversations = conversations.filter((conv) =>
  conv.otherUser?.name  // ‚úÖ CORRECT PROPERTY
);

// Reusable component
<AddButton size="md" title="Start new chat" />

// Properly typed
function ConversationItem({
  conversation,  // ‚úÖ ConversationListItem type
  onClick,
}: {
  conversation: ConversationListItem;
  onClick: () => void;
})
```

**Type Changes:**
- Removed: `interface Chat` (not needed with real data)
- Added: `import type { ConversationListItem }`
- Updated: `ConversationItem` function signature with proper types

### 3. Updated Friend Requests Component ‚úÖ
**File:** `client/src/components/pages/main/friendsRequests/index.tsx`

**Fixes:**
- Added TypeScript import: `import type { FriendRequest }`
- Fixed implicit `any` type in `FriendRequestItemProps`
  - Changed `request: any` to `request: FriendRequest`
- Fixed property access: `request.sender` for both incoming and sent (sender object is in the FriendRequest)

**Before:**
```tsx
interface FriendRequestItemProps {
  request: any;  // ‚ùå any type
}

const user = isIncoming ? request.sender : request.recipient;  // ‚ùå no recipient field
```

**After:**
```tsx
interface FriendRequestItemProps {
  request: FriendRequest;  // ‚úÖ typed
}

const user = isIncoming ? request.sender : request.sender;  // ‚úÖ correct
```

### 4. Created Button Export Index ‚úÖ
**File:** `client/src/components/ui/buttons/index.ts`

**Purpose:** Centralized exports for button components

**Exports:**
```typescript
export { AddButton } from "./AddButton";
export { LogoutButton } from "./LogoutButton";
```

**Usage:**
```tsx
// Before
import { AddButton } from "@/components/ui/buttons/AddButton";

// After
import { AddButton } from "@/components/ui/buttons";
```

---

## TypeScript Error Resolutions

| Error | Cause | Solution |
|-------|-------|----------|
| `Property 'conversations' does not exist on type 'ConversationListItem[]'` | Wrong property name | Changed `participants?.[1]?.name` to `otherUser?.name` |
| `Button type attribute has not been set` | Missing `type` attribute on buttons | Added `type="button"` to all buttons |
| `Parameter 'conversation' implicitly has an 'any' type` | Untyped function parameter | Added explicit type: `ConversationListItem` |
| `Unexpected any. Specify a different type` | Untyped interface property | Changed `request: any` to `request: FriendRequest` |

---

## Files Modified Summary

### New Files
- ‚úÖ `client/src/components/ui/buttons/AddButton.tsx` (41 lines)
- ‚úÖ `client/src/components/ui/buttons/index.ts` (2 lines)

### Updated Files
- ‚úÖ `client/src/components/pages/main/chats/index.tsx` (166 lines)
  - Removed 50+ lines of manual button markup
  - Added 1 import for AddButton
  - Fixed all TypeScript errors
  
- ‚úÖ `client/src/components/pages/main/friendsRequests/index.tsx` (228 lines)
  - Added 1 import for FriendRequest type
  - Fixed interface typing
  - Fixed property access

---

## Benefits

1. **Type Safety**: All `any` types eliminated, full TypeScript coverage
2. **DRY Principle**: AddButton used consistently across components
3. **Maintainability**: Button styling changes only need to be made in one place
4. **Accessibility**: Proper `type="button"` prevents accidental form submission
5. **Consistency**: All buttons follow the same pattern and styling

---

## Next Steps

The components are now fully typed and ready for:
- [ ] Integration with message sending functionality
- [ ] Real-time Socket.IO updates
- [ ] Additional components (Groups, Calls, Contacts)
- [ ] Component testing with proper TypeScript support

---

## Code Quality Checklist

- ‚úÖ All TypeScript errors resolved
- ‚úÖ No implicit `any` types
- ‚úÖ Button `type` attributes set
- ‚úÖ Proper imports with type safety
- ‚úÖ DRY principle followed (reusable AddButton)
- ‚úÖ Consistent prop interfaces
- ‚úÖ JSDoc comments maintained
- ‚úÖ Error handling preserved
</file>

<file path="client/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="client/FRONTEND_ARCHITECTURE.md">
# Frontend Architecture & Integration Guide

## Overview

This document outlines the client-side architecture for the Doot chat application, including service layers, hooks, and component integration patterns.

---

## Service Layer Architecture

### 1. Authentication Service (`services/auth.service.ts`)
**Purpose:** Handles user authentication, registration, and OAuth flows

**Key Methods:**
- `login()` - Email/password login
- `register()` - User registration
- `verifyEmail()` - Email verification
- `resendVerification()` - Resend verification email
- `requestPasswordReset()` - Request password reset
- `resetPassword()` - Reset password with token
- `initiateGoogleAuth()` - Start Google OAuth flow

**Used By:** `useAuth.ts` hook

**Pattern:**
```typescript
// Service returns typed responses extracted from API response
async login(data: LoginRequest): Promise<AuthResponse> {
  const response = await axiosInstance.post(url, data);
  return response.data.data; // Extract from { success, message, data }
}
```

---

### 2. Friends Service (`services/friends.service.ts`)
**Purpose:** Handles all friend-related operations

**Key Methods:**
- `sendFriendRequest()` - Send friend request to user
- `acceptFriendRequest()` - Accept incoming request
- `rejectFriendRequest()` - Reject request
- `cancelFriendRequest()` - Cancel sent request
- `getPendingRequests()` - Get incoming requests
- `getSentRequests()` - Get sent requests
- `getFriends()` - Get friends list
- `removeFriend()` - Remove friend

**Used By:** `useFriends.ts` hooks

**Pattern:**
```typescript
// Service handles API calls and response extraction
// Hooks wrap service calls with React Query
```

---

### 3. Conversations Service (`services/conversations.service.ts`)
**Purpose:** Handles conversation management

**Key Methods:**
- `getOrCreateConversation()` - Get or create conversation with friend
- `getConversations()` - Get all user conversations
- `getConversation()` - Get single conversation
- `getOtherUser()` - Get other user in conversation
- `archiveConversation()` - Archive conversation
- `unarchiveConversation()` - Unarchive conversation
- `deleteConversation()` - Delete conversation

**Used By:** `useConversations.ts` hooks

---

### 4. Messages Service (`services/messages.service.ts`)
**Purpose:** Handles message operations

**Key Methods:**
- `sendMessage()` - Send message in conversation
- `getMessages()` - Get messages in conversation
- `editMessage()` - Edit message content
- `deleteMessage()` - Delete message (soft delete)
- `markAsRead()` - Mark messages as read
- `getReadReceipts()` - Get read receipts for message
- `reactToMessage()` - Add emoji reaction
- `removeReaction()` - Remove reaction
- `getReactions()` - Get all reactions on message
- `searchMessages()` - Search messages in conversation

**Used By:** `useMessages.ts` hooks

---

## React Hooks Layer

### Query Hooks (Read Operations)

```typescript
// Get data that can be cached and refetched
const { data, isLoading, error } = useFriendsList();

// Features:
// - Automatic caching
// - Background refetching
// - Stale-while-revalidate pattern
// - Optimistic updates possible
```

### Mutation Hooks (Write Operations)

```typescript
// Perform mutations with callbacks
const mutation = useSendMessage();

mutation.mutate(data, {
  onSuccess: (result) => {
    // Handle success
  },
  onError: (error) => {
    // Handle error
  },
});
```

### Available Hooks

**Friends Hooks:**
- `useSendFriendRequest()` - Send request mutation
- `useAcceptFriendRequest()` - Accept request mutation
- `useRejectFriendRequest()` - Reject request mutation
- `useCancelFriendRequest()` - Cancel request mutation
- `usePendingFriendRequests()` - Query pending requests
- `useSentFriendRequests()` - Query sent requests
- `useFriendsList()` - Query friends list
- `useRemoveFriend()` - Remove friend mutation

**Conversation Hooks:**
- `useGetOrCreateConversation()` - Create/get conversation mutation
- `useConversations()` - Query all conversations
- `useConversation()` - Query single conversation
- `useConversationOtherUser()` - Query other user in conversation
- `useArchiveConversation()` - Archive conversation mutation
- `useUnarchiveConversation()` - Unarchive conversation mutation
- `useDeleteConversation()` - Delete conversation mutation

**Message Hooks:**
- `useSendMessage()` - Send message mutation
- `useMessages()` - Query messages in conversation
- `useEditMessage()` - Edit message mutation
- `useDeleteMessage()` - Delete message mutation
- `useMarkAsRead()` - Mark messages as read mutation
- `useReadReceipts()` - Query read receipts
- `useReactToMessage()` - React to message mutation
- `useRemoveReaction()` - Remove reaction mutation
- `useMessageReactions()` - Query message reactions
- `useSearchMessages()` - Search messages query

---

## Component Integration Pattern

### Step 1: Import Hook
```typescript
import { useConversations } from "@/hooks/useConversations";
import { useFriendsList } from "@/hooks/useFriends";
```

### Step 2: Use Hook in Component
```typescript
const MyComponent = () => {
  const { data: conversations, isLoading, error } = useConversations();
  const { data: friends } = useFriendsList();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {conversations?.map(conv => (
        <ConversationItem key={conv.id} conversation={conv} />
      ))}
    </div>
  );
};
```

### Step 3: Handle Mutations
```typescript
const ChatComponent = () => {
  const sendMessage = useSendMessage();
  const conversations = useConversations();

  const handleSendMessage = (content: string) => {
    sendMessage.mutate(
      {
        conversationId: "uuid",
        content,
      },
      {
        onSuccess: (data) => {
          console.log("Message sent:", data);
          // Invalidate cache to refetch messages
          queryClient.invalidateQueries({
            queryKey: ["messages", "uuid"],
          });
        },
      }
    );
  };

  return (
    <input
      onKeyPress={(e) => {
        if (e.key === "Enter") {
          handleSendMessage(e.target.value);
        }
      }}
    />
  );
};
```

---

## Data Flow Architecture

### Query Flow (Reading Data)
```
Component ‚Üí Hook (useConversations) 
  ‚Üí React Query (caching/fetching)
    ‚Üí Service (conversationsService)
      ‚Üí Axios (HTTP request)
        ‚Üí Backend API
          ‚Üí Response
```

### Mutation Flow (Writing Data)
```
Component (handleSubmit)
  ‚Üí Mutation Hook (useSendMessage)
    ‚Üí React Query Mutation
      ‚Üí Service (messagesService)
        ‚Üí Axios (HTTP request)
          ‚Üí Backend API
            ‚Üí Response
              ‚Üí onSuccess callback
                ‚Üí Invalidate queries
                ‚Üí Update UI
```

---

## Error Handling Pattern

### Service Layer
```typescript
// Services throw errors naturally
try {
  const response = await axiosInstance.get(url);
  return response.data.data;
} catch (error) {
  // Axios interceptor handles 401 (token refresh)
  // Other errors bubble up to hooks
  throw error;
}
```

### Hook Layer
```typescript
useQuery({
  queryFn: () => friendsService.getFriends(),
  onError: (error) => {
    console.error("Fetch failed:", error);
    // Can add toast notification here
  },
});
```

### Component Layer
```typescript
const { data, error, isLoading } = useFriends();

if (error) {
  return <ErrorAlert message={error.message} />;
}
```

---

## Caching & Invalidation Strategy

### Query Keys
```typescript
// Format: [resource, params]
["friends"]
["friendRequests", "pending"]
["conversations", { limit: 50, offset: 0 }]
["messages", conversationId]
["readReceipts", messageId]
```

### Invalidation
```typescript
// After mutation, invalidate related queries
const mutation = useSendMessage();

mutation.mutate(data, {
  onSuccess: () => {
    // Refetch messages in this conversation
    queryClient.invalidateQueries({
      queryKey: ["messages", conversationId],
    });
    
    // Refetch conversations list
    queryClient.invalidateQueries({
      queryKey: ["conversations"],
    });
  },
});
```

---

## Real-time Integration (Socket.IO)

### Planned Socket.IO Events

**Friends:**
- `friendRequestReceived` - New friend request received
- `friendAdded` - Friend request accepted
- `friendRemoved` - Friend removed

**Conversations:**
- `newMessage` - New message in conversation
- `messageEdited` - Message was edited
- `messageDeleted` - Message was deleted
- `conversationArchived` - Conversation archived
- `conversationDeleted` - Conversation deleted

**Messages:**
- `messagesRead` - Messages marked as read by other user
- `userTyping` - Other user is typing
- `userStoppedTyping` - Other user stopped typing

**User Status:**
- `userStatusChanged` - User online/offline/away status changed

### Integration Pattern
```typescript
// Example: Listen for new messages
useEffect(() => {
  socket.on("newMessage", (message) => {
    // Update cache with new message
    queryClient.setQueryData(
      ["messages", conversationId],
      (old) => {
        return {
          ...old,
          messages: [...old.messages, message],
        };
      }
    );
  });

  return () => {
    socket.off("newMessage");
  };
}, [conversationId]);
```

---

## State Management Summary

### Where State Lives

**React Query (Queries):**
- Conversations list
- Messages in conversation
- Friends list
- Friend requests
- User profile

**React Query (Mutations):**
- Sending messages
- Accepting friend requests
- Creating conversations

**Local Component State:**
- Form inputs
- UI state (dropdowns, modals)
- Temporary UI flags

**Not Used:**
- Redux (complexity not needed)
- Context (React Query handles caching)

---

## Implementation Checklist

For each new feature, follow this checklist:

- [ ] Create service file in `services/`
  - [ ] Define TypeScript interfaces
  - [ ] Implement API methods
  - [ ] Extract data from response structure

- [ ] Create hooks file in `hooks/`
  - [ ] Create query hooks for reads
  - [ ] Create mutation hooks for writes
  - [ ] Add error logging

- [ ] Create/Update component
  - [ ] Import needed hooks
  - [ ] Handle loading state
  - [ ] Handle error state
  - [ ] Render data
  - [ ] Call mutations on user action

- [ ] Test integration
  - [ ] Mock API responses
  - [ ] Test success paths
  - [ ] Test error handling
  - [ ] Test cache invalidation

---

## File Structure Reference

```
src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ friends.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ conversations.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ messages.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ users.service.ts (planned)
‚îÇ
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îú‚îÄ‚îÄ useFriends.ts
‚îÇ   ‚îú‚îÄ‚îÄ useConversations.ts
‚îÇ   ‚îú‚îÄ‚îÄ useMessages.ts
‚îÇ   ‚îî‚îÄ‚îÄ useUsers.ts (planned)
‚îÇ
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ chats/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ friends/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ contacts/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ calls/
‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ form/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ buttons/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ navigation/
‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ axios.ts (configured with interceptors)
‚îÇ
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ index.ts
```

---

## Next Steps

1. **Update Chats Component**
   - Replace mock data with `useConversations()` hook
   - Use `useSendMessage()` for sending messages
   - Remove hardcoded chat list

2. **Create Friends Components**
   - Friends List page using `useFriendsList()`
   - Friend Requests page using `usePendingFriendRequests()`
   - Add friend button using `useSendFriendRequest()`

3. **Integrate Socket.IO**
   - Create Socket.IO context provider
   - Listen for real-time events
   - Update query cache on socket events
   - Implement typing indicators

4. **Add Message Features**
   - Message search using `useSearchMessages()`
   - Message reactions using `useReactToMessage()`
   - Message edit/delete using `useEditMessage()` and `useDeleteMessage()`

5. **Implement Call System**
   - Create calls.service.ts and useCall hooks
   - Call initiation and management
   - Call history viewing
</file>

<file path="client/MIDDLEWARE_GUIDE.md">
# Middleware Authentication Guide

## Overview

The middleware handles all route protection on the **server-side** before the page renders. This is the **best practice** approach for Next.js 13+ with App Router.

## How It Works

### 1. **Request Flow**
```
User requests /chats
   ‚Üì
Middleware intercepts request
   ‚Üì
Reads accessToken from cookies
   ‚Üì
Decodes JWT without verification (for basic checks)
   ‚Üì
Validates token expiry
   ‚Üì
Routes accordingly:
   - Protected route + no token ‚Üí Redirect to /signIn
   - Protected route + valid token ‚Üí Allow access
   - Auth route + valid token ‚Üí Redirect to /chats
   - Other routes ‚Üí Allow access
```

### 2. **Protected Routes**
```typescript
const protectedRoutes = ["/chats", "/calls", "/profile"];
```
These routes require a valid `accessToken` cookie.

### 3. **Auth Routes**
```typescript
const authRoutes = ["/signIn", "/signUp", "/forgotPassword", "/resetPassword", "/verifyEmail"];
```
If user is authenticated, they're redirected away from these routes to `/chats`.

## Token Validation

### JWT Decoding (Client-side Safe)
```typescript
function decodeJWT(token: string): any | null {
  const base64Payload = token.split(".")[1];
  const jsonPayload = atob(base64Payload.replace(/-/g, "+").replace(/_/g, "/"));
  return JSON.parse(jsonPayload);
}
```
- **Does NOT verify** the token signature (server will do that on API calls)
- Only checks if it can be decoded
- Checks expiry time (`exp` claim)

### Expiry Check
```typescript
const isExpired = decoded.exp && Date.now() >= decoded.exp * 1000;
```
- If expired ‚Üí Redirect to `/signIn`
- Server's axios interceptor will handle token refresh on API calls

## Middleware Matcher

```typescript
export const config = {
  matcher: [
    "/chats/:path*",      // /chats and all subroutes
    "/calls/:path*",      // /calls and all subroutes
    "/profile/:path*",    // /profile and all subroutes
    "/signIn",            // Auth routes
    "/signUp",
    "/forgotPassword",
    "/resetPassword",
    "/verifyEmail",
  ],
};
```

Routes NOT in the matcher won't run middleware (faster performance).

## Authentication Flow

### Login
```
1. User submits credentials
   ‚Üì
2. Server validates and returns accessToken
   ‚Üì
3. Server sets refreshToken as httpOnly cookie
   ‚Üì
4. Client stores accessToken in cookie (via tokenManager.setAccessToken)
   ‚Üì
5. Next navigation ‚Üí Middleware checks accessToken
   ‚Üì
6. Valid token ‚Üí Access granted to protected routes
```

### Logout
```
1. User clicks logout button
   ‚Üì
2. Client calls /auth/logout API
   ‚Üì
3. Server clears refreshToken cookie
   ‚Üì
4. Client clears accessToken cookie
   ‚Üì
5. Next navigation ‚Üí No accessToken found
   ‚Üì
6. Middleware redirects to /signIn
```

### Token Refresh (Automatic)
```
1. Protected route accessed with expired accessToken
   ‚Üì
2. Middleware allows request through (only checks expiry)
   ‚Üì
3. API call made with expired token
   ‚Üì
4. Server returns 401
   ‚Üì
5. Axios interceptor detects 401
   ‚Üì
6. Interceptor uses refreshToken (auto-sent in httpOnly cookie)
   ‚Üì
7. Server returns new accessToken
   ‚Üì
8. Axios retries original request with new token
   ‚Üì
9. Request succeeds
```

## Key Differences from Client-Side Guards

| Aspect | Middleware | Client-Side Guards |
|--------|------------|-------------------|
| **Timing** | Runs before page renders | Runs after page renders |
| **Performance** | Faster (no client-side checks) | Slower (component renders first) |
| **Flash** | No flash of wrong content | Potential flash of protected content |
| **Security** | Better (server-controlled) | Weaker (client can be bypassed) |
| **Token Validation** | Can check expiry server-side | Limited checks on client |
| **Best Practice** | ‚úÖ Recommended for Next.js | ‚ùå Not recommended |

## Configuration

### Adding New Protected Routes
1. Add route to `protectedRoutes` array
2. Add matcher pattern to `config.matcher`

Example:
```typescript
const protectedRoutes = ["/chats", "/calls", "/profile", "/settings"];
// Add to matcher:
"/settings/:path*",
```

### Adding New Auth Routes
1. Add route to `authRoutes` array
2. Add matcher pattern to `config.matcher`

Example:
```typescript
const authRoutes = [..., "/verify-email"];
// Add to matcher:
"/verify-email",
```

## Token Expiry Times

- **Access Token**: 30 minutes (JWT_EXPIRE="30m")
- **Refresh Token**: 7 days (JWT_REFRESH_EXPIRE="7d")

When access token expires:
- Middleware allows request (only warns about expiry)
- API call fails with 401
- Axios interceptor refreshes token automatically
- Request retried with new token

## Files Involved

- **`middleware.ts`** - Route protection logic
- **`src/lib/axios.ts`** - Token refresh interceptor
- **`src/hooks/useAuth.ts`** - Login/logout hooks
- **`.env`** - JWT configuration

## Testing

1. **Login** ‚Üí accessToken cookie set ‚Üí can access /chats
2. **Go to /signIn** ‚Üí already authenticated ‚Üí redirected to /chats
3. **Logout** ‚Üí accessToken cookie cleared ‚Üí redirected to /signIn
4. **Access /chats without token** ‚Üí redirected to /signIn
5. **Wait for token expiry** ‚Üí Next API call triggers refresh automatically

## Security Notes

‚úÖ **httpOnly cookies** - refreshToken safe from XSS  
‚úÖ **Server validation** - All tokens validated on API calls  
‚úÖ **Middleware check** - Prevents unauthorized page access  
‚úÖ **Automatic refresh** - Users stay logged in seamlessly  
‚úÖ **Token expiry** - Limits exposure time of compromised tokens

## Related Documentation

- Next.js Middleware: https://nextjs.org/docs/advanced-features/middleware
- JWT Best Practices: https://tools.ietf.org/html/rfc8725
- Server-Side Rendering: https://nextjs.org/docs/basic-features/rendering
</file>

<file path="client/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactCompiler: true,
};

export default nextConfig;
</file>

<file path="client/package.json">
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@tanstack/react-query": "^5.90.10",
    "axios": "^1.13.2",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "js-cookie": "^3.0.5",
    "jwt-decode": "^4.0.0",
    "lucide-react": "^0.554.0",
    "next": "16.0.3",
    "peerjs": "^1.5.5",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "react-hook-form": "^7.66.1",
    "simple-peer": "^9.11.1",
    "socket.io-client": "^4.8.1",
    "tailwind-merge": "^3.4.0",
    "zod": "^4.1.12",
    "zustand": "^4.4.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.0.0",
    "@types/js-cookie": "^3.0.6",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.22",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.3",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "ts-node": "^10.9.2",
    "typescript": "^5"
  }
}
</file>

<file path="client/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="client/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
"# Chat-App-Client" 
"# Chat-App-Client-"
</file>

<file path="client/SERVICES_HOOKS_REFERENCE.md">
# Services & Hooks Quick Reference

## Services Overview

### Location & Structure
```
src/services/
‚îú‚îÄ‚îÄ auth.service.ts          ‚úÖ Complete - Auth, registration, OAuth
‚îú‚îÄ‚îÄ friends.service.ts       ‚úÖ NEW - Friend requests, friends list
‚îú‚îÄ‚îÄ conversations.service.ts ‚úÖ NEW - Conversations management
‚îú‚îÄ‚îÄ messages.service.ts      ‚úÖ NEW - Messages, reactions, search
‚îî‚îÄ‚îÄ users.service.ts         üìã Planned
```

### Hooks Overview
```
src/hooks/
‚îú‚îÄ‚îÄ useAuth.ts               ‚úÖ Complete - Login, register, logout
‚îú‚îÄ‚îÄ useGoogleAuth.ts         ‚úÖ Complete - Google OAuth
‚îú‚îÄ‚îÄ useFriends.ts            ‚úÖ NEW - Friend operations
‚îú‚îÄ‚îÄ useConversations.ts      ‚úÖ NEW - Conversation operations
‚îî‚îÄ‚îÄ useMessages.ts           ‚úÖ NEW - Message operations
```

---

## Friends Service & Hook

### Service: `friendsService`

```typescript
import { friendsService } from "@/services/friends.service";

// Send friend request
await friendsService.sendFriendRequest({ recipientId: "uuid" });

// Get pending requests (incoming)
const { friendRequests } = await friendsService.getPendingRequests();

// Get sent requests (outgoing)
const { friendRequests } = await friendsService.getSentRequests();

// Accept request
await friendsService.acceptFriendRequest(requestId);

// Reject request
await friendsService.rejectFriendRequest(requestId);

// Cancel sent request
await friendsService.cancelFriendRequest(requestId);

// Get all friends
const { friends } = await friendsService.getFriends();

// Remove friend
await friendsService.removeFriend(friendId);
```

### Hooks: `useFriends`

```typescript
import {
  useSendFriendRequest,
  usePendingFriendRequests,
  useSentFriendRequests,
  useFriendsList,
  useAcceptFriendRequest,
  useRejectFriendRequest,
  useCancelFriendRequest,
  useRemoveFriend,
} from "@/hooks/useFriends";

// Query: Get pending requests
const { data: requests, isLoading } = usePendingFriendRequests();

// Query: Get friends list
const { data: friends } = useFriendsList();

// Mutation: Send request
const sendRequest = useSendFriendRequest();
sendRequest.mutate({ recipientId: "uuid" });

// Mutation: Accept request
const acceptRequest = useAcceptFriendRequest();
acceptRequest.mutate(requestId);

// Mutation: Reject request
const rejectRequest = useRejectFriendRequest();
rejectRequest.mutate(requestId);

// Mutation: Remove friend
const removeFriend = useRemoveFriend();
removeFriend.mutate(friendId);
```

---

## Conversations Service & Hook

### Service: `conversationsService`

```typescript
import { conversationsService } from "@/services/conversations.service";

// Get or create conversation
const { conversation } = await conversationsService.getOrCreateConversation({
  friendId: "uuid"
});

// Get all conversations
const { conversations, total } = await conversationsService.getConversations(
  limit = 50,
  offset = 0
);

// Get single conversation
const { conversation } = await conversationsService.getConversation(
  conversationId
);

// Get other user in conversation
const { user } = await conversationsService.getOtherUser(conversationId);

// Archive conversation
await conversationsService.archiveConversation({ conversationId });

// Unarchive conversation
await conversationsService.unarchiveConversation({ conversationId });

// Delete conversation
await conversationsService.deleteConversation({ conversationId });
```

### Hooks: `useConversations`

```typescript
import {
  useGetOrCreateConversation,
  useConversations,
  useConversation,
  useConversationOtherUser,
  useArchiveConversation,
  useUnarchiveConversation,
  useDeleteConversation,
} from "@/hooks/useConversations";

// Query: Get all conversations
const { data: conversations } = useConversations(limit, offset);

// Query: Get single conversation
const { data: conversation } = useConversation(conversationId);

// Query: Get other user
const { data: otherUser } = useConversationOtherUser(conversationId);

// Mutation: Create/get conversation
const createConversation = useGetOrCreateConversation();
createConversation.mutate(
  { friendId: "uuid" },
  {
    onSuccess: (data) => {
      router.push(`/chats/${data.conversation.id}`);
    },
  }
);

// Mutation: Archive
const archive = useArchiveConversation();
archive.mutate(conversationId);

// Mutation: Delete
const deleteConv = useDeleteConversation();
deleteConv.mutate(conversationId);
```

---

## Messages Service & Hook

### Service: `messagesService`

```typescript
import { messagesService } from "@/services/messages.service";

// Send message
const { message } = await messagesService.sendMessage({
  conversationId: "uuid",
  content: "Hello!",
});

// Get messages in conversation
const { messages, total } = await messagesService.getMessages(
  conversationId,
  limit = 50,
  offset = 0
);

// Edit message
await messagesService.editMessage({
  messageId: "uuid",
  content: "Updated message",
});

// Delete message (soft delete)
await messagesService.deleteMessage({ messageId: "uuid" });

// Mark as read
const { markedCount } = await messagesService.markAsRead({
  conversationId: "uuid",
  messageIds: ["uuid1", "uuid2"],
});

// Get read receipts
const readBy = await messagesService.getReadReceipts(messageId);

// React to message
const { reaction } = await messagesService.reactToMessage({
  messageId: "uuid",
  emoji: "üëç",
});

// Remove reaction
await messagesService.removeReaction({ reactionId: "uuid" });

// Get reactions
const reactions = await messagesService.getReactions(messageId);

// Search messages
const { messages: results } = await messagesService.searchMessages(
  query = "hello",
  conversationId,
  limit = 20
);
```

### Hooks: `useMessages`

```typescript
import {
  useSendMessage,
  useMessages,
  useEditMessage,
  useDeleteMessage,
  useMarkAsRead,
  useReadReceipts,
  useReactToMessage,
  useRemoveReaction,
  useMessageReactions,
  useSearchMessages,
} from "@/hooks/useMessages";

// Query: Get messages
const { data: messages, isLoading } = useMessages(conversationId);

// Query: Get read receipts
const { data: readReceipts } = useReadReceipts(messageId);

// Query: Get reactions
const { data: reactions } = useMessageReactions(messageId);

// Query: Search messages
const { data: searchResults } = useSearchMessages(query, conversationId);

// Mutation: Send message
const sendMessage = useSendMessage();
sendMessage.mutate({
  conversationId: "uuid",
  content: "Hello!",
});

// Mutation: Edit message
const editMessage = useEditMessage();
editMessage.mutate({
  messageId: "uuid",
  content: "Updated",
});

// Mutation: Delete message
const deleteMessage = useDeleteMessage();
deleteMessage.mutate({ messageId: "uuid" });

// Mutation: Mark as read
const markAsRead = useMarkAsRead();
markAsRead.mutate({
  conversationId: "uuid",
  messageIds: ["uuid1", "uuid2"],
});

// Mutation: React
const reactToMessage = useReactToMessage();
reactToMessage.mutate({
  messageId: "uuid",
  emoji: "üëç",
});

// Mutation: Remove reaction
const removeReaction = useRemoveReaction();
removeReaction.mutate({ reactionId: "uuid" });
```

---

## Common Usage Patterns

### Pattern 1: List with Loading
```typescript
const MyComponent = () => {
  const { data: items, isLoading, error } = useFriendsList();

  if (isLoading) return <Skeleton />;
  if (error) return <ErrorMessage />;

  return (
    <div>
      {items?.map((item) => (
        <ItemRow key={item.id} item={item} />
      ))}
    </div>
  );
};
```

### Pattern 2: Mutation with Callbacks
```typescript
const sendMessage = useSendMessage();

const handleSend = (content: string) => {
  sendMessage.mutate(
    { conversationId, content },
    {
      onSuccess: () => {
        // Refetch or update cache
        queryClient.invalidateQueries({
          queryKey: ["messages", conversationId],
        });
        // Reset form
        setContent("");
      },
      onError: (error) => {
        // Show error
        toast.error(error.message);
      },
    }
  );
};
```

### Pattern 3: Dependent Queries
```typescript
// Only fetch conversation when ID is available
const { data: conversation } = useConversation(conversationId);

// Only fetch messages when conversation is selected
const { data: messages } = useMessages(conversationId);
```

### Pattern 4: Pagination
```typescript
const [offset, setOffset] = useState(0);

const { data: conversations } = useConversations(50, offset);

const handleLoadMore = () => {
  setOffset((prev) => prev + 50);
};
```

---

## Error Handling

### In Service
Services throw errors naturally - no custom error handling needed.

### In Hooks
Hooks automatically pass errors to components via `error` property.

### In Component
```typescript
const { data, error, isLoading } = useFriendsList();

if (error) {
  return (
    <div className="text-red-500">
      {error?.message || "Failed to load friends"}
    </div>
  );
}
```

---

## Testing Patterns

### Mock Service
```typescript
jest.mock("@/services/friends.service", () => ({
  friendsService: {
    getFriends: jest.fn(() =>
      Promise.resolve({
        friends: [{ id: "1", name: "John" }],
      })
    ),
  },
}));
```

### Test Hook
```typescript
import { renderHook, waitFor } from "@testing-library/react";

test("useFriendsList loads friends", async () => {
  const { result } = renderHook(() => useFriendsList());

  await waitFor(() => {
    expect(result.current.data).toBeDefined();
  });
});
```

---

## TypeScript Interfaces

### Friends
```typescript
interface Friend {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  status: "online" | "offline" | "away";
  bio?: string;
}

interface FriendRequest {
  id: string;
  senderId: string;
  sender: Friend;
  status: "pending" | "accepted" | "rejected";
  createdAt: string;
}
```

### Conversations
```typescript
interface Conversation {
  id: string;
  participants: ConversationUser[];
  lastMessage?: Message;
  unreadCount: number;
  isArchived: boolean;
  createdAt: string;
}
```

### Messages
```typescript
interface Message {
  id: string;
  conversationId: string;
  content: string;
  sender: { id: string; name: string };
  isRead: boolean;
  isEdited?: boolean;
  isDeleted?: boolean;
  createdAt: string;
}
```

---

## Troubleshooting

### Query not updating after mutation
**Solution:** Call `queryClient.invalidateQueries()` after successful mutation
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: ["friends"] });
}
```

### Loading never resolves
**Solution:** Check if query has `enabled: false` or is missing required parameters

### Type errors on response
**Solution:** Verify the service extracts correct data from API response structure

### Stale data showing
**Solution:** Manually invalidate cache or adjust staleTime in query options
</file>

<file path="client/src/app/(auth)/forgotPassword/page.tsx">
import ForgotPassword from "@/components/pages/auth/forgotPassword";

export default function ForgotPasswordPage() {
  return <ForgotPassword />;
}
</file>

<file path="client/src/app/(auth)/google-callback/page.tsx">
import GoogleCallback from "@/components/pages/auth/googleCallback";

const GoogleCallbackPage = () => <GoogleCallback />;

export default GoogleCallbackPage;
</file>

<file path="client/src/app/(auth)/layout.tsx">
import { AuthLayout } from "@/components/layout/authLayout";

export default function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <AuthLayout>{children}</AuthLayout>;
}
</file>

<file path="client/src/app/(auth)/resetPassword/page.tsx">
import ResetPassword from "@/components/pages/auth/resetPassword";

export default function ResetPasswordPage() {
  return <ResetPassword />;
}
</file>

<file path="client/src/app/(auth)/signIn/page.tsx">
import SignIn from "@/components/pages/auth/signIn";

const SignInPage = () => <SignIn />;

export default SignInPage;
</file>

<file path="client/src/app/(auth)/signUp/page.tsx">
import SignUp from "@/components/pages/auth/signUp";

const SignUpPage = () => <SignUp />;

export default SignUpPage;
</file>

<file path="client/src/app/(auth)/verifyEmail/page.tsx">
import VerifyEmail from "@/components/pages/auth/verifyEmail";

export default function VerifyEmailPage() {
  return <VerifyEmail />;
}
</file>

<file path="client/src/app/(main)/chats/page.tsx">
import Chats from "@/components/pages/main/chats";

const ChatsPage = () => <Chats />;

export default ChatsPage;
</file>

<file path="client/src/app/(main)/friendsRequests/page.tsx">
import FriendsRequests from "@/components/pages/main/friendsRequests";

const FriendsRequestsPage = () => <FriendsRequests />;

export default FriendsRequestsPage;
</file>

<file path="client/src/app/(main)/layout.tsx">
import { MainLayout } from "@/components/layout/mainLayout";

export default function MainAppLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <MainLayout>{children}</MainLayout>;
}
</file>

<file path="client/src/app/(main)/profile/page.tsx">
import Profile from "@/components/pages/main/profile";

const ProfilePage = () => <Profile />;

export default ProfilePage;
</file>

<file path="client/src/app/layout.tsx">
import type { Metadata, Viewport } from "next";
import { Inter, Poppins } from "next/font/google";
import "@/styles/globals.css";
import { Providers } from "@/providers";

const inter = Inter({
  subsets: ["latin"],
  weight: ["300", "400", "500", "600", "700"],
  variable: "--font-inter",
  display: "swap",
});

// Poppins for headings and display text
const poppins = Poppins({
  subsets: ["latin"],
  weight: ["400", "500", "600", "700", "800"],
  variable: "--font-poppins",
  display: "swap",
});

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  themeColor: "#37475a",
};

export const metadata: Metadata = {
  title: "Chat App",
  description:
    "Modern real-time chat application with video calls, file sharing, and more",
  keywords: ["chat", "messaging", "video call", "real-time", "communication"],
  authors: [{ name: "Chat App Team" }],
  icons: {
    icon: "/favicon.ico",
    apple: "/apple-touch-icon.png",
  },
  appleWebApp: {
    capable: true,
    statusBarStyle: "default",
    title: "Chat App",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html
      lang="en"
      className={`${inter.variable} ${poppins.variable}`}
      suppressHydrationWarning
    >
      <body className={`${inter.className} antialiased overflow-hidden`}>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="client/src/app/page.tsx">
/**
 * Root Page (/)
 * Middleware handles redirection:
 * - If authenticated: redirects to /chats
 * - If not authenticated: redirects to /signIn
 */
export default function MainPage() {
  return null;
}
</file>

<file path="client/src/components/layout/authLayout.tsx">
import React from "react";

interface AuthLayoutProps {
  children: React.ReactNode;
}

export function AuthLayout({ children }: AuthLayoutProps) {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-main">
      <div className="w-full">
        {children}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/layout/mainLayout.tsx">
import React from "react";
import { Sidebar } from "../ui/navigation/Sidebar";
import { Panel } from "../ui/display/Panel";

interface MainLayoutProps {
  children: React.ReactNode;
}

export function MainLayout({ children }: MainLayoutProps) {
  return (
    <div className="h-screen w-full flex overflow-hidden bg-main">
      <Sidebar />
      <Panel>{children}</Panel>
      <main className="flex-1 flex flex-col overflow-hidden bg-main">
        <div className="flex-1 flex items-center justify-center">
          <p className="text-sm text-secondary">
            Select a chat to start messaging
          </p>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="client/src/components/pages/auth/forgotPassword/index.tsx">
"use client";

import AuthContainer from "@/components/ui/display/AuthContainer";
import {
  Button,
  FormHeader,
  Input,
  AuthSwitchLink,
} from "@/components/ui/form";
import ErrorAlert from "@/components/ui/feedback/ErrorAlert";
import { useForgotPassword } from "./useForgotPassword";

const ForgotPassword = () => {
  const {
    email,
    errors,
    generalError,
    successMessage,
    handleChange,
    handleSubmit,
    isLoading,
    clearGeneralError,
    clearSuccessMessage,
  } = useForgotPassword();

  return (
    <AuthContainer>
      <form
        onSubmit={handleSubmit}
        className="w-full md:w-1/2 xl:w-1/3 flex flex-col gap-4 z-20"
      >
        <FormHeader
          title="Reset Password"
          subtitle="Enter your email to receive a password reset link."
        />

        {generalError && (
          <ErrorAlert message={generalError} onDismiss={clearGeneralError} />
        )}

        {successMessage && (
          <div className="bg-green-50 border border-green-200 rounded-lg p-3 text-sm text-green-700 flex justify-between items-center">
            <span>{successMessage}</span>
            <button
              type="button"
              onClick={clearSuccessMessage}
              className="text-green-700 hover:text-green-900 font-bold"
            >
              ‚úï
            </button>
          </div>
        )}

        <Input
          label="Email Address"
          type="email"
          value={email}
          onChange={(e) => handleChange(e.target.value)}
          error={errors.email}
        />

        <Button type="submit" isLoading={isLoading}>
          {isLoading ? "Sending..." : "Send Reset Link"}
        </Button>

        <AuthSwitchLink mode="signin" />
      </form>
    </AuthContainer>
  );
};

export default ForgotPassword;
</file>

<file path="client/src/components/pages/auth/forgotPassword/useForgotPassword.ts">
"use client";

import { useState } from "react";
import { AxiosError } from "axios";
import { useRequestPasswordReset } from "@/hooks/useAuth";

export const useForgotPassword = () => {
  const [email, setEmail] = useState("");
  const [errors, setErrors] = useState<{ email?: string }>({});
  const [generalError, setGeneralError] = useState<string>("");
  const [successMessage, setSuccessMessage] = useState<string>("");
  const forgotPasswordMutation = useRequestPasswordReset();

  // Validation
  const validateForm = (): boolean => {
    const newErrors: { email?: string } = {};
    setGeneralError("");

    if (!email) {
      newErrors.email = "Email is required";
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      newErrors.email = "Invalid email format";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle input change
  const handleChange = (value: string) => {
    setEmail(value);
    if (errors.email) {
      setErrors({});
    }
    if (generalError) {
      setGeneralError("");
    }
    if (successMessage) {
      setSuccessMessage("");
    }
  };

  // Handle form submit
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    forgotPasswordMutation.mutate(email, {
      onSuccess: () => {
        setSuccessMessage(
          "Password reset link has been sent to your email. Please check your inbox."
        );
        setEmail("");
      },
      onError: (error: Error) => {
        const axiosError = error as AxiosError<{ message: string }>;
        const errorMessage =
          axiosError?.response?.data?.message ||
          "Failed to send reset email. Please try again.";
        setGeneralError(errorMessage);
      },
    });
  };

  return {
    email,
    errors,
    generalError,
    successMessage,
    handleChange,
    handleSubmit,
    clearGeneralError: () => setGeneralError(""),
    clearSuccessMessage: () => setSuccessMessage(""),
    isLoading: forgotPasswordMutation.isPending,
  };
};
</file>

<file path="client/src/components/pages/auth/googleCallback/index.tsx">
"use client";

import AuthContainer from "@/components/ui/display/AuthContainer";
import { FormHeader } from "@/components/ui/form";
import ErrorAlert from "@/components/ui/feedback/ErrorAlert";
import { useGoogleCallback } from "./useGoogleCallback";

const GoogleCallback = () => {
  const { errorMessage } = useGoogleCallback();

  return (
    <AuthContainer>
      <div className="w-full md:w-1/2 xl:w-1/3 flex flex-col gap-4 z-20">
        {errorMessage ? (
          <>
            <FormHeader
              title="Authentication Failed"
              subtitle="Redirecting you back to sign in..."
            />
            <ErrorAlert message={errorMessage} onDismiss={() => {}} />
          </>
        ) : (
          <>
            <FormHeader
              title="Completing Sign In"
              subtitle="Please wait while we complete your authentication..."
            />
            <div className="flex justify-center py-8">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primaryColor"></div>
            </div>
            <p className="text-center text-gray-600 text-sm">
              Verifying your Google account and setting up your session...
            </p>
          </>
        )}
      </div>
    </AuthContainer>
  );
};

export default GoogleCallback;
</file>

<file path="client/src/components/pages/auth/googleCallback/useGoogleCallback.ts">
"use client";

import { useMemo, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { tokenManager } from "@/lib/axios";

export const useGoogleCallback = () => {
  const router = useRouter();
  const searchParams = useSearchParams();

  // Process auth data - compute once without side effects
  const errorMessage = useMemo(() => {
    const token = searchParams.get("token");
    const userJson = searchParams.get("user");

    // Validation: missing data
    if (!token || !userJson) {
      return "Invalid callback: missing token or user data";
    }

    try {
      // Parse user data (validates JSON structure)
      JSON.parse(decodeURIComponent(userJson));

      // Store access token
      tokenManager.setAccessToken(token);

      return "";
    } catch (err) {
      console.error("Error processing Google callback:", err);
      return "Failed to process authentication. Please try again.";
    }
  }, [searchParams]);

  // Handle navigation after processing
  useEffect(() => {
    if (errorMessage) {
      // Redirect to sign in on error after delay
      const timer = setTimeout(() => router.push("/signIn"), 2000);
      return () => clearTimeout(timer);
    } else {
      // Redirect to main app on success
      const timer = setTimeout(() => router.push("/chats"), 1000);
      return () => clearTimeout(timer);
    }
  }, [errorMessage, router]);

  return { errorMessage };
};
</file>

<file path="client/src/components/pages/auth/resetPassword/index.tsx">
"use client";

import AuthContainer from "@/components/ui/display/AuthContainer";
import {
  Button,
  FormHeader,
  Input,
} from "@/components/ui/form";
import ErrorAlert from "@/components/ui/feedback/ErrorAlert";
import { useResetPasswordForm } from "./useResetPasswordForm";

const ResetPassword = () => {
  const {
    token,
    password,
    confirmPassword,
    errors,
    generalError,
    handleChange,
    handleSubmit,
    isLoading,
    clearGeneralError,
  } = useResetPasswordForm();

  if (!token) {
    return (
      <AuthContainer>
        <div className="w-full md:w-1/2 lg:w-1/3 flex flex-col gap-4 z-20">
          <ErrorAlert 
            message="Invalid or missing reset token. Please request a new password reset link."
            onDismiss={() => {}}
          />
        </div>
      </AuthContainer>
    );
  }

  return (
    <AuthContainer>
      <form
        onSubmit={handleSubmit}
        className="w-full md:w-1/2 xl:w-1/3 flex flex-col gap-4 z-20"
      >
        <FormHeader
          title="Create New Password"
          subtitle="Enter your new password below."
        />

        {generalError && (
          <ErrorAlert message={generalError} onDismiss={clearGeneralError} />
        )}

        <Input
          label="New Password"
          type="password"
          value={password}
          onChange={(e) => handleChange("password", e.target.value)}
          error={errors.password}
        />

        <Input
          label="Confirm Password"
          type="password"
          value={confirmPassword}
          onChange={(e) => handleChange("confirmPassword", e.target.value)}
          error={errors.confirmPassword}
        />

        <Button type="submit" isLoading={isLoading}>
          {isLoading ? "Resetting..." : "Reset Password"}
        </Button>
      </form>
    </AuthContainer>
  );
};

export default ResetPassword;
</file>

<file path="client/src/components/pages/auth/resetPassword/useResetPasswordForm.ts">
"use client";

import { useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { AxiosError } from "axios";
import { useResetPassword } from "@/hooks/useAuth";

export const useResetPasswordForm = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const token = searchParams.get("token") || "";

  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [errors, setErrors] = useState<{ password?: string; confirmPassword?: string }>({});
  const [generalError, setGeneralError] = useState<string>("");
  const resetPasswordMutation = useResetPassword();

  // Validation
  const validateForm = (): boolean => {
    const newErrors: { password?: string; confirmPassword?: string } = {};
    setGeneralError("");

    if (!password) {
      newErrors.password = "Password is required";
    } else if (password.length < 6) {
      newErrors.password = "Password must be at least 6 characters";
    }

    if (!confirmPassword) {
      newErrors.confirmPassword = "Please confirm your password";
    } else if (password !== confirmPassword) {
      newErrors.confirmPassword = "Passwords do not match";
    }

    if (!token) {
      setGeneralError("Invalid reset token. Please request a new password reset.");
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0 && !!token;
  };

  // Handle input change
  const handleChange = (field: "password" | "confirmPassword", value: string) => {
    if (field === "password") {
      setPassword(value);
    } else {
      setConfirmPassword(value);
    }
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: undefined,
      }));
    }
    if (generalError) {
      setGeneralError("");
    }
  };

  // Handle form submit
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    resetPasswordMutation.mutate(
      { token, newPassword: password },
      {
        onSuccess: () => {
          router.push("/signIn?message=Password reset successfully. Please sign in.");
        },
        onError: (error: Error) => {
          const axiosError = error as AxiosError<{ message: string }>;
          const errorMessage =
            axiosError?.response?.data?.message ||
            "Failed to reset password. Please try again.";
          setGeneralError(errorMessage);
        },
      }
    );
  };

  return {
    token,
    password,
    confirmPassword,
    errors,
    generalError,
    handleChange,
    handleSubmit,
    clearGeneralError: () => setGeneralError(""),
    isLoading: resetPasswordMutation.isPending,
  };
};
</file>

<file path="client/src/components/pages/auth/signIn/index.tsx">
"use client";

import AuthContainer from "@/components/ui/display/AuthContainer";
import {
  Button,
  GoogleButton,
  FormHeader,
  Milestone,
  Input,
  ForgetPassword,
  AuthSwitchLink,
} from "@/components/ui/form";
import ErrorAlert from "@/components/ui/feedback/ErrorAlert";
import { useSignIn } from "./useSignIn";

const SignIn = () => {
  const {
    formData,
    errors,
    generalError,
    handleChange,
    handleSubmit,
    isLoading,
    clearGeneralError,
  } = useSignIn();

  return (
    <AuthContainer>
      <form
        onSubmit={handleSubmit}
        className="w-full md:w-1/2 xl:w-1/3 flex flex-col gap-4 z-20"
      >
        <FormHeader
          title="Welcome Back !"
          subtitle="Sign in to continue to Doot."
        />

        {generalError && (
          <ErrorAlert message={generalError} onDismiss={clearGeneralError} />
        )}

        <Input
          label="Email"
          type="email"
          value={formData.email}
          onChange={(e) => handleChange("email", e.target.value)}
          error={errors.email}
        />

        <Input
          label="Password"
          type="password"
          value={formData.password}
          onChange={(e) => handleChange("password", e.target.value)}
          error={errors.password}
        />

        <ForgetPassword />

        <Button type="submit" isLoading={isLoading}>
          {isLoading ? "Signing In..." : "Sign In"}
        </Button>

        <Milestone title="Sign in with" />

        <GoogleButton />

        <AuthSwitchLink mode="signIn" />
      </form>
    </AuthContainer>
  );
};

export default SignIn;
</file>

<file path="client/src/components/pages/auth/signIn/useSignIn.ts">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { AxiosError } from "axios";
import { useLogin } from "@/hooks/useAuth";
import { LoginRequest } from "@/services/auth.service";

export const useSignIn = () => {
  const router = useRouter();
  const loginMutation = useLogin();

  // Form state
  const [formData, setFormData] = useState<LoginRequest>({
    email: "",
    password: "",
  });

  const [errors, setErrors] = useState<Partial<LoginRequest>>({});
  const [generalError, setGeneralError] = useState<string>("");

  // Validation
  const validateForm = (): boolean => {
    const newErrors: Partial<LoginRequest> = {};
    setGeneralError("");

    if (!formData.email) {
      newErrors.email = "Email is required";
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = "Invalid email format";
    }

    if (!formData.password) {
      newErrors.password = "Password is required";
    } else if (formData.password.length < 6) {
      newErrors.password = "Password must be at least 6 characters";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle input change
  const handleChange = (field: keyof LoginRequest, value: string) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: undefined,
      }));
    }
    if (generalError) {
      setGeneralError("");
    }
  };

  // Handle form submit
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    loginMutation.mutate(formData, {
      onSuccess: () => {
        // Use router.push for proper SPA navigation
        router.push("/chats");
      },
      onError: (error: Error) => {
        const axiosError = error as AxiosError<{ message: string }>;
        const errorMessage =
          axiosError?.response?.data?.message ||
          "Login failed. Please try again.";
        setGeneralError(errorMessage);
      },
    });
  };

  return {
    formData,
    errors,
    generalError,
    handleChange,
    handleSubmit,
    clearGeneralError: () => setGeneralError(""),
    isLoading: loginMutation.isPending,
    isError: loginMutation.isError,
  };
};
</file>

<file path="client/src/components/pages/auth/signUp/index.tsx">
"use client";

import AuthContainer from "@/components/ui/display/AuthContainer";
import {
  Button,
  GoogleButton,
  FormHeader,
  Input,
  AuthSwitchLink,
} from "@/components/ui/form";
import ErrorAlert from "@/components/ui/feedback/ErrorAlert";
import { useSignUp } from "./useSignUp";

const SignUp = () => {
  const {
    formData,
    errors,
    generalError,
    handleChange,
    handleSubmit,
    isLoading,
    clearGeneralError,
  } = useSignUp();

  return (
    <AuthContainer>
      <form
        onSubmit={handleSubmit}
        className="w-full md:w-1/2 xl:w-1/3 flex flex-col gap-4 z-20"
      >
        <FormHeader
          title="Create Account"
          subtitle="Join Doot and start chatting."
        />

        {generalError && (
          <ErrorAlert message={generalError} onDismiss={clearGeneralError} />
        )}

        <Input
          label="Full Name"
          type="text"
          value={formData.name}
          onChange={(e) => handleChange("name", e.target.value)}
          error={errors.name}
        />

        <Input
          label="Email"
          type="email"
          value={formData.email}
          onChange={(e) => handleChange("email", e.target.value)}
          error={errors.email}
        />

        <Input
          label="Password"
          type="password"
          value={formData.password}
          onChange={(e) => handleChange("password", e.target.value)}
          error={errors.password}
        />

        <Button type="submit" isLoading={isLoading}>
          {isLoading ? "Creating Account..." : "Sign Up"}
        </Button>

        <GoogleButton text="Sign Up with Google" />

        <AuthSwitchLink mode="signUp" />
      </form>
    </AuthContainer>
  );
};

export default SignUp;
</file>

<file path="client/src/components/pages/auth/signUp/useSignUp.ts">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { AxiosError } from "axios";
import { useRegister } from "@/hooks/useAuth";
import { RegisterRequest, RegisterResponse } from "@/services/auth.service";

export const useSignUp = () => {
  const router = useRouter();
  const registerMutation = useRegister();

  // Form state
  const [formData, setFormData] = useState<RegisterRequest>({
    name: "",
    email: "",
    password: "",
  });

  const [errors, setErrors] = useState<Partial<RegisterRequest>>({});
  const [generalError, setGeneralError] = useState<string>("");

  // Validation
  const validateForm = (): boolean => {
    const newErrors: Partial<RegisterRequest> = {};
    setGeneralError("");

    if (!formData.name) {
      newErrors.name = "Name is required";
    } else if (formData.name.length < 2) {
      newErrors.name = "Name must be at least 2 characters";
    }

    if (!formData.email) {
      newErrors.email = "Email is required";
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = "Invalid email format";
    }

    if (!formData.password) {
      newErrors.password = "Password is required";
    } else if (formData.password.length < 6) {
      newErrors.password = "Password must be at least 6 characters";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle input change
  const handleChange = (field: keyof RegisterRequest, value: string) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: undefined,
      }));
    }
    if (generalError) {
      setGeneralError("");
    }
  };

  // Handle form submit
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    registerMutation.mutate(formData, {
      onSuccess: (data: RegisterResponse) => {
        router.push(
          `/verifyEmail?email=${encodeURIComponent(formData.email)}&token=${encodeURIComponent(data.verificationToken)}`
        );
      },
      onError: (error: Error) => {
        const axiosError = error as AxiosError<{ message: string }>;
        const errorMessage =
          axiosError?.response?.data?.message ||
          "Registration failed. Please try again.";
        setGeneralError(errorMessage);
      },
    });
  };

  return {
    formData,
    errors,
    generalError,
    handleChange,
    handleSubmit,
    clearGeneralError: () => setGeneralError(""),
    isLoading: registerMutation.isPending,
  };
};
</file>

<file path="client/src/components/pages/auth/verifyEmail/index.tsx">
"use client";

import AuthContainer from "@/components/ui/display/AuthContainer";
import {
  Button,
  FormHeader,
  Input,
} from "@/components/ui/form";
import ErrorAlert from "@/components/ui/feedback/ErrorAlert";
import { useVerifyEmailForm } from "./useVerifyEmailForm";

const VerifyEmail = () => {
  const {
    email,
    verificationCode,
    errors,
    generalError,
    successMessage,
    resendCooldown,
    handleChange,
    handleSubmit,
    handleResendVerification,
    isLoading,
    isResending,
    clearGeneralError,
    clearSuccessMessage,
  } = useVerifyEmailForm();

  return (
    <AuthContainer>
      <form
        onSubmit={handleSubmit}
        className="w-full md:w-1/2 xl:w-1/3 flex flex-col gap-4 z-20"
      >
        <FormHeader
          title="Verify Email"
          subtitle="Enter the verification code sent to your email."
        />

        {generalError && (
          <ErrorAlert message={generalError} onDismiss={clearGeneralError} />
        )}

        {successMessage && (
          <div className="bg-green-50 border border-green-200 rounded-lg p-3 text-sm text-green-700 flex justify-between items-center">
            <span>{successMessage}</span>
            <button
              type="button"
              onClick={clearSuccessMessage}
              className="text-green-700 hover:text-green-900 font-bold"
            >
              ‚úï
            </button>
          </div>
        )}

        {email && (
          <div className="text-sm text-gray-600">
            Verification code sent to: <span className="font-semibold">{email}</span>
          </div>
        )}

        <Input
          label="Verification Code"
          type="text"
          value={verificationCode}
          onChange={(e) => handleChange(e.target.value)}
          error={errors.code}
        />

        <Button type="submit" isLoading={isLoading}>
          {isLoading ? "Verifying..." : "Verify Email"}
        </Button>

        <div className="text-center">
          <p className="text-sm text-gray-600 mb-2">
            Didn&apos;t receive the code?
          </p>
          <button
            type="button"
            onClick={handleResendVerification}
            disabled={resendCooldown > 0 || isResending}
            className={`text-sm font-semibold transition-colors ${
              resendCooldown > 0 || isResending
                ? "text-gray-400 cursor-not-allowed"
                : "text-blue-600 hover:text-blue-800"
            }`}
          >
            {isResending
              ? "Sending..."
              : resendCooldown > 0
              ? `Resend in ${resendCooldown}s`
              : "Resend Code"}
          </button>
        </div>
      </form>
    </AuthContainer>
  );
};

export default VerifyEmail;
</file>

<file path="client/src/components/pages/auth/verifyEmail/useVerifyEmailForm.ts">
"use client";

import { useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { AxiosError } from "axios";
import { useVerifyEmail, useResendVerification } from "@/hooks/useAuth";

export const useVerifyEmailForm = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const token = searchParams.get("token") || "";
  const email = searchParams.get("email") || "";

  // Pre-fill with token if available, otherwise empty string
  const [verificationCode, setVerificationCode] = useState(token);
  const [errors, setErrors] = useState<{ code?: string }>({});
  const [generalError, setGeneralError] = useState<string>("");
  const [successMessage, setSuccessMessage] = useState<string>("");
  const [resendCooldown, setResendCooldown] = useState(0);

  const verifyEmailMutation = useVerifyEmail();
  const resendVerificationMutation = useResendVerification();

  const validateForm = (): boolean => {
    const newErrors: { code?: string } = {};
    setGeneralError("");

    if (!verificationCode) {
      newErrors.code = "Verification code is required";
    } else if (verificationCode.length < 6) {
      newErrors.code = "Verification code must be at least 6 characters";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (value: string) => {
    setVerificationCode(value);
    if (errors.code) setErrors({});
    if (generalError) setGeneralError("");
  };

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (!validateForm()) return;

    verifyEmailMutation.mutate(verificationCode, {
      onSuccess: () => {
        setSuccessMessage("Email verified successfully! Redirecting to login...");
        setTimeout(() => router.push("/signIn"), 2000);
      },
      onError: (error: Error) => {
        const axiosError = error as AxiosError<{ message: string }>;
        const errorMessage =
          axiosError?.response?.data?.message ||
          "Email verification failed. Please try again.";
        setGeneralError(errorMessage);
      },
    });
  };

  const handleResendVerification = () => {
    if (!email) {
      setGeneralError("Email is required to resend verification code.");
      return;
    }

    resendVerificationMutation.mutate(email, {
      onSuccess: () => {
        setSuccessMessage("Verification code sent to your email!");
        setResendCooldown(60);
        setVerificationCode(""); // Clear input after resend
      },
      onError: (error: Error) => {
        const axiosError = error as AxiosError<{ message: string }>;
        const errorMessage =
          axiosError?.response?.data?.message ||
          "Failed to resend verification code. Please try again.";
        setGeneralError(errorMessage);
      },
    });
  };

  return {
    email,
    verificationCode,
    errors,
    generalError,
    successMessage,
    resendCooldown,
    handleChange,
    handleSubmit,
    handleResendVerification,
    clearGeneralError: () => setGeneralError(""),
    clearSuccessMessage: () => setSuccessMessage(""),
    isLoading: verifyEmailMutation.isPending,
    isResending: resendVerificationMutation.isPending,
  };
};
</file>

<file path="client/src/components/pages/main/chats/index.tsx">
"use client";

import { useState } from "react";
import { Search } from "lucide-react";
import { useConversations } from "@/hooks/useConversations";
import { useRouter } from "next/navigation";
import { AddButton } from "@/components/ui/buttons/AddButton";
import type { ConversationListItem } from "@/services/conversations.service";

const Chats = () => {
  const [searchQuery, setSearchQuery] = useState("");
  const router = useRouter();
  const { data: conversations = [], isLoading } = useConversations(50, 0);

  // Filter conversations based on search
  const filteredConversations = conversations.filter((conv: ConversationListItem) =>
    conv.otherUser?.name
      ?.toLowerCase()
      .includes(searchQuery.toLowerCase())
  );

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="p-4 border-b border-border bg-panel">
        <div className="flex items-center justify-between mb-3">
          <h1 className="text-lg font-semibold text-primary">Chats</h1>
          <AddButton size="md" title="Start new chat" />
        </div>

        {/* Search Bar */}
        <div className="relative">
          <Search
            className="absolute left-2.5 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-secondary"
            strokeWidth={2}
          />
          <input
            type="text"
            placeholder="Search here..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-8 pr-3 py-2 bg-search-bg border-0 rounded-md text-xs text-primary placeholder:text-secondary focus:outline-none focus:ring-1 focus:ring-primaryColor/30"
          />
        </div>
      </div>

      {/* Chat Lists */}
      <div className="flex-1 overflow-y-auto bg-panel">
        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-xs text-secondary">Loading conversations...</p>
          </div>
        ) : filteredConversations.length === 0 ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-xs text-secondary">
              {conversations.length === 0
                ? "No conversations yet"
                : "No conversations match your search"}
            </p>
          </div>
        ) : (
          <div className="px-4 py-3">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-[10px] font-semibold text-secondary uppercase tracking-wider">
                Conversations ({filteredConversations.length})
              </h3>
              <AddButton size="sm" title="New conversation" />
            </div>
            <div className="space-y-1">
              {filteredConversations.map((conversation) => (
                <ConversationItem
                  key={conversation.id}
                  conversation={conversation}
                  onClick={() => router.push(`/chats/${conversation.id}`)}
                />
              ))}
            </div>
          </div>
        )}
      </div>

    </div>
  );
};

// Conversation Item Component
function ConversationItem({
  conversation,
  onClick,
}: {
  conversation: ConversationListItem;
  onClick: () => void;
}) {
  const otherUser = conversation.otherUser;
  const lastMessage = conversation.lastMessage;
  const unreadCount = conversation.unreadCount || 0;

  const getTimeString = (date: string) => {
    const msgDate = new Date(date);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (msgDate.toDateString() === today.toDateString()) {
      return msgDate.toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
      });
    } else if (msgDate.toDateString() === yesterday.toDateString()) {
      return "Yesterday";
    } else {
      return msgDate.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
      });
    }
  };

  return (
    <button
      type="button"
      onClick={onClick}
      className="w-full flex items-center gap-2.5 p-2 rounded-md hover:bg-chat-hover transition-colors group"
    >
      {/* Avatar with online indicator */}
      <div className="relative flex-shrink-0">
        <div className="w-9 h-9 rounded-full bg-primaryColor/20 flex items-center justify-center text-primaryColor text-xs font-semibold">
          {otherUser.name?.[0]?.toUpperCase() || "U"}
        </div>
      </div>

      {/* Chat Info */}
      <div className="flex-1 min-w-0 text-left">
        <div className="flex items-center justify-between mb-0.5">
          <h4 className="text-sm font-medium text-primary truncate">
            {otherUser.name}
          </h4>
          {lastMessage && (
            <span className="text-[10px] text-secondary flex-shrink-0 ml-2">
              {getTimeString(lastMessage.createdAt)}
            </span>
          )}
        </div>
        <p className="text-xs text-secondary truncate">
          {lastMessage?.content || "No messages yet"}
        </p>
      </div>

      {/* Unread Badge */}
      <div className="flex items-center gap-1.5 flex-shrink-0">
        {unreadCount > 0 && (
          <div className="min-w-[18px] h-[18px] px-1.5 bg-primaryColor rounded-full flex items-center justify-center">
            <span className="text-[10px] text-white font-semibold leading-none">
              {unreadCount}
            </span>
          </div>
        )}
      </div>
    </button>
  );
}

export default Chats;
</file>

<file path="client/src/components/pages/main/friendsRequests/index.tsx">
"use client";

import React, { useState } from "react";
import { Search, Check, X } from "lucide-react";
import {
  usePendingFriendRequests,
  useSentFriendRequests,
  useAcceptFriendRequest,
  useRejectFriendRequest,
  useCancelFriendRequest,
} from "@/hooks/useFriends";
import type { FriendRequest } from "@/services/friends.service";

const FriendsRequests = () => {
  const [activeTab, setActiveTab] = useState<"pending" | "sent">("pending");
  const [searchQuery, setSearchQuery] = useState("");

  // Queries
  const { data: pendingRequests = [], isLoading: pendingLoading } =
    usePendingFriendRequests();
  const { data: sentRequests = [], isLoading: sentLoading } = useSentFriendRequests();

  // Mutations
  const acceptRequest = useAcceptFriendRequest();
  const rejectRequest = useRejectFriendRequest();
  const cancelRequest = useCancelFriendRequest();

  const activeRequests =
    activeTab === "pending" ? pendingRequests : sentRequests;

  const filteredRequests = activeRequests.filter((req: FriendRequest) =>
    activeTab === "pending"
      ? req.sender?.name?.toLowerCase().includes(searchQuery.toLowerCase())
      : req.sender?.name?.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="p-4 border-b border-border bg-panel">
        <div className="flex items-center justify-between mb-3">
          <h1 className="text-lg font-semibold text-primary">
            Friend Requests
          </h1>
        </div>

        {/* Search Bar */}
        <div className="relative">
          <Search
            className="absolute left-2.5 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-secondary"
            strokeWidth={2}
          />
          <input
            type="text"
            placeholder="Search requests..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-8 pr-3 py-2 bg-search-bg border-0 rounded-md text-xs text-primary placeholder:text-secondary focus:outline-none focus:ring-1 focus:ring-primaryColor/30"
          />
        </div>
      </div>

      {/* Tabs */}
      <div className="flex border-b border-border bg-panel px-4 sticky top-0">
        <button
          onClick={() => setActiveTab("pending")}
          className={`flex-1 py-3 text-xs font-semibold transition-colors ${
            activeTab === "pending"
              ? "text-primaryColor border-b-2 border-primaryColor"
              : "text-secondary border-b-2 border-transparent hover:text-primary"
          }`}
        >
          Incoming
          {pendingRequests.length > 0 && (
            <span className="ml-2 px-2 py-0.5 bg-primaryColor/20 rounded-full text-primaryColor text-[10px]">
              {pendingRequests.length}
            </span>
          )}
        </button>
        <button
          onClick={() => setActiveTab("sent")}
          className={`flex-1 py-3 text-xs font-semibold transition-colors ${
            activeTab === "sent"
              ? "text-primaryColor border-b-2 border-primaryColor"
              : "text-secondary border-b-2 border-transparent hover:text-primary"
          }`}
        >
          Sent
          {sentRequests.length > 0 && (
            <span className="ml-2 px-2 py-0.5 bg-primaryColor/20 rounded-full text-primaryColor text-[10px]">
              {sentRequests.length}
            </span>
          )}
        </button>
      </div>

      {/* Requests List */}
      <div className="flex-1 overflow-y-auto bg-panel">
        {pendingLoading || sentLoading ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-xs text-secondary">Loading requests...</p>
          </div>
        ) : filteredRequests.length === 0 ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-xs text-secondary">
              {activeTab === "pending"
                ? "No incoming requests"
                : "No sent requests"}
            </p>
          </div>
        ) : (
          <div className="space-y-2 p-4">
            {filteredRequests.map((request: FriendRequest) => (
              <FriendRequestItem
                key={request.id}
                request={request}
                isIncoming={activeTab === "pending"}
                onAccept={() =>
                  acceptRequest.mutate(request.id, {
                    onSuccess: () => {
                      // Request accepted, you can show a toast or update UI
                    },
                  })
                }
                onReject={() =>
                  rejectRequest.mutate(request.id, {
                    onSuccess: () => {
                      // Request rejected
                    },
                  })
                }
                onCancel={() =>
                  cancelRequest.mutate(request.id, {
                    onSuccess: () => {
                      // Request cancelled
                    },
                  })
                }
                isLoading={
                  acceptRequest.isPending ||
                  rejectRequest.isPending ||
                  cancelRequest.isPending
                }
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

interface FriendRequestItemProps {
  request: FriendRequest;
  isIncoming: boolean;
  onAccept: () => void;
  onReject: () => void;
  onCancel: () => void;
  isLoading: boolean;
}

function FriendRequestItem({
  request,
  isIncoming,
  onAccept,
  onReject,
  onCancel,
  isLoading,
}: FriendRequestItemProps) {
  const user = isIncoming ? request.sender : request.sender;

  if (!user) return null;

  return (
    <div className="flex items-center justify-between p-2.5 rounded-md bg-chat-hover hover:bg-chat-hover/80 transition-colors">
      {/* User Info */}
      <div className="flex items-center gap-2.5 flex-1 min-w-0">
        <div className="w-9 h-9 rounded-full bg-primaryColor/20 flex items-center justify-center text-primaryColor text-xs font-semibold flex-shrink-0">
          {user.name?.[0]?.toUpperCase() || "U"}
        </div>
        <div className="flex-1 min-w-0">
          <p className="text-sm font-medium text-primary truncate">
            {user.name}
          </p>
          <p className="text-[10px] text-secondary truncate">{user.email}</p>
        </div>
      </div>

      {/* Actions */}
      <div className="flex items-center gap-1.5 flex-shrink-0">
        {isIncoming ? (
          <>
            <button
              onClick={onAccept}
              disabled={isLoading}
              className="w-7 h-7 rounded-md bg-green-500/10 text-green-500 hover:bg-green-500/20 transition-colors flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
              title="Accept request"
            >
              <Check className="w-4 h-4" strokeWidth={2} />
            </button>
            <button
              onClick={onReject}
              disabled={isLoading}
              className="w-7 h-7 rounded-md bg-red-500/10 text-red-500 hover:bg-red-500/20 transition-colors flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
              title="Reject request"
            >
              <X className="w-4 h-4" strokeWidth={2} />
            </button>
          </>
        ) : (
          <button
            onClick={onCancel}
            disabled={isLoading}
            className="w-7 h-7 rounded-md bg-red-500/10 text-red-500 hover:bg-red-500/20 transition-colors flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed text-xs font-semibold"
            title="Cancel request"
          >
            <X className="w-4 h-4" strokeWidth={2} />
          </button>
        )}
      </div>
    </div>
  );
}

export default FriendsRequests;
</file>

<file path="client/src/components/pages/main/profile/index.tsx">
const Profile = () => {
  return (
    <div>
      
    </div>
  );
}

export default Profile;
</file>

<file path="client/src/components/ui/buttons/AddButton.tsx">
import { Plus } from "lucide-react";

interface AddButtonProps {
  onClick?: () => void;
  size?: "sm" | "md";
  className?: string;
  title?: string;
}

/**
 * Reusable Add/Plus button component
 * Used for adding new items (chats, groups, etc)
 */
export function AddButton({
  onClick,
  size = "md",
  className = "",
  title = "Add",
}: AddButtonProps) {
  const sizeClasses = {
    sm: "w-5 h-5",
    md: "w-7 h-7",
  };

  const iconSizes = {
    sm: "w-3.5 h-3.5",
    md: "w-4 h-4",
  };

  return (
    <button
      type="button"
      onClick={onClick}
      title={title}
      className={`${sizeClasses[size]} rounded-md bg-primaryColor/10 flex items-center justify-center hover:bg-primaryColor/20 transition-colors text-primaryColor ${className}`}
    >
      <Plus className={`${iconSizes[size]} text-primaryColor`} strokeWidth={2} />
    </button>
  );
}
</file>

<file path="client/src/components/ui/buttons/index.ts">
export { AddButton } from "./AddButton";
export { LogoutButton } from "./LogoutButton";
</file>

<file path="client/src/components/ui/display/AuthContainer.tsx">
import React from "react";
import { MessageSquareText } from "lucide-react";
import Image from "next/image";

interface ContainerProps {
  children: React.ReactNode;
}
const AuthContainer = ({ children }: ContainerProps) => {
  return (
    <section className="h-[100dvh] w-[100vw] flex flex-col lg:flex-row items-start justify-start lg:justify-between bg-primaryColor p-4 md:p-7">
      <div className="w-full lg:w-[20%] p-8">
        <div className="flex flex-col justify-center items-center lg:items-start lg:justify-start">
          <h2 className="text-white font-medium flex flex-row items-center gap-4">
            <MessageSquareText size={25} />
            <p>Doot</p>
          </h2>
          <p className="text-gray-300 font-medium">
            Responsive Bootstrap 5 Chat App
          </p>
        </div>
      </div>
      <div className="w-full lg:w-[74%] md:h-full bg-white rounded-2xl flex justify-center items-center py-10 md:py-5 px-5 mt-10 md:mt-0">
        {children}
      </div>
      <Image
        className="absolute hidden lg:block bottom-2 left-2 md:bottom-5 md:left-8 xl:left-16 w-40 h-auto md:w-56 lg:w-[500px] xl:w-[600px]"
        src="/images/auth-img.png"
        alt="Authentication Image"
        width={830}
        height={830}
      />
    </section>
  );
};

export default AuthContainer;
</file>

<file path="client/src/components/ui/display/Panel.tsx">
import React from "react";

interface PanelProps {
  children: React.ReactNode;
}

export function Panel({ children }: PanelProps) {
  return (
    <section className="w-[320px] bg-panel flex flex-col overflow-hidden border-r border-border">
      {children}
    </section>
  );
}
</file>

<file path="client/src/components/ui/feedback/ErrorAlert.tsx">
"use client";

import React from "react";
import { X } from "lucide-react";

interface ErrorAlertProps {
  message: string;
  onDismiss?: () => void;
  title?: string;
}

const ErrorAlert: React.FC<ErrorAlertProps> = ({
  message,
  onDismiss,
  title = "Error",
}) => {
  return (
    <div className="p-3 bg-red-50 border border-red-300 rounded-md flex items-start justify-between gap-2">
      <div className="flex-1">
        <h3 className="text-sm font-semibold text-red-800">{title}</h3>
        <p className="text-sm text-red-700 mt-1">{message}</p>
      </div>
      {onDismiss && (
        <button
          onClick={onDismiss}
          className="text-red-600 hover:text-red-800 flex-shrink-0"
          aria-label="Dismiss error"
        >
          <X className="w-4 h-4" />
        </button>
      )}
    </div>
  );
};

export default ErrorAlert;
</file>

<file path="client/src/components/ui/form/AuthSwitchLink.tsx">
"use client";

import Link from "next/link";

interface AuthSwitchLinkProps {
  mode: "signIn" | "signUp";
}

const AuthSwitchLink = ({ mode }: AuthSwitchLinkProps) => {
  return mode === "signIn" ? (
    <div className="text-center text-gray-600 mt-5 text-sm">
      Don&apos;t have an account ?{" "}
      <Link
        href="/signUp"
        className="text-primaryColor hover:underline font-medium"
      >
        Register
      </Link>
    </div>
  ) : (
    <div className="text-center text-sm text-gray-600 mt-2">
      Already have an account ?{" "}
      <Link
        href="/signIn"
        className="text-primaryColor hover:underline font-medium"
      >
        Sign In
      </Link>
    </div>
  );
};

export default AuthSwitchLink;
</file>

<file path="client/src/components/ui/form/Button.tsx">
"use client";

import React from "react";

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  isLoading?: boolean;
  variant?: "primary" | "secondary" | "danger";
  fullWidth?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  children,
  isLoading = false,
  variant = "primary",
  fullWidth = true,
  className = "",
  disabled,
  ...props
}) => {
  const variants = {
    primary:
      "bg-primaryColor hover:bg-[#3f905a] active:bg-[#3f905a] text-white",
    secondary: "bg-gray-100 text-gray-700 hover:bg-gray-200 active:bg-gray-300",
    danger: "bg-red-600 text-white hover:bg-red-700 active:bg-red-800",
  };

  return (
    <button
      {...props}
      disabled={disabled || isLoading}
      className={`px-4 py-2.5 text-[15px] font-medium rounded-md transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed ${
        variants[variant]
      } ${fullWidth ? "w-full" : ""} ${className}`}
    >
      {isLoading ? (
        <span className="flex items-center justify-center gap-2">
          <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            />
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            />
          </svg>
          Loading...
        </span>
      ) : (
        children
      )}
    </button>
  );
};

export default Button;
</file>

<file path="client/src/components/ui/form/ForgetPassword.tsx">
"use client";
import Link from "next/link";

const ForgetPassword = () => {
  return (
    <Link
      className="text-right text-[15px] text-gray-500 hover:text-primaryColor"
      href="/forgot-password"
    >
      Forgot Password?
    </Link>
  );
};

export default ForgetPassword;
</file>

<file path="client/src/components/ui/form/FormHeader.tsx">
"use client";

const FormHeader = ({
  title,
  subtitle,
}: {
  title: string;
  subtitle: string;
}) => {
  return (
    <div className="w-full flex flex-col items-center gap-2 mb-10">
      <h2 className="text-gray-600">{title}</h2>
      <h6 className="text-gray-500">{subtitle}</h6>
    </div>
  );
};

export default FormHeader;
</file>

<file path="client/src/components/ui/form/GoogleButton.tsx">
"use client";

import React from "react";

interface GoogleButtonProps {
  onClick?: () => void;
  isLoading?: boolean;
  text?: string;
}

const GoogleButton: React.FC<GoogleButtonProps> = ({
  onClick,
  isLoading = false,
  text = "Sign in with Google",
}) => {
  const handleClick = () => {
    if (onClick) {
      onClick();
    } else {
      // Default: redirect to Google OAuth endpoint
      window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/auth/google`;
    }
  };

  return (
    <button
      type="button"
      onClick={handleClick}
      disabled={isLoading}
      className="w-full flex items-center justify-center gap-3 px-4 py-2.5 my-3 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md transition-all duration-200 hover:bg-gray-50 active:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {isLoading ? (
        <svg
          className="w-5 h-5 animate-spin text-gray-500"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
      ) : (
        <svg className="w-5 h-5" viewBox="0 0 24 24">
          <path
            fill="#4285F4"
            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
          />
          <path
            fill="#34A853"
            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
          />
          <path
            fill="#FBBC05"
            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
          />
          <path
            fill="#EA4335"
            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
          />
        </svg>
      )}
      <span>{isLoading ? "Signing in..." : text}</span>
    </button>
  );
};

export default GoogleButton;
</file>

<file path="client/src/components/ui/form/index.ts">
export { default as Input } from "./Input";
export { default as Button } from "./Button";
export { default as GoogleButton } from "./GoogleButton";
export { default as Milestone } from "./Milestone";
export { default as FormHeader } from "./FormHeader";
export { default as ForgetPassword } from "./ForgetPassword";
export { default as AuthSwitchLink } from "./AuthSwitchLink";
</file>

<file path="client/src/components/ui/form/Input.tsx">
"use client";

import React, { useState, forwardRef } from "react";

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label: string;
  error?: string;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, className = "", ...props }, ref) => {
    const [isFocused, setIsFocused] = useState(false);
    const hasValue = props.value !== undefined && props.value !== "";

    const isFloating = isFocused || hasValue;

    return (
      <div className="w-full">
        <div className="relative">
          <input
            ref={ref}
            {...props}
            onFocus={(e) => {
              setIsFocused(true);
              props.onFocus?.(e);
            }}
            onBlur={(e) => {
              setIsFocused(false);
              props.onBlur?.(e);
            }}
            className={`w-full px-3 pt-5 pb-2 text-sm text-gray-700 bg-white border rounded-md outline-none transition-all duration-200 focus:border-primaryColor ${
              error ? "border-red-500" : "border-gray-300"
            } ${className}`}
          />
          <label
            className={`absolute left-3 transition-all duration-200 pointer-events-none ${
              isFloating
                ? "top-1.5 text-xs text-gray-500"
                : "top-1/2 -translate-y-1/2 text-sm text-gray-400"
            }`}
          >
            {label}
          </label>
        </div>
        {error && <p className="mt-1 text-xs text-red-500">{error}</p>}
      </div>
    );
  }
);

Input.displayName = "Input";

export default Input;
</file>

<file path="client/src/components/ui/form/Milestone.tsx">
"use client";

const Milestone = ({ title }: { title: string }) => {
  return (
    <div className="flex flex-row items-center justify-center">
      <span className="bg-gray-300 h-[1px] w-[30%]" />
      <div className="text-center text-gray-500 w-[35%] text-sm">{title}</div>
      <span className="bg-gray-300 h-[1px] w-[30%]" />
    </div>
  );
};

export default Milestone;
</file>

<file path="client/src/components/ui/navigation/Sidebar.tsx">
"use client";

import React from "react";
import Link from "next/link";
import { usePathname, useRouter } from "next/navigation";
import {
  MessageSquare,
  Phone,
  User,
  Settings,
  Moon,
  Sun,
  Users,
  Bookmark,
  LogOut,
  UserPlus,
} from "lucide-react";
import { useLogout } from "@/hooks/useAuth";

export function Sidebar() {
  const pathname = usePathname();
  const router = useRouter();
  const [isDark, setIsDark] = React.useState(false);
  const [mounted, setMounted] = React.useState(false);
  const logoutMutation = useLogout();

  // Initialize theme from localStorage
  React.useEffect(() => {
    setMounted(true);
    const isDarkMode = localStorage.getItem("theme") === "dark" || 
                       document.documentElement.classList.contains("dark");
    setIsDark(isDarkMode);
  }, []);

  const navigation = [
    { name: "Chats", href: "/chats", icon: MessageSquare },
    { name: "Friend Requests", href: "/friendsRequests", icon: UserPlus },
    { name: "Contacts", href: "/contacts", icon: User },
    { name: "Calls", href: "/calls", icon: Phone },
    { name: "Settings", href: "/settings", icon: Settings },
  ];

  const toggleTheme = () => {
    const newIsDark = !isDark;
    setIsDark(newIsDark);
    
    if (newIsDark) {
      document.documentElement.classList.add("dark");
      localStorage.setItem("theme", "dark");
    } else {
      document.documentElement.classList.remove("dark");
      localStorage.setItem("theme", "light");
    }
  };

  const handleLogout = () => {
    logoutMutation.mutate(undefined, {
      onSuccess: () => {
        router.push("/signIn");
      },
      onError: (error) => {
        console.error("Logout failed:", error);
        router.push("/signIn");
      },
    });
  };

  return (
    <aside className="w-[60px] bg-sidebar flex flex-col items-center py-3 gap-2">
      {/* Logo/Brand */}
      <div className="w-9 h-9 bg-primaryColor rounded-lg flex items-center justify-center mb-2">
        <MessageSquare className="w-5 h-5 text-white" strokeWidth={2} />
      </div>

      {/* Navigation Icons */}
      <nav className="flex-1 flex flex-col gap-1 w-full">
        {navigation.map((item) => {
          const isActive = pathname.startsWith(item.href);
          const Icon = item.icon;

          return (
            <Link
              key={item.name}
              href={item.href}
              className={`
                relative w-full h-11 flex items-center justify-center
                transition-colors duration-200
                ${
                  isActive
                    ? "text-primaryColor"
                    : "text-gray-400 hover:text-gray-300"
                }
              `}
              title={item.name}
            >
              {/* Active indicator - left border */}
              {isActive && (
                <div className="absolute left-0 top-1/2 -translate-y-1/2 w-1 h-8 bg-primaryColor rounded-r" />
              )}
              <Icon className="w-5 h-5" strokeWidth={2} />
            </Link>
          );
        })}
      </nav>

      {/* Bottom Actions */}
      <div className="flex flex-col gap-1 w-full mb-2">
        {/* Theme Toggle */}
        <button
          onClick={toggleTheme}
          className="w-full h-11 flex items-center justify-center text-gray-400 hover:text-gray-300 transition-all duration-300 transform hover:scale-110"
          title="Toggle theme"
        >
          {isDark ? (
            <Sun className="w-4 h-4 transition-transform duration-300" strokeWidth={2} />
          ) : (
            <Moon className="w-4 h-4 transition-transform duration-300" strokeWidth={2} />
          )}
        </button>

        {/* Logout Button */}
        <button
          onClick={handleLogout}
          disabled={logoutMutation.isPending}
          className="w-full h-11 flex items-center justify-center text-gray-400 hover:text-red-400 transition-colors disabled:opacity-50"
          title="Logout"
        >
          <LogOut className="w-5 h-5" strokeWidth={2} />
        </button>

        {/* User Avatar */}
        <div className="w-full h-11 flex items-center justify-center">
          <div className="w-8 h-8 rounded-full bg-primaryColor flex items-center justify-center text-white text-xs font-semibold">
            N
          </div>
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="client/src/hooks/useAuth.ts">
import { useMutation } from "@tanstack/react-query";
import { authService, LoginRequest, RegisterRequest, AuthResponse} from "@/services/auth.service";
import { tokenManager } from "@/lib/axios";

/**
 * Hook for user login
 */
export const useLogin = () => {
  return useMutation({
    mutationFn: (data: LoginRequest) => authService.login(data),
    onSuccess: (data: AuthResponse) => {
      tokenManager.setAccessToken(data.accessToken);
    },
    onError: (error) => {
      console.error("Login failed:", error);
    },
  });
};

/**
 * Hook for user registration
 */
export const useRegister = () => {
  return useMutation({
    mutationFn: (data: RegisterRequest) => authService.register(data),
    onError: (error) => {
      console.error("Registration failed:", error);
    },
  });
};

/**
 * Hook for user logout
 */
export const useLogout = () => {
  return useMutation({
    mutationFn: () => authService.logout(),
    onSuccess: () => {
      tokenManager.clearTokens();
    },
    onError: (error) => {
      console.error("Logout failed:", error);
      tokenManager.clearTokens();
    },
  });
};

/**
 * Hook for email verification
 */
export const useVerifyEmail = () => {
  return useMutation({
    mutationFn: (token: string) => authService.verifyEmail(token),
    onError: (error) => {
      console.error("Email verification failed:", error);
    },
  });
};

/**
 * Hook for resending verification email
 */
export const useResendVerification = () => {
  return useMutation({
    mutationFn: (email: string) => authService.resendVerification(email),
    onError: (error) => {
      console.error("Resend verification failed:", error);
    },
  });
};

/**
 * Hook for requesting password reset
 */
export const useRequestPasswordReset = () => {
  return useMutation({
    mutationFn: (email: string) => authService.requestPasswordReset(email),
    onError: (error) => {
      console.error("Password reset request failed:", error);
    },
  });
};

/**
 * Hook for resetting password
 */
export const useResetPassword = () => {
  return useMutation({
    mutationFn: (data: { token: string; newPassword: string }) =>
      authService.resetPassword(data.token, data.newPassword),
    onError: (error) => {
      console.error("Password reset failed:", error);
    },
  });
};
</file>

<file path="client/src/hooks/useConversations.ts">
import { useMutation, useQuery } from "@tanstack/react-query";
import {
  conversationsService,
  GetOrCreateConversationRequest,
} from "@/services/conversations.service";

/**
 * Hook for getting or creating conversation with a friend
 */
export const useGetOrCreateConversation = () => {
  return useMutation({
    mutationFn: (data: GetOrCreateConversationRequest) =>
      conversationsService.getOrCreateConversation(data),
    onError: (error) => {
      console.error("Get or create conversation failed:", error);
    },
  });
};

/**
 * Hook for getting all conversations
 */
export const useConversations = (limit: number = 50, offset: number = 0) => {
  return useQuery({
    queryKey: ["conversations", { limit, offset }],
    queryFn: () => conversationsService.getConversations(limit, offset),
    select: (data) => data.conversations,
  });
};

/**
 * Hook for getting single conversation
 */
export const useConversation = (conversationId: string) => {
  return useQuery({
    queryKey: ["conversation", conversationId],
    queryFn: () => conversationsService.getConversation(conversationId),
    select: (data) => data.conversation,
    enabled: !!conversationId,
  });
};

/**
 * Hook for getting other user in conversation
 */
export const useConversationOtherUser = (conversationId: string) => {
  return useQuery({
    queryKey: ["conversation", conversationId, "otherUser"],
    queryFn: () => conversationsService.getOtherUser(conversationId),
    select: (data) => data.user,
    enabled: !!conversationId,
  });
};

/**
 * Hook for archiving conversation
 */
export const useArchiveConversation = () => {
  return useMutation({
    mutationFn: (conversationId: string) =>
      conversationsService.archiveConversation({ conversationId }),
    onError: (error) => {
      console.error("Archive conversation failed:", error);
    },
  });
};

/**
 * Hook for unarchiving conversation
 */
export const useUnarchiveConversation = () => {
  return useMutation({
    mutationFn: (conversationId: string) =>
      conversationsService.unarchiveConversation({ conversationId }),
    onError: (error) => {
      console.error("Unarchive conversation failed:", error);
    },
  });
};

/**
 * Hook for deleting conversation
 */
export const useDeleteConversation = () => {
  return useMutation({
    mutationFn: (conversationId: string) =>
      conversationsService.deleteConversation({ conversationId }),
    onError: (error) => {
      console.error("Delete conversation failed:", error);
    },
  });
};
</file>

<file path="client/src/hooks/useFriends.ts">
import { useMutation, useQuery } from "@tanstack/react-query";
import {
  friendsService,
  SendFriendRequestParams,
} from "@/services/friends.service";

/**
 * Hook for sending friend requests
 */
export const useSendFriendRequest = () => {
  return useMutation({
    mutationFn: (data: SendFriendRequestParams) =>
      friendsService.sendFriendRequest(data),
    onError: (error) => {
      console.error("Send friend request failed:", error);
    },
  });
};

/**
 * Hook for accepting friend requests
 */
export const useAcceptFriendRequest = () => {
  return useMutation({
    mutationFn: (requestId: string) =>
      friendsService.acceptFriendRequest(requestId),
    onError: (error) => {
      console.error("Accept friend request failed:", error);
    },
  });
};

/**
 * Hook for rejecting friend requests
 */
export const useRejectFriendRequest = () => {
  return useMutation({
    mutationFn: (requestId: string) =>
      friendsService.rejectFriendRequest(requestId),
    onError: (error) => {
      console.error("Reject friend request failed:", error);
    },
  });
};

/**
 * Hook for canceling sent friend requests
 */
export const useCancelFriendRequest = () => {
  return useMutation({
    mutationFn: (requestId: string) =>
      friendsService.cancelFriendRequest(requestId),
    onError: (error) => {
      console.error("Cancel friend request failed:", error);
    },
  });
};

/**
 * Hook for getting pending friend requests
 */
export const usePendingFriendRequests = () => {
  return useQuery({
    queryKey: ["friendRequests", "pending"],
    queryFn: () => friendsService.getPendingRequests(),
    select: (data) => data.friendRequests,
  });
};

/**
 * Hook for getting sent friend requests
 */
export const useSentFriendRequests = () => {
  return useQuery({
    queryKey: ["friendRequests", "sent"],
    queryFn: () => friendsService.getSentRequests(),
    select: (data) => data.friendRequests,
  });
};

/**
 * Hook for getting friends list
 */
export const useFriendsList = () => {
  return useQuery({
    queryKey: ["friends"],
    queryFn: () => friendsService.getFriends(),
    select: (data) => data.friends,
  });
};

/**
 * Hook for removing friend
 */
export const useRemoveFriend = () => {
  return useMutation({
    mutationFn: (friendId: string) => friendsService.removeFriend(friendId),
    onError: (error) => {
      console.error("Remove friend failed:", error);
    },
  });
};
</file>

<file path="client/src/hooks/useGoogleAuth.ts">
import { authService } from "@/services/auth.service";

export const useGoogleAuth = () => {
  const handleGoogleAuth = () => {
    try {
      authService.initiateGoogleAuth();
    } catch (error) {
      console.error("Google auth error:", error);
    }
  };

  return { handleGoogleAuth };
};
</file>

<file path="client/src/hooks/useMessages.ts">
import { useMutation, useQuery } from "@tanstack/react-query";
import {
  messagesService,
  SendMessageRequest,
  EditMessageRequest,
  DeleteMessageRequest,
  MarkAsReadRequest,
  ReactToMessageRequest,
  RemoveReactionRequest,
} from "@/services/messages.service";

/**
 * Hook for sending message
 */
export const useSendMessage = () => {
  return useMutation({
    mutationFn: (data: SendMessageRequest) =>
      messagesService.sendMessage(data),
    onError: (error) => {
      console.error("Send message failed:", error);
    },
  });
};

/**
 * Hook for getting messages in conversation
 */
export const useMessages = (
  conversationId: string,
  limit: number = 50,
  offset: number = 0
) => {
  return useQuery({
    queryKey: ["messages", conversationId, { limit, offset }],
    queryFn: () => messagesService.getMessages(conversationId, limit, offset),
    select: (data) => data.messages,
    enabled: !!conversationId,
  });
};

/**
 * Hook for editing message
 */
export const useEditMessage = () => {
  return useMutation({
    mutationFn: (data: EditMessageRequest) =>
      messagesService.editMessage(data),
    onError: (error) => {
      console.error("Edit message failed:", error);
    },
  });
};

/**
 * Hook for deleting message
 */
export const useDeleteMessage = () => {
  return useMutation({
    mutationFn: (data: DeleteMessageRequest) =>
      messagesService.deleteMessage(data),
    onError: (error) => {
      console.error("Delete message failed:", error);
    },
  });
};

/**
 * Hook for marking messages as read
 */
export const useMarkAsRead = () => {
  return useMutation({
    mutationFn: (data: MarkAsReadRequest) =>
      messagesService.markAsRead(data),
    onError: (error) => {
      console.error("Mark as read failed:", error);
    },
  });
};

/**
 * Hook for getting read receipts
 */
export const useReadReceipts = (messageId: string) => {
  return useQuery({
    queryKey: ["readReceipts", messageId],
    queryFn: () => messagesService.getReadReceipts(messageId),
    enabled: !!messageId,
  });
};

/**
 * Hook for reacting to message
 */
export const useReactToMessage = () => {
  return useMutation({
    mutationFn: (data: ReactToMessageRequest) =>
      messagesService.reactToMessage(data),
    onError: (error) => {
      console.error("React to message failed:", error);
    },
  });
};

/**
 * Hook for removing reaction
 */
export const useRemoveReaction = () => {
  return useMutation({
    mutationFn: (data: RemoveReactionRequest) =>
      messagesService.removeReaction(data),
    onError: (error) => {
      console.error("Remove reaction failed:", error);
    },
  });
};

/**
 * Hook for getting reactions on message
 */
export const useMessageReactions = (messageId: string) => {
  return useQuery({
    queryKey: ["reactions", messageId],
    queryFn: () => messagesService.getReactions(messageId),
    enabled: !!messageId,
  });
};

/**
 * Hook for searching messages
 */
export const useSearchMessages = (
  query: string,
  conversationId: string,
  limit: number = 20
) => {
  return useQuery({
    queryKey: ["searchMessages", { query, conversationId, limit }],
    queryFn: () =>
      messagesService.searchMessages(query, conversationId, limit),
    select: (data) => data.messages,
    enabled: !!query && !!conversationId,
  });
};
</file>

<file path="client/src/lib/axios.ts">
import axios, { AxiosError, AxiosInstance, InternalAxiosRequestConfig } from "axios";
import Cookies from "js-cookie";

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:5000/api";

/**
 * Create axios instance with default config
 */
export const axiosInstance: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true, // Include cookies in requests (needed for refresh token)
});

/**
 * Token management utilities
 */
const tokenManager = {
  getAccessToken: () => Cookies.get("accessToken"),
  setAccessToken: (token: string) =>
    Cookies.set("accessToken", token, {
      expires: 1/48, // 30 minutes (1 day / 48 = 30 minutes)
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
    }),
  // Note: refreshToken is set by the server as httpOnly cookie
  // We cannot and should not try to access or set it from the client
  // The browser automatically handles httpOnly cookies in requests
  clearTokens: () => {
    Cookies.remove("accessToken");
    // refreshToken will be cleared by server on logout endpoint
  },
};

/**
 * Flag to prevent multiple refresh attempts
 */
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (err: AxiosError) => void;
}> = [];

/**
 * Process queued requests after token refresh
 */
const processQueue = (error: AxiosError | null, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token || "");
    }
  });

  isRefreshing = false;
  failedQueue = [];
};

/**
 * Request interceptor - Add access token to headers
 */
axiosInstance.interceptors.request.use(
  (config) => {
    const accessToken = tokenManager.getAccessToken();
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

/**
 * Response interceptor - Handle token refresh
 */
axiosInstance.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };

    // If error is not 401, reject
    if (error.response?.status !== 401) {
      return Promise.reject(error);
    }

    // If this is a login/register/auth endpoint, don't try to refresh - return error as is
    if (originalRequest?.url?.includes("/auth/login") || 
        originalRequest?.url?.includes("/auth/register") ||
        originalRequest?.url?.includes("/auth/forgot-password") ||
        originalRequest?.url?.includes("/auth/reset-password")) {
      return Promise.reject(error);
    }

    // If this is a refresh token endpoint, logout
    if (originalRequest?.url?.includes("/auth/refresh-tokens")) {
      tokenManager.clearTokens();
      // Redirect to login
      if (typeof window !== "undefined") {
        window.location.href = "/signIn";
      }
      return Promise.reject(error);
    }

    // Prevent multiple refresh attempts
    if (isRefreshing) {
      return new Promise((resolve, reject) => {
        failedQueue.push({ resolve, reject });
      }).then((token) => {
        originalRequest.headers.Authorization = `Bearer ${token}`;
        return axiosInstance(originalRequest);
      });
    }

    isRefreshing = true;

    try {
      // Attempt to refresh token
      // Note: refreshToken is sent automatically by the browser in httpOnly cookie
      const response = await axios.post(
        `${API_BASE_URL}/auth/refresh-tokens`,
        {},
        {
          headers: { "Content-Type": "application/json" },
          withCredentials: true, // Ensure cookies are sent
        }
      );

      const { accessToken: newAccessToken } = response.data.data;
      tokenManager.setAccessToken(newAccessToken);

      // Update original request with new token
      originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;

      processQueue(null, newAccessToken);
      return axiosInstance(originalRequest);
    } catch (refreshError) {
      // Refresh failed - logout user
      tokenManager.clearTokens();
      processQueue(refreshError as AxiosError);

      if (typeof window !== "undefined") {
        window.location.href = "/signIn";
      }

      return Promise.reject(refreshError);
    }
  }
);

export { tokenManager };
</file>

<file path="client/src/middleware.ts">
import { NextRequest, NextResponse } from "next/server";

/**
 * JWT payload interface
 */
interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  exp: number;
  iat: number;
}

/**
 * Decode JWT token without verification (for client-side middleware checks only)
 * Server will validate the actual token on API calls
 */
function decodeJWT(token: string): JWTPayload | null {
  try {
    const base64Payload = token.split(".")[1];
    const jsonPayload = atob(
      base64Payload.replace(/-/g, "+").replace(/_/g, "/")
    );
    return JSON.parse(jsonPayload) as JWTPayload;
  } catch {
    return null;
  }
}

/**
 * Middleware for route protection
 * - Protects /chats, /calls, /profile routes
 * - Redirects to /signIn if no token
 * - Redirects authenticated users away from auth pages
 * - Handles token expiry checks
 */
export function middleware(req: NextRequest) {
  const url = req.nextUrl.clone();
  const accessToken = req.cookies.get("accessToken")?.value;
  const pathname = url.pathname;

  // Route definitions
  const protectedRoutes = ["/chats", "/calls", "/profile"];

  const isProtectedRoute = protectedRoutes.some((route) =>
    pathname.startsWith(route)
  );
  const isRootPath = pathname === "/";

  // Root path (/) - redirect based on auth status
  if (isRootPath) {
    if (!accessToken) {
      url.pathname = "/signIn";
      return NextResponse.redirect(url);
    } else {
      // Verify token is valid
      const decoded = decodeJWT(accessToken);
      if (!decoded) {
        url.pathname = "/signIn";
        return NextResponse.redirect(url);
      }
      
      const isExpired = decoded.exp && Date.now() >= decoded.exp * 1000;
      if (isExpired) {
        url.pathname = "/signIn";
        return NextResponse.redirect(url);
      }
      
      // Valid token, redirect to chats
      url.pathname = "/chats";
      return NextResponse.redirect(url);
    }
  }

  // If accessing protected route without token
  if (isProtectedRoute && !accessToken) {
    url.pathname = "/signIn";
    return NextResponse.redirect(url);
  }

  // If token exists on protected route, validate it
  if (isProtectedRoute && accessToken) {
    const decoded = decodeJWT(accessToken);

    // Token is invalid (can't decode)
    if (!decoded) {
      url.pathname = "/signIn";
      return NextResponse.redirect(url);
    }

    // Check if token is expired
    const isExpired = decoded.exp && Date.now() >= decoded.exp * 1000;

    if (isExpired) {
      url.pathname = "/signIn";
      return NextResponse.redirect(url);
    }
  }

  return NextResponse.next();
}

/**
 * Middleware matcher - which routes to apply middleware to
 */
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)  
     * - favicon.ico (favicon file)
     * - public folder
     * - api routes
     */
    "/((?!_next|favicon.ico|images|api).*)",
  ],
};
</file>

<file path="client/src/providers/index.tsx">
"use client";

import React from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

/**
 * Create a client side query client instance
 */
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 30, // 30 minutes
      retry: 1,
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});

interface ProvidersProps {
  children: React.ReactNode;
}

/**
 * Providers wrapper component
 * Wraps React Query QueryClientProvider for state management
 */
export function Providers({ children }: ProvidersProps) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
</file>

<file path="client/src/services/auth.service.ts">
import { axiosInstance } from "@/lib/axios";

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

export interface AuthResponse {
  accessToken: string;
  user: {
    id: string;
    email: string;
    name: string;
  };
}

export interface RegisterResponse {
  user: {
    id: string;
    email: string;
    name: string;
  };
  verificationToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
}

export const authService = {
  /**
   * Login with email and password
   */
  async login(data: LoginRequest): Promise<AuthResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: { user: AuthResponse['user']; accessToken: string };
    }>("/auth/login", data);
    
    return {
      accessToken: response.data.data.accessToken,
      user: response.data.data.user,
    };
  },

  /**
   * Register a new user
   */
  async register(data: RegisterRequest): Promise<RegisterResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: { user: RegisterResponse['user']; verificationToken: string };
    }>("/auth/register", data);
    
    return {
      user: response.data.data.user,
      verificationToken: response.data.data.verificationToken,
    };
  },

  /**
   * Logout user
   */
  async logout(): Promise<void> {
    await axiosInstance.post("/auth/logout");
  },

  /**
   * Refresh access token using refresh token
   */
  async refreshToken(refreshToken: string): Promise<RefreshTokenResponse> {
    const response = await axiosInstance.post<RefreshTokenResponse>(
      "/auth/refresh-tokens",
      { refreshToken }
    );
    return response.data;
  },

  /**
   * Verify email
   */
  async verifyEmail(token: string) {
    const response = await axiosInstance.get("/auth/verify-email", {
      params: { token },
    });
    return response.data;
  },

  /**
   * Resend verification email
   */
  async resendVerification(email: string) {
    const response = await axiosInstance.post("/auth/resend-verification", {
      email,
    });
    return response.data;
  },

  /**
   * Request password reset
   */
  async requestPasswordReset(email: string) {
    const response = await axiosInstance.post("/auth/forgot-password", {
      email,
    });
    return response.data;
  },

  /**
   * Reset password with token
   */
  async resetPassword(token: string, newPassword: string) {
    const response = await axiosInstance.post("/auth/reset-password", {
      token,
      newPassword,
    });
    return response.data;
  },

  /**
   * Initiate Google OAuth login
   * Redirects user to Google login page
   */
  initiateGoogleAuth(): void {
    const apiUrl = process.env.NEXT_PUBLIC_API_URL;
    window.location.href = `${apiUrl}/auth/google`;
  },
};
</file>

<file path="client/src/services/conversations.service.ts">
import { axiosInstance } from "@/lib/axios";

/**
 * User DTO (for use in conversations)
 */
export interface ConversationUser {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  status: "online" | "offline" | "away";
}

/**
 * Message DTO
 */
export interface Message {
  id: string;
  conversationId: string;
  content: string;
  sender: ConversationUser;
  isRead: boolean;
  createdAt: string;
}

/**
 * Conversation DTO
 */
export interface Conversation {
  id: string;
  participants: ConversationUser[];
  lastMessage?: Message;
  unreadCount: number;
  isArchived: boolean;
  createdAt: string;
  updatedAt: string;
}

/**
 * Conversation with other user info (for list view)
 */
export interface ConversationListItem {
  id: string;
  otherUser: ConversationUser;
  lastMessage?: {
    content: string;
    sender: string;
    createdAt: string;
  };
  unreadCount: number;
  isArchived: boolean;
  updatedAt: string;
}

/**
 * Request/Response Types
 */
export interface GetOrCreateConversationRequest {
  friendId: string;
}

export interface GetOrCreateConversationResponse {
  conversation: Conversation;
}

export interface GetConversationsResponse {
  conversations: ConversationListItem[];
  total: number;
  limit: number;
  offset: number;
}

export interface GetConversationResponse {
  conversation: Conversation;
}

export interface GetOtherUserResponse {
  user: ConversationUser;
}

export interface ArchiveConversationRequest {
  conversationId: string;
}

export interface DeleteConversationRequest {
  conversationId: string;
}

/**
 * Conversations Service
 * Handles all conversation-related API calls
 */
export const conversationsService = {
  /**
   * Get or create conversation with a friend
   */
  async getOrCreateConversation(
    data: GetOrCreateConversationRequest
  ): Promise<GetOrCreateConversationResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: GetOrCreateConversationResponse;
    }>("/conversations", data);

    return response.data.data;
  },

  /**
   * Get all conversations for current user
   */
  async getConversations(
    limit: number = 50,
    offset: number = 0
  ): Promise<GetConversationsResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetConversationsResponse;
    }>("/conversations", {
      params: { limit, offset },
    });

    return response.data.data;
  },

  /**
   * Get single conversation by ID
   */
  async getConversation(conversationId: string): Promise<GetConversationResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetConversationResponse;
    }>(`/conversations/${conversationId}`);

    return response.data.data;
  },

  /**
   * Get other user in conversation
   */
  async getOtherUser(conversationId: string): Promise<GetOtherUserResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetOtherUserResponse;
    }>(`/conversations/${conversationId}/user`);

    return response.data.data;
  },

  /**
   * Archive conversation
   */
  async archiveConversation(
    data: ArchiveConversationRequest
  ): Promise<void> {
    await axiosInstance.patch<{
      success: boolean;
      message: string;
    }>("/conversations/archive", data);
  },

  /**
   * Unarchive conversation
   */
  async unarchiveConversation(
    data: ArchiveConversationRequest
  ): Promise<void> {
    await axiosInstance.patch<{
      success: boolean;
      message: string;
    }>("/conversations/unarchive", data);
  },

  /**
   * Delete conversation
   */
  async deleteConversation(data: DeleteConversationRequest): Promise<void> {
    await axiosInstance.delete<{
      success: boolean;
      message: string;
    }>("/conversations", { data });
  },
};
</file>

<file path="client/src/services/friends.service.ts">
import { axiosInstance } from "@/lib/axios";

/**
 * Friend Request DTOs
 */
export interface FriendRequest {
  id: string;
  senderId: string;
  recipientId: string;
  sender: {
    id: string;
    name: string;
    email: string;
    avatar?: string;
  };
  status: "pending" | "accepted" | "rejected";
  createdAt: string;
}

export interface SendFriendRequestParams {
  recipientId: string;
}

export interface SendFriendRequestResponse {
  friendRequest: FriendRequest;
}

/**
 * Friend DTOs
 */
export interface Friend {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  status: "online" | "offline" | "away";
  bio?: string;
}

export interface GetFriendsResponse {
  friends: Friend[];
}

/**
 * Friend Requests List Response
 */
export interface GetFriendRequestsResponse {
  friendRequests: FriendRequest[];
}

/**
 * Accept/Reject Friend Request Response
 */
export interface ModifyFriendRequestResponse {
  success: boolean;
}

/**
 * Friends Service
 * Handles all friend-related API calls
 */
export const friendsService = {
  /**
   * Send friend request to a user
   */
  async sendFriendRequest(
    data: SendFriendRequestParams
  ): Promise<SendFriendRequestResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: SendFriendRequestResponse;
    }>("/friends/request", data);

    return response.data.data;
  },

  /**
   * Accept friend request
   */
  async acceptFriendRequest(requestId: string): Promise<void> {
    await axiosInstance.patch<{
      success: boolean;
      message: string;
    }>(`/friends/request/${requestId}/accept`);
  },

  /**
   * Reject friend request
   */
  async rejectFriendRequest(requestId: string): Promise<void> {
    await axiosInstance.patch<{
      success: boolean;
      message: string;
    }>(`/friends/request/${requestId}/reject`);
  },

  /**
   * Cancel sent friend request
   */
  async cancelFriendRequest(requestId: string): Promise<void> {
    await axiosInstance.delete<{
      success: boolean;
      message: string;
    }>(`/friends/request/${requestId}`);
  },

  /**
   * Get pending friend requests
   * Requests where current user is recipient
   */
  async getPendingRequests(): Promise<GetFriendRequestsResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetFriendRequestsResponse;
    }>("/friends/requests", {
      params: { type: "pending" },
    });

    return response.data.data;
  },

  /**
   * Get sent friend requests
   * Requests where current user is sender
   */
  async getSentRequests(): Promise<GetFriendRequestsResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetFriendRequestsResponse;
    }>("/friends/requests", {
      params: { type: "sent" },
    });

    return response.data.data;
  },

  /**
   * Get all friends list
   */
  async getFriends(): Promise<GetFriendsResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetFriendsResponse;
    }>("/friends");

    return response.data.data;
  },

  /**
   * Remove friend
   */
  async removeFriend(friendId: string): Promise<void> {
    await axiosInstance.delete<{
      success: boolean;
      message: string;
    }>(`/friends/${friendId}`);
  },
};
</file>

<file path="client/src/services/messages.service.ts">
import { axiosInstance } from "@/lib/axios";

/**
 * Message DTO
 */
export interface Message {
  id: string;
  conversationId: string;
  content: string;
  sender: {
    id: string;
    name: string;
    avatar?: string;
  };
  isRead: boolean;
  isEdited?: boolean;
  editedAt?: string;
  isDeleted?: boolean;
  deletedAt?: string;
  createdAt: string;
}

/**
 * Reaction DTO
 */
export interface MessageReaction {
  id: string;
  messageId: string;
  userId: string;
  emoji: string;
  createdAt: string;
}

/**
 * Read Receipt DTO
 */
export interface ReadReceipt {
  id: string;
  name: string;
  readAt: string;
}

/**
 * Request/Response Types
 */
export interface SendMessageRequest {
  conversationId: string;
  content: string;
}

export interface SendMessageResponse {
  message: Message;
}

export interface GetMessagesRequest {
  conversationId: string;
  limit?: number;
  offset?: number;
}

export interface GetMessagesResponse {
  messages: Message[];
  total: number;
  limit: number;
  offset: number;
}

export interface EditMessageRequest {
  messageId: string;
  content: string;
}

export interface DeleteMessageRequest {
  messageId: string;
}

export interface MarkAsReadRequest {
  conversationId: string;
  messageIds: string[];
}

export interface MarkAsReadResponse {
  markedCount: number;
}

export interface ReactToMessageRequest {
  messageId: string;
  emoji: string;
}

export interface ReactToMessageResponse {
  reaction: MessageReaction;
}

export interface RemoveReactionRequest {
  reactionId: string;
}

export interface SearchMessagesRequest {
  query: string;
  conversationId: string;
  limit?: number;
}

export interface SearchMessagesResponse {
  messages: Message[];
}

/**
 * Messages Service
 * Handles all message-related API calls
 */
export const messagesService = {
  /**
   * Send message in conversation
   */
  async sendMessage(
    data: SendMessageRequest
  ): Promise<SendMessageResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: SendMessageResponse;
    }>("/messages", data);

    return response.data.data;
  },

  /**
   * Get messages in conversation
   */
  async getMessages(
    conversationId: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<GetMessagesResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: GetMessagesResponse;
    }>(`/messages/${conversationId}`, {
      params: { limit, offset },
    });

    return response.data.data;
  },

  /**
   * Edit message
   */
  async editMessage(data: EditMessageRequest): Promise<void> {
    await axiosInstance.patch<{
      success: boolean;
      message: string;
    }>("/messages/edit", data);
  },

  /**
   * Delete message (soft delete)
   */
  async deleteMessage(data: DeleteMessageRequest): Promise<void> {
    await axiosInstance.delete<{
      success: boolean;
      message: string;
    }>("/messages", { data });
  },

  /**
   * Mark messages as read
   */
  async markAsRead(data: MarkAsReadRequest): Promise<MarkAsReadResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: MarkAsReadResponse;
    }>("/messages/mark-as-read", data);

    return response.data.data;
  },

  /**
   * Get read receipts for message
   */
  async getReadReceipts(messageId: string): Promise<ReadReceipt[]> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: { readBy: ReadReceipt[] };
    }>(`/messages/${messageId}/read-receipts`);

    return response.data.data.readBy;
  },

  /**
   * React to message
   */
  async reactToMessage(
    data: ReactToMessageRequest
  ): Promise<ReactToMessageResponse> {
    const response = await axiosInstance.post<{
      success: boolean;
      message: string;
      data: ReactToMessageResponse;
    }>("/messages/react", data);

    return response.data.data;
  },

  /**
   * Remove reaction from message
   */
  async removeReaction(data: RemoveReactionRequest): Promise<void> {
    await axiosInstance.delete<{
      success: boolean;
      message: string;
    }>("/messages/react", { data });
  },

  /**
   * Get reactions for message
   */
  async getReactions(messageId: string): Promise<any[]> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: { reactions: any[] };
    }>(`/messages/${messageId}/reactions`);

    return response.data.data.reactions;
  },

  /**
   * Search messages
   */
  async searchMessages(
    query: string,
    conversationId: string,
    limit: number = 20
  ): Promise<SearchMessagesResponse> {
    const response = await axiosInstance.get<{
      success: boolean;
      message: string;
      data: SearchMessagesResponse;
    }>("/messages/search", {
      params: { query, conversationId, limit },
    });

    return response.data.data;
  },
};
</file>

<file path="client/src/styles/dark-mode-transitions.css">
/* 
  Dark Mode Transition Enhancement
  
  This adds smooth transitions for dark mode by applying
  transition-colors to all elements using CSS variables
*/

:root,
.dark {
  transition-property: background-color, border-color, color;
  transition-duration: 300ms;
  transition-timing-function: ease-in-out;
}

/* Ensure all Tailwind color utilities inherit the transition */
* {
  transition-property: background-color, border-color, color, box-shadow;
  transition-duration: 300ms;
  transition-timing-function: ease-in-out;
}

/* Speed up specific transitions that should be faster */
*:hover {
  transition-duration: 200ms;
}
</file>

<file path="client/src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Enable smooth transitions for dark mode */
:root {
  --primary-color: #4eac6d;

  /* Light Mode Colors */
  --sidebar-bg: #37475a;
  --panel-bg: #f5f7fb;
  --main-bg: #e6ebf5;
  --header-bg: #ffffff;
  --text-primary: #495057;
  --text-secondary: #7a7f9a;
  --border-color: #e1e5eb;
  --hover-bg: #eef0f5;
  --search-bg: #eef2f8;
  --chat-hover: #e8ecf4;

  color-scheme: light;
}

.dark {
  /* Dark Mode Colors */
  --sidebar-bg: #36404a;
  --panel-bg: #262e35;
  --main-bg: #1b2028;
  --header-bg: #303841;
  --text-primary: #e1e9f0;
  --text-secondary: #9ca3af;
  --border-color: #38424d;
  --hover-bg: #303841;
  --search-bg: #303841;
  --chat-hover: #303841;

  color-scheme: dark;
}

@layer base {
  html {
    @apply transition-colors duration-300;
  }

  * {
    @apply transition-colors duration-300;
  }

  body {
    @apply min-h-[100dvh] w-full overflow-hidden;
    background-color: var(--main-bg);
    color: var(--text-primary);
  }

  h1 {
    @apply font-display text-4xl font-normal tracking-tight;
  }

  h2 {
    @apply font-display text-3xl font-normal tracking-tight;
  }

  h3 {
    @apply font-display text-2xl font-normal tracking-tight;
  }

  h4 {
    @apply font-display text-xl font-normal;
  }

  h5 {
    @apply font-display text-lg font-normal;
  }

  h6 {
    @apply font-display text-base font-normal;
  }
}
</file>

<file path="client/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  darkMode: "class",
  theme: {
    extend: {
      colors: {
        // Application Layout Colors - using CSS variables with hex
        primaryColor: "var(--primary-color)",
        sidebar: "var(--sidebar-bg)",
        panel: "var(--panel-bg)",
        main: "var(--main-bg)",
        header: "var(--header-bg)",
        primary: "var(--text-primary)",
        secondary: "var(--text-secondary)",
        border: "var(--border-color)",
        hover: "var(--hover-bg)",
        accent: "var(--accent-color)",
        // Success
        success: {
          50: "#f0fdf4",
          100: "#dcfce7",
          200: "#bbf7d0",
          300: "#86efac",
          400: "#4ade80",
          500: "#22c55e",
          600: "#16a34a",
          700: "#15803d",
          800: "#166534",
          900: "#14532d",
        },
        // Error
        error: {
          50: "#fef2f2",
          100: "#fee2e2",
          200: "#fecaca",
          300: "#fca5a5",
          400: "#f87171",
          500: "#ef4444",
          600: "#dc2626",
          700: "#b91c1c",
          800: "#991b1b",
          900: "#7f1d1d",
        },
        // Warning
        warning: {
          50: "#fefce8",
          100: "#fef9c3",
          200: "#fef08a",
          300: "#fde047",
          400: "#facc15",
          500: "#eab308",
          600: "#ca8a04",
          700: "#a16207",
          800: "#854d0e",
          900: "#713f12",
        },
        // Chat Specific Colors
        chat: {
          bg: {
            light: "#f8fafc",
            dark: "#0f172a",
          },
          sidebar: {
            light: "#ffffff",
            dark: "#1e293b",
          },
          message: {
            sent: {
              light: "#3b82f6",
              dark: "#2563eb",
            },
            received: {
              light: "#f1f5f9",
              dark: "#334155",
            },
          },
          online: "#22c55e",
          offline: "#94a3b8",
          typing: "#f59e0b",
        },
      },
      fontFamily: {
        sans: ["var(--font-inter)", "system-ui", "sans-serif"],
        display: ["var(--font-poppins)", "system-ui", "sans-serif"],
        mono: ["var(--font-jetbrains)", "Consolas", "monospace"],
      },
      fontSize: {
        "2xs": ["0.625rem", { lineHeight: "0.875rem" }],
        xs: ["0.75rem", { lineHeight: "1rem" }],
        sm: ["0.875rem", { lineHeight: "1.25rem" }],
        base: ["1rem", { lineHeight: "1.5rem" }],
        lg: ["1.125rem", { lineHeight: "1.75rem" }],
        xl: ["1.25rem", { lineHeight: "1.75rem" }],
        "2xl": ["1.5rem", { lineHeight: "2rem" }],
        "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
        "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
        "5xl": ["3rem", { lineHeight: "1" }],
      },
      spacing: {
        18: "4.5rem",
        88: "22rem",
        112: "28rem",
        128: "32rem",
      },
      borderRadius: {
        "4xl": "2rem",
        "5xl": "2.5rem",
      },
      boxShadow: {
        soft: "0 2px 8px rgba(0, 0, 0, 0.05)",
        medium: "0 4px 16px rgba(0, 0, 0, 0.1)",
        strong: "0 8px 24px rgba(0, 0, 0, 0.15)",
        chat: "0 1px 2px rgba(0, 0, 0, 0.05)",
        "chat-hover": "0 4px 12px rgba(0, 0, 0, 0.1)",
      },
      animation: {
        "fade-in": "fadeIn 0.2s ease-in-out",
        "slide-in": "slideIn 0.3s ease-out",
        "slide-up": "slideUp 0.3s ease-out",
        "scale-in": "scaleIn 0.2s ease-out",
        "bounce-subtle": "bounceSubtle 0.5s ease-in-out",
        typing: "typing 1.5s infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      },
      keyframes: {
        fadeIn: {
          "0%": { opacity: "0" },
          "100%": { opacity: "1" },
        },
        slideIn: {
          "0%": { transform: "translateX(-100%)" },
          "100%": { transform: "translateX(0)" },
        },
        slideUp: {
          "0%": { transform: "translateY(10px)", opacity: "0" },
          "100%": { transform: "translateY(0)", opacity: "1" },
        },
        scaleIn: {
          "0%": { transform: "scale(0.95)", opacity: "0" },
          "100%": { transform: "scale(1)", opacity: "1" },
        },
        bounceSubtle: {
          "0%, 100%": { transform: "translateY(0)" },
          "50%": { transform: "translateY(-5px)" },
        },
        typing: {
          "0%, 100%": { opacity: "0.3" },
          "50%": { opacity: "1" },
        },
      },
      screens: {
        xs: "475px",
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px",
        "2xl": "1536px",
      },
      backdropBlur: {
        xs: "2px",
      },
      transitionProperty: {
        height: "height",
        spacing: "margin, padding",
      },
    },
  },
  plugins: [],
};
</file>

<file path="client/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="DARK_MODE_GUIDE.md">
# Dark Mode Transition - Implementation Guide

## ‚úÖ Changes Made

### 1. **Global CSS Transitions** (`src/styles/globals.css`)
- Added `transition-colors duration-300` to `html` and `*` elements
- Applied to all color-changing properties:
  - `background-color`
  - `border-color`
  - `color`
  - `box-shadow`
- Transition duration: 300ms with ease-in-out timing

### 2. **Enhanced Sidebar Toggle** (`src/components/ui/navigation/Sidebar.tsx`)
- Added localStorage persistence for theme preference
- Added proper initialization with `useEffect`
- Added mount state to prevent hydration mismatch
- Button now has:
  - Scale animation on hover (hover:scale-110)
  - Smooth color transition (300ms)
  - Icon transition animation

### 3. **CSS Variable Transitions** 
- All elements automatically inherit `transition-colors`
- CSS variables used for theming:
  - `--sidebar-bg`
  - `--panel-bg`
  - `--main-bg`
  - `--text-primary`
  - `--text-secondary`
  - And others...

## üöÄ How to Test

### Step 1: Clear Browser Cache
1. Open DevTools (F12)
2. Right-click the reload button
3. Select "Empty cache and hard reload"
4. Or: Settings ‚Üí Privacy ‚Üí Clear cookies/cache

### Step 2: Open the Application
- Navigate to http://localhost:3000
- Login to your account

### Step 3: Test Dark Mode Toggle
1. Look for the **Moon icon** in the sidebar (bottom section)
2. Click it to toggle dark mode
3. **Watch for the smooth transition** - all colors should fade smoothly over 300ms
4. Click again to switch back to light mode

## üé® What You Should See

### Light Mode ‚Üí Dark Mode
```
Before click:
- Light gray backgrounds
- Dark text

[Click Moon Icon]

Smooth 300ms transition...

After click:
- Dark backgrounds
- Light text
- All colors fade smoothly
```

### Visual Cues
- ‚úÖ Button scales up slightly when you hover over it
- ‚úÖ Icon transitions smoothly
- ‚úÖ All colors in the interface fade together
- ‚úÖ No jarring color changes
- ‚úÖ Theme preference saved to localStorage

## üîç Debugging

If dark mode still doesn't change:

### Check 1: Browser Console
```javascript
// In DevTools Console:
console.log(localStorage.getItem("theme"))
console.log(document.documentElement.classList.contains("dark"))
```

### Check 2: Force Reload
```powershell
# In terminal, restart Next.js dev server
cd client
npm run dev
```

### Check 3: Check CSS Variables
```javascript
// In console:
getComputedStyle(document.documentElement).getPropertyValue('--main-bg')
```

### Check 4: Verify CSS is Compiled
1. Open DevTools ‚Üí Sources tab
2. Look for `globals.css` in the compiled files
3. Search for `transition-colors duration-300`
4. Should find it in both `html` and `*` selectors

## üéØ Expected Behavior

| Action | Expected Result |
|--------|-----------------|
| Click theme button | All colors fade smoothly over 300ms |
| Hover theme button | Button scales up 110% |
| Reload page | Same theme persists (from localStorage) |
| Open DevTools | `localStorage.theme` = "dark" or "light" |

## üìù Files Modified

1. ‚úÖ `client/src/styles/globals.css`
   - Added transition utilities
   - Applied to html and all elements

2. ‚úÖ `client/src/components/ui/navigation/Sidebar.tsx`
   - Added theme persistence
   - Added proper initialization
   - Enhanced toggle button

3. ‚úÖ `client/src/styles/dark-mode-transitions.css`
   - Transition configuration (optional, can be removed)

## üîß Troubleshooting

### Transitions not smooth?
‚Üí Clear cache and hard reload (Ctrl+Shift+R)

### Theme not persisting?
‚Üí Check localStorage is enabled in browser settings
‚Üí Check DevTools: Application ‚Üí Storage ‚Üí Cookies/LocalStorage

### Colors not changing at all?
‚Üí Ensure dark mode class is added to `<html>` element
‚Üí Check CSS variables in DevTools Computed Styles

### Icons not showing?
‚Üí Ensure `lucide-react` is installed
‚Üí Check `Moon` and `Sun` icons are imported

## ‚ú® Enhancement Ideas

Want even smoother transitions?
- Add transition delay for staggered effect
- Add Framer Motion for advanced animations
- Use CSS custom properties for timing function

Want more theme options?
- Add system dark mode detection (prefers-color-scheme)
- Add multiple color schemes (purple, blue, etc.)
- Add theme selector component
</file>

<file path="README.md">
"# WebSocket-Project"
</file>

<file path="server/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="server/dist/app.d.ts">
import { Express } from "express";
import "./config/google-auth.config";
export declare const app: Express;
export default app;
//# sourceMappingURL=app.d.ts.map
</file>

<file path="server/dist/app.d.ts.map">
{"version":3,"file":"app.d.ts","sourceRoot":"","sources":["../src/app.ts"],"names":[],"mappings":"AAAA,OAAgB,EAAE,OAAO,EAAmC,MAAM,SAAS,CAAC;AAe5E,OAAO,6BAA6B,CAAC;AAErC,eAAO,MAAM,GAAG,EAAE,OAAmB,CAAC;AAqGtC,eAAe,GAAG,CAAC"}
</file>

<file path="server/dist/app.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.app = void 0;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const helmet_1 = __importDefault(require("helmet"));
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const express_session_1 = __importDefault(require("express-session"));
const passport_1 = __importDefault(require("passport"));
const env_config_1 = require("./config/env.config");
const error_middleware_1 = require("./middleware/error.middleware");
const auth_route_1 = __importDefault(require("./routes/auth.route"));
const google_auth_route_1 = __importDefault(require("./routes/google-auth.route"));
const user_route_1 = __importDefault(require("./routes/user.route"));
const friend_route_1 = __importDefault(require("./routes/friend.route"));
const conversation_route_1 = __importDefault(require("./routes/conversation.route"));
const message_route_1 = __importDefault(require("./routes/message.route"));
const call_route_1 = __importDefault(require("./routes/call.route"));
require("./config/google-auth.config");
exports.app = (0, express_1.default)();
(0, env_config_1.validateEnv)();
exports.app.use((0, helmet_1.default)());
exports.app.use((0, cors_1.default)({
    origin: env_config_1.config.CLIENT_URL,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
    allowedHeaders: ["Content-Type", "Authorization"],
}));
exports.app.use(express_1.default.json({ limit: "10kb" }));
exports.app.use(express_1.default.urlencoded({ limit: "10kb", extended: true }));
exports.app.use((0, cookie_parser_1.default)());
exports.app.use((0, express_session_1.default)({
    secret: env_config_1.config.JWT_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: env_config_1.config.NODE_ENV === "production",
        httpOnly: true,
        sameSite: "strict",
        maxAge: 24 * 60 * 60 * 1000,
    },
}));
exports.app.use(passport_1.default.initialize());
exports.app.use(passport_1.default.session());
exports.app.get("/api/health", (req, res) => {
    res.status(200).json({
        success: true,
        message: "Server is running",
        timestamp: new Date().toISOString(),
    });
});
exports.app.use("/api/v1/auth", auth_route_1.default);
exports.app.use("/api/v1/auth", google_auth_route_1.default);
exports.app.use("/api/v1/users", user_route_1.default);
exports.app.use("/api/v1/friends", friend_route_1.default);
exports.app.use("/api/v1/conversations", conversation_route_1.default);
exports.app.use("/api/v1/messages", message_route_1.default);
exports.app.use("/api/v1/calls", call_route_1.default);
exports.app.use(error_middleware_1.notFound);
exports.app.use(error_middleware_1.errorHandler);
exports.default = exports.app;
//# sourceMappingURL=app.js.map
</file>

<file path="server/dist/app.js.map">
{"version":3,"file":"app.js","sourceRoot":"","sources":["../src/app.ts"],"names":[],"mappings":";;;;;;AAAA,sDAA4E;AAC5E,gDAAwB;AACxB,oDAA4B;AAC5B,kEAAyC;AACzC,sEAAsC;AACtC,wDAAgC;AAChC,oDAA0D;AAC1D,oEAAuE;AACvE,qEAA6C;AAC7C,mFAA0D;AAC1D,qEAA6C;AAC7C,yEAAiD;AACjD,qFAA6D;AAC7D,2EAAmD;AACnD,qEAA6C;AAC7C,uCAAqC;AAExB,QAAA,GAAG,GAAY,IAAA,iBAAO,GAAE,CAAC;AAEtC,IAAA,wBAAW,GAAE,CAAC;AAGd,WAAG,CAAC,GAAG,CAAC,IAAA,gBAAM,GAAE,CAAC,CAAC;AAGlB,WAAG,CAAC,GAAG,CACL,IAAA,cAAI,EAAC;IACH,MAAM,EAAE,mBAAM,CAAC,UAAU;IACzB,WAAW,EAAE,IAAI;IACjB,OAAO,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC;IAClD,cAAc,EAAE,CAAC,cAAc,EAAE,eAAe,CAAC;CAClD,CAAC,CACH,CAAC;AAGF,WAAG,CAAC,GAAG,CAAC,iBAAO,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;AACzC,WAAG,CAAC,GAAG,CAAC,iBAAO,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAE/D,WAAG,CAAC,GAAG,CAAC,IAAA,uBAAY,GAAE,CAAC,CAAC;AAWxB,WAAG,CAAC,GAAG,CACL,IAAA,yBAAO,EAAC;IACN,MAAM,EAAE,mBAAM,CAAC,UAAU;IACzB,MAAM,EAAE,KAAK;IACb,iBAAiB,EAAE,KAAK;IACxB,MAAM,EAAE;QACN,MAAM,EAAE,mBAAM,CAAC,QAAQ,KAAK,YAAY;QACxC,QAAQ,EAAE,IAAI;QACd,QAAQ,EAAE,QAAQ;QAClB,MAAM,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;KAC5B;CACF,CAAC,CACH,CAAC;AASF,WAAG,CAAC,GAAG,CAAC,kBAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;AAC/B,WAAG,CAAC,GAAG,CAAC,kBAAQ,CAAC,OAAO,EAAE,CAAC,CAAC;AAK5B,WAAG,CAAC,GAAG,CAAC,aAAa,EAAE,CAAC,GAAY,EAAE,GAAa,EAAE,EAAE;IACrD,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;QACnB,OAAO,EAAE,IAAI;QACb,OAAO,EAAE,mBAAmB;QAC5B,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;KACpC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAMH,WAAG,CAAC,GAAG,CAAC,cAAc,EAAE,oBAAU,CAAC,CAAC;AAGpC,WAAG,CAAC,GAAG,CAAC,cAAc,EAAE,2BAAgB,CAAC,CAAC;AAG1C,WAAG,CAAC,GAAG,CAAC,eAAe,EAAE,oBAAU,CAAC,CAAC;AAGrC,WAAG,CAAC,GAAG,CAAC,iBAAiB,EAAE,sBAAY,CAAC,CAAC;AAGzC,WAAG,CAAC,GAAG,CAAC,uBAAuB,EAAE,4BAAkB,CAAC,CAAC;AAGrD,WAAG,CAAC,GAAG,CAAC,kBAAkB,EAAE,uBAAa,CAAC,CAAC;AAG3C,WAAG,CAAC,GAAG,CAAC,eAAe,EAAE,oBAAU,CAAC,CAAC;AAKrC,WAAG,CAAC,GAAG,CAAC,2BAAQ,CAAC,CAAC;AAKlB,WAAG,CAAC,GAAG,CAAC,+BAAY,CAAC,CAAC;AAEtB,kBAAe,WAAG,CAAC"}
</file>

<file path="server/dist/config/cloudinary.config.d.ts">
import { v2 as cloudinary } from "cloudinary";
export default cloudinary;
//# sourceMappingURL=cloudinary.config.d.ts.map
</file>

<file path="server/dist/config/cloudinary.config.d.ts.map">
{"version":3,"file":"cloudinary.config.d.ts","sourceRoot":"","sources":["../../src/config/cloudinary.config.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,EAAE,IAAI,UAAU,EAAE,MAAM,YAAY,CAAC;AAS9C,eAAe,UAAU,CAAC"}
</file>

<file path="server/dist/config/cloudinary.config.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloudinary_1 = require("cloudinary");
const env_config_1 = require("./env.config");
cloudinary_1.v2.config({
    cloud_name: env_config_1.config.CLOUDINARY_CLOUD_NAME,
    api_key: env_config_1.config.CLOUDINARY_API_KEY,
    api_secret: env_config_1.config.CLOUDINARY_API_SECRET,
});
exports.default = cloudinary_1.v2;
//# sourceMappingURL=cloudinary.config.js.map
</file>

<file path="server/dist/config/cloudinary.config.js.map">
{"version":3,"file":"cloudinary.config.js","sourceRoot":"","sources":["../../src/config/cloudinary.config.ts"],"names":[],"mappings":";;AAAA,2CAA8C;AAC9C,6CAAsC;AAEtC,eAAU,CAAC,MAAM,CAAC;IAChB,UAAU,EAAE,mBAAM,CAAC,qBAAqB;IACxC,OAAO,EAAE,mBAAM,CAAC,kBAAkB;IAClC,UAAU,EAAE,mBAAM,CAAC,qBAAqB;CACzC,CAAC,CAAC;AAEH,kBAAe,eAAU,CAAC"}
</file>

<file path="server/dist/config/db.d.ts">
import { PrismaClient } from "@prisma/client";
declare global {
    var prisma: PrismaClient | undefined;
}
declare const prisma: PrismaClient<import(".prisma/client").Prisma.PrismaClientOptions, never, import("@prisma/client/runtime/library").DefaultArgs>;
export declare const connectDB: () => Promise<void>;
export declare const disconnectDB: () => Promise<void>;
export declare const checkDBHealth: () => Promise<boolean>;
export default prisma;
//# sourceMappingURL=db.d.ts.map
</file>

<file path="server/dist/config/db.d.ts.map">
{"version":3,"file":"db.d.ts","sourceRoot":"","sources":["../../src/config/db.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAG9C,OAAO,CAAC,MAAM,CAAC;IACb,IAAI,MAAM,EAAE,YAAY,GAAG,SAAS,CAAC;CACtC;AAGD,QAAA,MAAM,MAAM,gIAOR,CAAC;AAUL,eAAO,MAAM,SAAS,qBAQrB,CAAC;AAKF,eAAO,MAAM,YAAY,qBAOxB,CAAC;AAKF,eAAO,MAAM,aAAa,QAAa,OAAO,CAAC,OAAO,CAQrD,CAAC;AAEF,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/config/db.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkDBHealth = exports.disconnectDB = exports.connectDB = void 0;
const client_1 = require("@prisma/client");
const prisma = global.prisma ||
    new client_1.PrismaClient({
        log: process.env.NODE_ENV === "development"
            ? ["query", "error", "warn"]
            : ["error"],
    });
if (process.env.NODE_ENV !== "production") {
    global.prisma = prisma;
}
const connectDB = async () => {
    try {
        await prisma.$connect();
        console.log("‚úÖ Database connected successfully");
    }
    catch (error) {
        console.error("‚ùå Database connection failed:", error);
        process.exit(1);
    }
};
exports.connectDB = connectDB;
const disconnectDB = async () => {
    try {
        await prisma.$disconnect();
        console.log("‚úÖ Database disconnected successfully");
    }
    catch (error) {
        console.error("‚ùå Database disconnection failed:", error);
    }
};
exports.disconnectDB = disconnectDB;
const checkDBHealth = async () => {
    try {
        await prisma.$queryRaw `SELECT 1`;
        return true;
    }
    catch (error) {
        console.error("‚ùå Database health check failed:", error);
        return false;
    }
};
exports.checkDBHealth = checkDBHealth;
exports.default = prisma;
//# sourceMappingURL=db.js.map
</file>

<file path="server/dist/config/db.js.map">
{"version":3,"file":"db.js","sourceRoot":"","sources":["../../src/config/db.ts"],"names":[],"mappings":";;;AAAA,2CAA8C;AAQ9C,MAAM,MAAM,GACV,MAAM,CAAC,MAAM;IACb,IAAI,qBAAY,CAAC;QACf,GAAG,EACD,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa;YACpC,CAAC,CAAC,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC;YAC5B,CAAC,CAAC,CAAC,OAAO,CAAC;KAChB,CAAC,CAAC;AAGL,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE,CAAC;IAC1C,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,CAAC;AAKM,MAAM,SAAS,GAAG,KAAK,IAAI,EAAE;IAClC,IAAI,CAAC;QACH,MAAM,MAAM,CAAC,QAAQ,EAAE,CAAC;QACxB,OAAO,CAAC,GAAG,CAAC,mCAAmC,CAAC,CAAC;IACnD,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,+BAA+B,EAAE,KAAK,CAAC,CAAC;QACtD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;AACH,CAAC,CAAC;AARW,QAAA,SAAS,aAQpB;AAKK,MAAM,YAAY,GAAG,KAAK,IAAI,EAAE;IACrC,IAAI,CAAC;QACH,MAAM,MAAM,CAAC,WAAW,EAAE,CAAC;QAC3B,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;IACtD,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,kCAAkC,EAAE,KAAK,CAAC,CAAC;IAC3D,CAAC;AACH,CAAC,CAAC;AAPW,QAAA,YAAY,gBAOvB;AAKK,MAAM,aAAa,GAAG,KAAK,IAAsB,EAAE;IACxD,IAAI,CAAC;QACH,MAAM,MAAM,CAAC,SAAS,CAAA,UAAU,CAAC;QACjC,OAAO,IAAI,CAAC;IACd,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,iCAAiC,EAAE,KAAK,CAAC,CAAC;QACxD,OAAO,KAAK,CAAC;IACf,CAAC;AACH,CAAC,CAAC;AARW,QAAA,aAAa,iBAQxB;AAEF,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/config/env.config.d.ts">
export declare const config: {
    NODE_ENV: string;
    PORT: number;
    SERVER_URL: string;
    CLIENT_URL: string;
    DATABASE_URL: string | undefined;
    JWT_SECRET: string;
    JWT_EXPIRE: string;
    JWT_REFRESH_SECRET: string;
    JWT_REFRESH_EXPIRE: string;
    MAX_FILE_SIZE: number;
    UPLOAD_DIR: string;
    BCRYPT_ROUNDS: number;
    EMAIL_SERVICE: string;
    EMAIL_USER: string | undefined;
    EMAIL_PASSWORD: string | undefined;
    EMAIL_FROM: string;
    VERIFICATION_EXPIRY: string;
    GOOGLE_CLIENT_ID: string | undefined;
    GOOGLE_CLIENT_SECRET: string | undefined;
    CLOUDINARY_CLOUD_NAME: string;
    CLOUDINARY_API_KEY: string;
    CLOUDINARY_API_SECRET: string;
};
export declare const validateEnv: () => void;
//# sourceMappingURL=env.config.d.ts.map
</file>

<file path="server/dist/config/env.config.d.ts.map">
{"version":3,"file":"env.config.d.ts","sourceRoot":"","sources":["../../src/config/env.config.ts"],"names":[],"mappings":"AAOA,eAAO,MAAM,MAAM;;;;;;;;;;;;;;;;;;;;;;;CAsClB,CAAC;AAKF,eAAO,MAAM,WAAW,YAWvB,CAAC"}
</file>

<file path="server/dist/config/env.config.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateEnv = exports.config = void 0;
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
exports.config = {
    NODE_ENV: process.env.NODE_ENV || "development",
    PORT: parseInt(process.env.PORT || "5000", 10),
    SERVER_URL: process.env.SERVER_URL || "http://localhost:5000",
    CLIENT_URL: process.env.CLIENT_URL || "http://localhost:3000",
    DATABASE_URL: process.env.DATABASE_URL,
    JWT_SECRET: process.env.JWT_SECRET || "your-super-secret-jwt-key",
    JWT_EXPIRE: process.env.JWT_EXPIRE || "7d",
    JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET || "your-refresh-secret",
    JWT_REFRESH_EXPIRE: process.env.JWT_REFRESH_EXPIRE || "30d",
    MAX_FILE_SIZE: parseInt(process.env.MAX_FILE_SIZE || "52428800", 10),
    UPLOAD_DIR: process.env.UPLOAD_DIR || "./uploads",
    BCRYPT_ROUNDS: parseInt(process.env.BCRYPT_ROUNDS || "10", 10),
    EMAIL_SERVICE: process.env.EMAIL_SERVICE || "gmail",
    EMAIL_USER: process.env.EMAIL_USER,
    EMAIL_PASSWORD: process.env.EMAIL_PASSWORD,
    EMAIL_FROM: process.env.EMAIL_FROM || "noreply@chatapp.com",
    VERIFICATION_EXPIRY: process.env.VERIFICATION_EXPIRY || "24h",
    GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
    GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
    CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME,
    CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY,
    CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET,
};
const validateEnv = () => {
    const required = ["DATABASE_URL", "JWT_SECRET"];
    const missing = required.filter((key) => !process.env[key]);
    if (missing.length > 0) {
        throw new Error(`Missing required environment variables: ${missing.join(", ")}`);
    }
    console.log("‚úÖ Environment variables validated");
};
exports.validateEnv = validateEnv;
//# sourceMappingURL=env.config.js.map
</file>

<file path="server/dist/config/env.config.js.map">
{"version":3,"file":"env.config.js","sourceRoot":"","sources":["../../src/config/env.config.ts"],"names":[],"mappings":";;;;;;AAAA,oDAA4B;AAE5B,gBAAM,CAAC,MAAM,EAAE,CAAC;AAKH,QAAA,MAAM,GAAG;IAEpB,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,QAAQ,IAAI,aAAa;IAC/C,IAAI,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,MAAM,EAAE,EAAE,CAAC;IAC9C,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,uBAAuB;IAC7D,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,uBAAuB;IAG7D,YAAY,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY;IAGtC,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,2BAA2B;IACjE,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,IAAI;IAC1C,kBAAkB,EAAE,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,qBAAqB;IAC3E,kBAAkB,EAAE,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,KAAK;IAG3D,aAAa,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,UAAU,EAAE,EAAE,CAAC;IACpE,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,WAAW;IAGjD,aAAa,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,IAAI,EAAE,EAAE,CAAC;IAG9D,aAAa,EAAE,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,OAAO;IACnD,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU;IAClC,cAAc,EAAE,OAAO,CAAC,GAAG,CAAC,cAAc;IAC1C,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,qBAAqB;IAC3D,mBAAmB,EAAE,OAAO,CAAC,GAAG,CAAC,mBAAmB,IAAI,KAAK;IAG7D,gBAAgB,EAAE,OAAO,CAAC,GAAG,CAAC,gBAAgB;IAC9C,oBAAoB,EAAE,OAAO,CAAC,GAAG,CAAC,oBAAoB;IAGtD,qBAAqB,EAAE,OAAO,CAAC,GAAG,CAAC,qBAAsB;IACzD,kBAAkB,EAAE,OAAO,CAAC,GAAG,CAAC,kBAAmB;IACnD,qBAAqB,EAAE,OAAO,CAAC,GAAG,CAAC,qBAAsB;CAC1D,CAAC;AAKK,MAAM,WAAW,GAAG,GAAG,EAAE;IAC9B,MAAM,QAAQ,GAAG,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;IAChD,MAAM,OAAO,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAE5D,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACvB,MAAM,IAAI,KAAK,CACb,2CAA2C,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAChE,CAAC;IACJ,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,mCAAmC,CAAC,CAAC;AACnD,CAAC,CAAC;AAXW,QAAA,WAAW,eAWtB"}
</file>

<file path="server/dist/config/google-auth.config.d.ts">
import passport from "passport";
export default passport;
//# sourceMappingURL=google-auth.config.d.ts.map
</file>

<file path="server/dist/config/google-auth.config.d.ts.map">
{"version":3,"file":"google-auth.config.d.ts","sourceRoot":"","sources":["../../src/config/google-auth.config.ts"],"names":[],"mappings":"AAAA,OAAO,QAAQ,MAAM,UAAU,CAAC;AAyFhC,eAAe,QAAQ,CAAC"}
</file>

<file path="server/dist/config/google-auth.config.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const passport_1 = __importDefault(require("passport"));
const passport_google_oauth20_1 = require("passport-google-oauth20");
const db_1 = __importDefault(require("./db"));
const env_config_1 = require("./env.config");
if (!env_config_1.config.GOOGLE_CLIENT_ID || !env_config_1.config.GOOGLE_CLIENT_SECRET) {
    console.warn("‚ö†Ô∏è  Google OAuth credentials not configured. Google authentication will not work.");
}
passport_1.default.use(new passport_google_oauth20_1.Strategy({
    clientID: env_config_1.config.GOOGLE_CLIENT_ID || "not-configured",
    clientSecret: env_config_1.config.GOOGLE_CLIENT_SECRET || "not-configured",
    callbackURL: `${env_config_1.config.SERVER_URL}/api/v1/auth/google/callback`,
    passReqToCallback: false,
    scope: ["email", "profile"],
}, async (accessToken, refreshToken, profile, done) => {
    try {
        const googleId = profile.id;
        const email = profile.emails?.[0]?.value;
        const name = profile.displayName;
        const avatar = profile.photos?.[0]?.value;
        if (!email) {
            return done(new Error("No email provided by Google"));
        }
        let user = await db_1.default.user.findUnique({
            where: { email },
        });
        if (user) {
            if (!user.googleId) {
                user = await db_1.default.user.update({
                    where: { email },
                    data: { googleId },
                });
            }
        }
        else {
            user = await db_1.default.user.create({
                data: {
                    email,
                    name: name || email.split("@")[0],
                    avatar: avatar || null,
                    googleId,
                    emailVerified: true,
                    role: "USER",
                },
            });
        }
        return done(null, user);
    }
    catch (error) {
        return done(error);
    }
}));
passport_1.default.serializeUser((user, done) => {
    done(null, user.id);
});
passport_1.default.deserializeUser(async (id, done) => {
    try {
        const user = await db_1.default.user.findUnique({
            where: { id },
            select: {
                id: true,
                email: true,
                name: true,
                role: true,
                avatar: true,
            },
        });
        done(null, user);
    }
    catch (error) {
        done(error);
    }
});
exports.default = passport_1.default;
//# sourceMappingURL=google-auth.config.js.map
</file>

<file path="server/dist/config/google-auth.config.js.map">
{"version":3,"file":"google-auth.config.js","sourceRoot":"","sources":["../../src/config/google-auth.config.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/controllers/auth.controller.d.ts">
import { Request, Response } from "express";
export declare const register: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const login: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const verifyEmail: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const resendVerification: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const forgotPassword: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const resetPassword: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const refreshTokens: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const logout: (req: Request, res: Response, next: import("express").NextFunction) => void;
//# sourceMappingURL=auth.controller.d.ts.map
</file>

<file path="server/dist/controllers/auth.controller.d.ts.map">
{"version":3,"file":"auth.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/auth.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAQ5C,eAAO,MAAM,QAAQ,6EAcnB,CAAC;AAEH,eAAO,MAAM,KAAK,6EAqBhB,CAAC;AAEH,eAAO,MAAM,WAAW,6EAiBtB,CAAC;AAEH,eAAO,MAAM,kBAAkB,6EAa7B,CAAC;AAEH,eAAO,MAAM,cAAc,6EAazB,CAAC;AAEH,eAAO,MAAM,aAAa,6EAcxB,CAAC;AAEH,eAAO,MAAM,aAAa,6EAiBxB,CAAC;AAEH,eAAO,MAAM,MAAM,6EAkBjB,CAAC"}
</file>

<file path="server/dist/controllers/auth.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logout = exports.refreshTokens = exports.resetPassword = exports.forgotPassword = exports.resendVerification = exports.verifyEmail = exports.login = exports.register = void 0;
const zod_1 = require("zod");
const auth_service_1 = require("../services/auth.service");
const auth_dto_1 = require("../dto/auth.dto");
const error_middleware_1 = require("../middleware/error.middleware");
const authService = new auth_service_1.AuthService();
exports.register = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const parse = auth_dto_1.registerSchema.safeParse(req.body);
    if (!parse.success) {
        const errors = zod_1.z.treeifyError(parse.error);
        return res.status(400).json({ success: false, errors });
    }
    const result = await authService.register(parse.data);
    return res.status(201).json({
        success: true,
        message: result.message,
        data: result.data,
    });
});
exports.login = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const parse = auth_dto_1.loginSchema.safeParse(req.body);
    if (!parse.success) {
        const errors = zod_1.z.treeifyError(parse.error);
        return res.status(400).json({ success: false, errors });
    }
    const result = await authService.login(parse.data);
    res.cookie("refreshToken", result.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: 7 * 24 * 60 * 60 * 1000,
    });
    return res.status(200).json({
        success: true,
        message: result.message,
        data: result.data,
    });
});
exports.verifyEmail = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const { token } = req.query;
    if (!token || typeof token !== "string") {
        return res.status(400).json({
            success: false,
            message: "Verification token is required",
        });
    }
    const result = await authService.verifyEmail(token);
    return res.status(200).json({
        success: true,
        message: result.message,
        data: result.data,
    });
});
exports.resendVerification = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const parse = auth_dto_1.resendVerificationSchema.safeParse(req.body);
    if (!parse.success) {
        const errors = zod_1.z.treeifyError(parse.error);
        return res.status(400).json({ success: false, errors });
    }
    const result = await authService.resendVerification(parse.data.email);
    return res.status(200).json({
        success: true,
        message: result.message,
    });
});
exports.forgotPassword = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const parse = auth_dto_1.forgotPasswordSchema.safeParse(req.body);
    if (!parse.success) {
        const errors = zod_1.z.treeifyError(parse.error);
        return res.status(400).json({ success: false, errors });
    }
    const result = await authService.forgotPassword(parse.data.email);
    return res.status(200).json({
        success: true,
        message: result.message,
    });
});
exports.resetPassword = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const parse = auth_dto_1.resetPasswordSchema.safeParse(req.body);
    if (!parse.success) {
        const errors = zod_1.z.treeifyError(parse.error);
        return res.status(400).json({ success: false, errors });
    }
    const result = await authService.resetPassword(parse.data.token, parse.data.password);
    return res.status(200).json({
        success: true,
        message: result.message,
        data: result.data,
    });
});
exports.refreshTokens = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const refreshToken = req.cookies?.refreshToken;
    const result = await authService.refreshTokens(refreshToken);
    res.cookie("refreshToken", result.tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: 7 * 24 * 60 * 60 * 1000,
    });
    return res.status(200).json({
        success: true,
        message: "Tokens refreshed",
        data: { accessToken: result.tokens.accessToken },
    });
});
exports.logout = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        return res.status(401).json({
            success: false,
            message: "User not authenticated",
        });
    }
    await authService.logout(userId);
    res.clearCookie("refreshToken");
    return res.status(200).json({
        success: true,
        message: "Logged out successfully",
    });
});
//# sourceMappingURL=auth.controller.js.map
</file>

<file path="server/dist/controllers/auth.controller.js.map">
{"version":3,"file":"auth.controller.js","sourceRoot":"","sources":["../../src/controllers/auth.controller.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/controllers/call.controller.d.ts">
import { Request, Response } from "express";
export declare const initiateCall: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const updateCallStatus: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const endCall: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const declineCall: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getActiveCall: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getCallHistory: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const missCall: (req: Request, res: Response, next: import("express").NextFunction) => void;
//# sourceMappingURL=call.controller.d.ts.map
</file>

<file path="server/dist/controllers/call.controller.d.ts.map">
{"version":3,"file":"call.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/call.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAO5C,eAAO,MAAM,YAAY,6EA0BvB,CAAC;AAGH,eAAO,MAAM,gBAAgB,6EA8B3B,CAAC;AAGH,eAAO,MAAM,OAAO,6EAelB,CAAC;AAGH,eAAO,MAAM,WAAW,6EAetB,CAAC;AAGH,eAAO,MAAM,aAAa,6EAoBxB,CAAC;AAGH,eAAO,MAAM,cAAc,6EAuBzB,CAAC;AAGH,eAAO,MAAM,QAAQ,6EAenB,CAAC"}
</file>

<file path="server/dist/controllers/call.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.missCall = exports.getCallHistory = exports.getActiveCall = exports.declineCall = exports.endCall = exports.updateCallStatus = exports.initiateCall = void 0;
const call_service_1 = require("../services/call.service");
const response_util_1 = require("../utils/response.util");
const error_types_1 = require("../types/error.types");
const error_middleware_1 = require("../middleware/error.middleware");
exports.initiateCall = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId, receiverId, callType } = req.body;
    if (!conversationId || !receiverId || !callType) {
        throw new error_types_1.BadRequestError("conversationId, receiverId, and callType are required");
    }
    if (!["AUDIO", "VIDEO"].includes(callType)) {
        throw new error_types_1.BadRequestError("callType must be AUDIO or VIDEO");
    }
    const call = await call_service_1.callService.initiateCall(conversationId, userId, receiverId, callType);
    (0, response_util_1.sendResponse)(res, 201, "Call initiated", call);
});
exports.updateCallStatus = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { callId, status } = req.body;
    if (!callId || !status) {
        throw new error_types_1.BadRequestError("callId and status are required");
    }
    const validStatuses = [
        "INITIATING",
        "RINGING",
        "ACTIVE",
        "ENDED",
        "DECLINED",
        "MISSED",
        "CANCELED",
    ];
    if (!validStatuses.includes(status)) {
        throw new error_types_1.BadRequestError(`status must be one of: ${validStatuses.join(", ")}`);
    }
    const call = await call_service_1.callService.updateCallStatus(callId, status);
    (0, response_util_1.sendResponse)(res, 200, "Call status updated", call);
});
exports.endCall = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { callId } = req.body;
    if (!callId) {
        throw new error_types_1.BadRequestError("callId is required");
    }
    const call = await call_service_1.callService.endCall(callId);
    (0, response_util_1.sendResponse)(res, 200, "Call ended", call);
});
exports.declineCall = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { callId } = req.body;
    if (!callId) {
        throw new error_types_1.BadRequestError("callId is required");
    }
    const call = await call_service_1.callService.declineCall(callId);
    (0, response_util_1.sendResponse)(res, 200, "Call declined", call);
});
exports.getActiveCall = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = req.params;
    if (!conversationId) {
        throw new error_types_1.BadRequestError("conversationId is required");
    }
    const call = await call_service_1.callService.getActiveCall(conversationId);
    if (!call) {
        (0, response_util_1.sendResponse)(res, 200, "No active call", null);
        return;
    }
    (0, response_util_1.sendResponse)(res, 200, "Active call retrieved", call);
});
exports.getCallHistory = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = req.params;
    const limit = Number(req.query.limit) || 20;
    const page = Number(req.query.page) || 1;
    const skip = (page - 1) * limit;
    if (!conversationId) {
        throw new error_types_1.BadRequestError("conversationId is required");
    }
    const calls = await call_service_1.callService.getCallHistory(conversationId, userId, limit, skip);
    (0, response_util_1.sendResponse)(res, 200, "Call history retrieved", calls);
});
exports.missCall = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { callId } = req.body;
    if (!callId) {
        throw new error_types_1.BadRequestError("callId is required");
    }
    const call = await call_service_1.callService.missCall(callId);
    (0, response_util_1.sendResponse)(res, 200, "Call marked as missed", call);
});
//# sourceMappingURL=call.controller.js.map
</file>

<file path="server/dist/controllers/call.controller.js.map">
{"version":3,"file":"call.controller.js","sourceRoot":"","sources":["../../src/controllers/call.controller.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/controllers/conversation.controller.d.ts">
import { Request, Response, NextFunction } from "express";
export declare const getOrCreateConversation: (req: Request, res: Response, next: NextFunction) => void;
export declare const getUserConversations: (req: Request, res: Response, next: NextFunction) => void;
export declare const getConversation: (req: Request, res: Response, next: NextFunction) => void;
export declare const getOtherUser: (req: Request, res: Response, next: NextFunction) => void;
export declare const archiveConversation: (req: Request, res: Response, next: NextFunction) => void;
export declare const unarchiveConversation: (req: Request, res: Response, next: NextFunction) => void;
export declare const deleteConversation: (req: Request, res: Response, next: NextFunction) => void;
//# sourceMappingURL=conversation.controller.d.ts.map
</file>

<file path="server/dist/controllers/conversation.controller.d.ts.map">
{"version":3,"file":"conversation.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/conversation.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAgB1D,eAAO,MAAM,uBAAuB,2DAoBnC,CAAC;AAGF,eAAO,MAAM,oBAAoB,2DAsBhC,CAAC;AAGF,eAAO,MAAM,eAAe,2DAqB1B,CAAC;AAGH,eAAO,MAAM,YAAY,2DAevB,CAAC;AAGH,eAAO,MAAM,mBAAmB,2DAc9B,CAAC;AAGH,eAAO,MAAM,qBAAqB,2DAgBjC,CAAC;AAGF,eAAO,MAAM,kBAAkB,2DAW7B,CAAC"}
</file>

<file path="server/dist/controllers/conversation.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteConversation = exports.unarchiveConversation = exports.archiveConversation = exports.getOtherUser = exports.getConversation = exports.getUserConversations = exports.getOrCreateConversation = void 0;
const conversation_service_1 = require("../services/conversation.service");
const message_service_1 = require("../services/message.service");
const conversation_dto_1 = require("../dto/conversation.dto");
const response_util_1 = require("../utils/response.util");
const error_types_1 = require("../types/error.types");
const error_middleware_1 = require("../middleware/error.middleware");
exports.getOrCreateConversation = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { friendId } = conversation_dto_1.getOrCreateConversationSchema.parse(req.body);
    if (friendId === userId) {
        throw new error_types_1.BadRequestError("Cannot start conversation with yourself");
    }
    const conversation = await conversation_service_1.conversationService.getOrCreateConversation(userId, friendId);
    (0, response_util_1.sendResponse)(res, 200, "Conversation retrieved or created", conversation);
});
exports.getUserConversations = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const query = conversation_dto_1.getUserConversationsQuerySchema.parse(req.query || {});
    const limit = query.limit || 20;
    const page = query.page || 1;
    const skip = (page - 1) * limit;
    const search = query.search;
    const conversations = await conversation_service_1.conversationService.getUserConversations(userId, limit, skip, search);
    (0, response_util_1.sendResponse)(res, 200, "Conversations retrieved", conversations);
});
exports.getConversation = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = conversation_dto_1.getConversationSchema.parse(req.params);
    const conversation = await conversation_service_1.conversationService.getConversation(conversationId, userId);
    if (!conversation) {
        throw new error_types_1.NotFoundError("Conversation not found");
    }
    await message_service_1.messageService.markMessagesAsRead(conversationId, userId);
    (0, response_util_1.sendResponse)(res, 200, "Conversation retrieved", conversation);
});
exports.getOtherUser = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = conversation_dto_1.getConversationSchema.parse(req.params);
    const otherUser = await conversation_service_1.conversationService.getOtherUser(conversationId, userId);
    if (!otherUser) {
        throw new error_types_1.NotFoundError("User not found in this conversation");
    }
    (0, response_util_1.sendResponse)(res, 200, "Other user retrieved", otherUser);
});
exports.archiveConversation = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = conversation_dto_1.archiveConversationSchema.parse(req.body || {});
    const conversation = await conversation_service_1.conversationService.archiveConversation(conversationId, userId);
    (0, response_util_1.sendResponse)(res, 200, "Conversation archived", conversation);
});
exports.unarchiveConversation = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = conversation_dto_1.unarchiveConversationSchema.parse(req.body || {});
    const conversation = await conversation_service_1.conversationService.unarchiveConversation(conversationId, userId);
    (0, response_util_1.sendResponse)(res, 200, "Conversation unarchived", conversation);
});
exports.deleteConversation = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = conversation_dto_1.deleteConversationSchema.parse(req.body || {});
    await conversation_service_1.conversationService.deleteConversation(conversationId, userId);
    (0, response_util_1.sendResponse)(res, 204, "Conversation deleted", null);
});
//# sourceMappingURL=conversation.controller.js.map
</file>

<file path="server/dist/controllers/conversation.controller.js.map">
{"version":3,"file":"conversation.controller.js","sourceRoot":"","sources":["../../src/controllers/conversation.controller.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/controllers/friend.controller.d.ts">
import { Request, Response } from "express";
export declare const sendFriendRequestHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const acceptFriendRequestHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const rejectFriendRequestHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const cancelFriendRequestHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getFriendRequestsHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getFriendsHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const removeFriendHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
//# sourceMappingURL=friend.controller.d.ts.map
</file>

<file path="server/dist/controllers/friend.controller.d.ts.map">
{"version":3,"file":"friend.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/friend.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAuB5C,eAAO,MAAM,wBAAwB,6EA6BpC,CAAC;AAMF,eAAO,MAAM,0BAA0B,6EAiBtC,CAAC;AAMF,eAAO,MAAM,0BAA0B,6EAiBtC,CAAC;AAMF,eAAO,MAAM,0BAA0B,6EActC,CAAC;AAOF,eAAO,MAAM,wBAAwB,6EA+CpC,CAAC;AAMF,eAAO,MAAM,iBAAiB,6EAyC7B,CAAC;AAMF,eAAO,MAAM,mBAAmB,6EAc/B,CAAC"}
</file>

<file path="server/dist/controllers/friend.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeFriendHandler = exports.getFriendsHandler = exports.getFriendRequestsHandler = exports.cancelFriendRequestHandler = exports.rejectFriendRequestHandler = exports.acceptFriendRequestHandler = exports.sendFriendRequestHandler = void 0;
const error_middleware_1 = require("../middleware/error.middleware");
const friend_service_1 = require("../services/friend.service");
const friend_dto_1 = require("../dto/friend.dto");
exports.sendFriendRequestHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const validationResult = friend_dto_1.sendFriendRequestSchema.safeParse(req.body);
    if (!validationResult.success) {
        res.status(400).json({
            message: "Validation failed",
            errors: validationResult.error.flatten().fieldErrors,
        });
        return;
    }
    const { receiverId } = validationResult.data;
    const friendRequest = await (0, friend_service_1.sendFriendRequest)(userId, receiverId);
    res.status(201).json({
        message: "Friend request sent successfully",
        data: friendRequest,
    });
});
exports.acceptFriendRequestHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    const { requestId } = req.params;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const result = await (0, friend_service_1.acceptFriendRequest)(requestId, userId);
    res.status(200).json({
        message: "Friend request accepted successfully",
        data: result,
    });
});
exports.rejectFriendRequestHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    const { requestId } = req.params;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const result = await (0, friend_service_1.rejectFriendRequest)(requestId, userId);
    res.status(200).json({
        message: "Friend request rejected successfully",
        data: result,
    });
});
exports.cancelFriendRequestHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    const { requestId } = req.params;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const result = await (0, friend_service_1.cancelFriendRequest)(requestId, userId);
    res.status(200).json(result);
});
exports.getFriendRequestsHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const validationResult = friend_dto_1.getFriendRequestsQuerySchema.safeParse(req.query);
    if (!validationResult.success) {
        res.status(400).json({
            message: "Validation failed",
            errors: validationResult.error.flatten().fieldErrors,
        });
        return;
    }
    const { type } = validationResult.data;
    const limit = parseInt(validationResult.data.limit, 10);
    const page = parseInt(validationResult.data.page, 10);
    const skip = (page - 1) * limit;
    const requests = await (0, friend_service_1.getFriendRequests)(userId, type, limit, skip);
    const total = await (0, friend_service_1.getFriendRequestsCount)(userId, type);
    const message = type === "pending"
        ? "Pending friend requests retrieved successfully"
        : "Sent friend requests retrieved successfully";
    res.status(200).json({
        message,
        data: {
            requests,
            type,
            pagination: {
                total,
                page,
                limit,
                pages: Math.ceil(total / limit),
            },
        },
    });
});
exports.getFriendsHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const validationResult = friend_dto_1.getFriendsQuerySchema.safeParse(req.query);
    if (!validationResult.success) {
        res.status(400).json({
            message: "Validation failed",
            errors: validationResult.error.flatten().fieldErrors,
        });
        return;
    }
    const limit = parseInt(validationResult.data.limit, 10);
    const page = parseInt(validationResult.data.page, 10);
    const skip = (page - 1) * limit;
    const search = validationResult.data.search;
    const friends = await (0, friend_service_1.getFriends)(userId, limit, skip, search);
    const total = await (0, friend_service_1.getFriendsCount)(userId, search);
    res.status(200).json({
        message: "Friends retrieved successfully",
        data: {
            friends,
            pagination: {
                total,
                page,
                limit,
                pages: Math.ceil(total / limit),
            },
        },
    });
});
exports.removeFriendHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    const { friendId } = req.params;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const result = await (0, friend_service_1.removeFriend)(userId, friendId);
    res.status(200).json(result);
});
//# sourceMappingURL=friend.controller.js.map
</file>

<file path="server/dist/controllers/friend.controller.js.map">
{"version":3,"file":"friend.controller.js","sourceRoot":"","sources":["../../src/controllers/friend.controller.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/controllers/google-auth.controller.d.ts">
import { Request, Response } from "express";
export declare const googleCallback: (req: Request, res: Response) => Promise<void>;
export declare const googleAuth: (req: Request, res: Response) => void;
export declare const googleLogout: (req: Request, res: Response, next: import("express").NextFunction) => void;
//# sourceMappingURL=google-auth.controller.d.ts.map
</file>

<file path="server/dist/controllers/google-auth.controller.d.ts.map">
{"version":3,"file":"google-auth.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/google-auth.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAK5C,eAAO,MAAM,cAAc,GAAU,KAAK,OAAO,EAAE,KAAK,QAAQ,KAAG,OAAO,CAAC,IAAI,CA4C9E,CAAC;AAEF,eAAO,MAAM,UAAU,GAAI,KAAK,OAAO,EAAE,KAAK,QAAQ,KAAG,IAKxD,CAAC;AAEF,eAAO,MAAM,YAAY,6EAiBvB,CAAC"}
</file>

<file path="server/dist/controllers/google-auth.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.googleLogout = exports.googleAuth = exports.googleCallback = void 0;
const jwt_util_1 = require("../utils/jwt.util");
const env_config_1 = require("../config/env.config");
const error_middleware_1 = require("../middleware/error.middleware");
const googleCallback = async (req, res) => {
    try {
        const googleUser = req.user;
        if (!googleUser || !googleUser.id || !googleUser.email) {
            res.status(401).json({
                success: false,
                message: "Authentication failed",
            });
            return;
        }
        const tokens = (0, jwt_util_1.generateAuthTokens)({
            userId: googleUser.id,
            email: googleUser.email,
            role: googleUser.role || "USER",
        });
        res.cookie("refreshToken", tokens.refreshToken, {
            httpOnly: true,
            secure: env_config_1.config.NODE_ENV === "production",
            sameSite: "strict",
            maxAge: 30 * 24 * 60 * 60 * 1000,
        });
        const redirectUrl = `${env_config_1.config.CLIENT_URL}/auth/google/callback?token=${tokens.accessToken}&user=${encodeURIComponent(JSON.stringify({
            id: googleUser.id,
            email: googleUser.email,
            name: googleUser.name || "",
            avatar: googleUser.avatar || "",
            role: googleUser.role || "USER",
        }))}`;
        res.redirect(redirectUrl);
    }
    catch (error) {
        console.error("Google callback error:", error);
        res.redirect(`${env_config_1.config.CLIENT_URL}/auth/error?message=Authentication failed`);
    }
};
exports.googleCallback = googleCallback;
const googleAuth = (req, res) => {
    res.json({
        success: true,
        message: "Redirecting to Google login...",
    });
};
exports.googleAuth = googleAuth;
exports.googleLogout = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({
            success: false,
            message: "Not authenticated",
        });
        return;
    }
    res.clearCookie("refreshToken");
    res.status(200).json({
        success: true,
        message: "Logged out successfully",
    });
});
//# sourceMappingURL=google-auth.controller.js.map
</file>

<file path="server/dist/controllers/google-auth.controller.js.map">
{"version":3,"file":"google-auth.controller.js","sourceRoot":"","sources":["../../src/controllers/google-auth.controller.ts"],"names":[],"mappings":";;;AACA,gDAAuD;AACvD,qDAA8C;AAC9C,qEAA8D;AAEvD,MAAM,cAAc,GAAG,KAAK,EAAE,GAAY,EAAE,GAAa,EAAiB,EAAE;IACjF,IAAI,CAAC;QACH,MAAM,UAAU,GAAI,GAAW,CAAC,IAEnB,CAAC;QAEd,IAAI,CAAC,UAAU,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;YACvD,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;gBACnB,OAAO,EAAE,KAAK;gBACd,OAAO,EAAE,uBAAuB;aACjC,CAAC,CAAC;YACH,OAAO;QACT,CAAC;QAED,MAAM,MAAM,GAAG,IAAA,6BAAkB,EAAC;YAChC,MAAM,EAAE,UAAU,CAAC,EAAE;YACrB,KAAK,EAAE,UAAU,CAAC,KAAK;YACvB,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,MAAM;SAChC,CAAC,CAAC;QAEH,GAAG,CAAC,MAAM,CAAC,cAAc,EAAE,MAAM,CAAC,YAAY,EAAE;YAC9C,QAAQ,EAAE,IAAI;YACd,MAAM,EAAE,mBAAM,CAAC,QAAQ,KAAK,YAAY;YACxC,QAAQ,EAAE,QAAQ;YAClB,MAAM,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;SACjC,CAAC,CAAC;QAEH,MAAM,WAAW,GAAG,GAAG,mBAAM,CAAC,UAAU,+BAA+B,MAAM,CAAC,WAAW,SAAS,kBAAkB,CAClH,IAAI,CAAC,SAAS,CAAC;YACb,EAAE,EAAE,UAAU,CAAC,EAAE;YACjB,KAAK,EAAE,UAAU,CAAC,KAAK;YACvB,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,EAAE;YAC3B,MAAM,EAAE,UAAU,CAAC,MAAM,IAAI,EAAE;YAC/B,IAAI,EAAE,UAAU,CAAC,IAAI,IAAI,MAAM;SAChC,CAAC,CACH,EAAE,CAAC;QAEJ,GAAG,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;IAC5B,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,wBAAwB,EAAE,KAAK,CAAC,CAAC;QAC/C,GAAG,CAAC,QAAQ,CACV,GAAG,mBAAM,CAAC,UAAU,2CAA2C,CAChE,CAAC;IACJ,CAAC;AACH,CAAC,CAAC;AA5CW,QAAA,cAAc,kBA4CzB;AAEK,MAAM,UAAU,GAAG,CAAC,GAAY,EAAE,GAAa,EAAQ,EAAE;IAC9D,GAAG,CAAC,IAAI,CAAC;QACP,OAAO,EAAE,IAAI;QACb,OAAO,EAAE,gCAAgC;KAC1C,CAAC,CAAC;AACL,CAAC,CAAC;AALW,QAAA,UAAU,cAKrB;AAEW,QAAA,YAAY,GAAG,IAAA,+BAAY,EAAC,KAAK,EAAE,GAAY,EAAE,GAAa,EAAiB,EAAE;IAC5F,MAAM,MAAM,GAAG,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC;IAEhC,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;YACnB,OAAO,EAAE,KAAK;YACd,OAAO,EAAE,mBAAmB;SAC7B,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IAED,GAAG,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;IAEhC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;QACnB,OAAO,EAAE,IAAI;QACb,OAAO,EAAE,yBAAyB;KACnC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC"}
</file>

<file path="server/dist/controllers/message.controller.d.ts">
import { Request, Response } from "express";
export declare const sendMessage: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getMessages: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const editMessage: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const deleteMessage: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const markAsRead: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getReadReceipts: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const reactToMessage: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const removeReaction: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getReactions: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const searchMessages: (req: Request, res: Response, next: import("express").NextFunction) => void;
//# sourceMappingURL=message.controller.d.ts.map
</file>

<file path="server/dist/controllers/message.controller.d.ts.map">
{"version":3,"file":"message.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/message.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAe5C,eAAO,MAAM,WAAW,6EAiBtB,CAAC;AAGH,eAAO,MAAM,WAAW,6EAkBtB,CAAC;AAGH,eAAO,MAAM,WAAW,6EAetB,CAAC;AAGH,eAAO,MAAM,aAAa,6EAazB,CAAC;AAGF,eAAO,MAAM,UAAU,6EAWrB,CAAC;AAGH,eAAO,MAAM,eAAe,6EAa3B,CAAC;AAGF,eAAO,MAAM,cAAc,6EAiB1B,CAAC;AAGF,eAAO,MAAM,cAAc,6EAiB1B,CAAC;AAGF,eAAO,MAAM,YAAY,6EAQxB,CAAC;AAGF,eAAO,MAAM,cAAc,6EAqB1B,CAAC"}
</file>

<file path="server/dist/controllers/message.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchMessages = exports.getReactions = exports.removeReaction = exports.reactToMessage = exports.getReadReceipts = exports.markAsRead = exports.deleteMessage = exports.editMessage = exports.getMessages = exports.sendMessage = void 0;
const message_service_1 = require("../services/message.service");
const message_dto_1 = require("../dto/message.dto");
const response_util_1 = require("../utils/response.util");
const error_types_1 = require("../types/error.types");
const error_middleware_1 = require("../middleware/error.middleware");
exports.sendMessage = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const payload = message_dto_1.sendMessageSchema.parse(req.body);
    const message = await message_service_1.messageService.sendMessage(payload.conversationId, userId, payload.content, payload.type, payload.mediaUrls);
    (0, response_util_1.sendResponse)(res, 201, "Message sent", message);
});
exports.getMessages = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId } = req.params;
    const limit = Number(req.query.limit) || 20;
    const page = Number(req.query.page) || 1;
    const skip = (page - 1) * limit;
    const messages = await message_service_1.messageService.getMessages(conversationId, limit, skip);
    (0, response_util_1.sendResponse)(res, 200, "Messages retrieved", messages);
});
exports.editMessage = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const payload = message_dto_1.editMessageSchema.parse(req.body);
    const message = await message_service_1.messageService.editMessage(payload.messageId, userId, payload.newContent);
    (0, response_util_1.sendResponse)(res, 200, "Message edited", message);
});
exports.deleteMessage = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const payload = message_dto_1.deleteMessageSchema.parse(req.body);
    await message_service_1.messageService.deleteMessage(payload.messageId, userId);
    (0, response_util_1.sendResponse)(res, 204, "Message deleted", null);
});
exports.markAsRead = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const payload = message_dto_1.markAsReadSchema.parse(req.body);
    await message_service_1.messageService.markMessagesAsRead(payload.conversationId, userId);
    (0, response_util_1.sendResponse)(res, 200, "Messages marked as read", null);
});
exports.getReadReceipts = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { messageId } = req.params;
    const receipts = await message_service_1.messageService.getMessageReadReceipts(messageId);
    (0, response_util_1.sendResponse)(res, 200, "Read receipts retrieved", receipts);
});
exports.reactToMessage = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const payload = message_dto_1.reactToMessageSchema.parse(req.body);
    const reaction = await message_service_1.messageService.reactToMessage(payload.messageId, userId, payload.emoji);
    (0, response_util_1.sendResponse)(res, 201, "Reaction added", reaction);
});
exports.removeReaction = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const payload = message_dto_1.removeReactionSchema.parse(req.body);
    await message_service_1.messageService.removeReaction(payload.messageId, userId, payload.emoji);
    (0, response_util_1.sendResponse)(res, 204, "Reaction removed", null);
});
exports.getReactions = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const { messageId } = req.params;
    const reactions = await message_service_1.messageService.getMessageReactions(messageId);
    (0, response_util_1.sendResponse)(res, 200, "Reactions retrieved", reactions);
});
exports.searchMessages = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        throw new error_types_1.AuthorizationError("Unauthorized");
    }
    const { conversationId, q } = req.query;
    if (!q || typeof q !== "string") {
        throw new error_types_1.BadRequestError("Search query required");
    }
    if (!conversationId || typeof conversationId !== "string") {
        throw new error_types_1.BadRequestError("Conversation ID required");
    }
    const messages = await message_service_1.messageService.searchMessages(conversationId, q);
    (0, response_util_1.sendResponse)(res, 200, "Messages found", messages);
});
//# sourceMappingURL=message.controller.js.map
</file>

<file path="server/dist/controllers/message.controller.js.map">
{"version":3,"file":"message.controller.js","sourceRoot":"","sources":["../../src/controllers/message.controller.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/controllers/user.controller.d.ts">
import { Request, Response } from "express";
export declare const getProfile: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getUserByIdHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const updateProfile: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const uploadAvatar: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const searchUsersHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const updateStatus: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const deleteAccount: (req: Request, res: Response, next: import("express").NextFunction) => void;
export declare const getAllUsersHandler: (req: Request, res: Response, next: import("express").NextFunction) => void;
//# sourceMappingURL=user.controller.d.ts.map
</file>

<file path="server/dist/controllers/user.controller.d.ts.map">
{"version":3,"file":"user.controller.d.ts","sourceRoot":"","sources":["../../src/controllers/user.controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAkB5C,eAAO,MAAM,UAAU,6EAcrB,CAAC;AAKH,eAAO,MAAM,kBAAkB,6EAS7B,CAAC;AAKH,eAAO,MAAM,aAAa,6EAyBxB,CAAC;AAKH,eAAO,MAAM,YAAY,6EAmBvB,CAAC;AAKH,eAAO,MAAM,kBAAkB,6EAsB7B,CAAC;AAKH,eAAO,MAAM,YAAY,6EAqBvB,CAAC;AAKH,eAAO,MAAM,aAAa,6EAaxB,CAAC;AAKH,eAAO,MAAM,kBAAkB,6EAoB7B,CAAC"}
</file>

<file path="server/dist/controllers/user.controller.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllUsersHandler = exports.deleteAccount = exports.updateStatus = exports.searchUsersHandler = exports.uploadAvatar = exports.updateProfile = exports.getUserByIdHandler = exports.getProfile = void 0;
const user_dto_1 = require("../dto/user.dto");
const user_service_1 = require("../services/user.service");
const error_middleware_1 = require("../middleware/error.middleware");
exports.getProfile = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const user = await (0, user_service_1.getUserProfile)(userId);
    res.status(200).json({
        message: "Profile retrieved successfully",
        user,
    });
});
exports.getUserByIdHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const { id } = req.params;
    const user = await (0, user_service_1.getUserById)(id);
    res.status(200).json({
        message: "User retrieved successfully",
        user,
    });
});
exports.updateProfile = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const validationResult = user_dto_1.updateProfileSchema.safeParse(req.body);
    if (!validationResult.success) {
        res.status(400).json({
            message: "Validation failed",
            errors: validationResult.error.flatten().fieldErrors,
        });
        return;
    }
    const updatedUser = await (0, user_service_1.updateUserProfile)(userId, validationResult.data);
    res.status(200).json({
        message: "Profile updated successfully",
        user: updatedUser,
    });
});
exports.uploadAvatar = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    if (!req.file) {
        res.status(400).json({ message: "No file uploaded" });
        return;
    }
    const updatedUser = await (0, user_service_1.uploadUserAvatar)(userId, req.file);
    res.status(200).json({
        message: "Avatar uploaded successfully",
        user: updatedUser,
    });
});
exports.searchUsersHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const validationResult = user_dto_1.searchUsersSchema.safeParse(req.query);
    if (!validationResult.success) {
        res.status(400).json({
            message: "Validation failed",
            errors: validationResult.error.flatten().fieldErrors,
        });
        return;
    }
    const { query, limit } = validationResult.data;
    const limitNumber = limit ? parseInt(limit, 10) : 10;
    const users = await (0, user_service_1.searchUsers)(query, limitNumber);
    res.status(200).json({
        message: "Users found",
        count: users.length,
        users,
    });
});
exports.updateStatus = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    const { status } = req.body;
    if (!status) {
        res.status(400).json({ message: "Status is required" });
        return;
    }
    const updatedUser = await (0, user_service_1.updateUserStatus)(userId, status);
    res.status(200).json({
        message: "Status updated successfully",
        user: updatedUser,
    });
});
exports.deleteAccount = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
    }
    await (0, user_service_1.deleteUserAccount)(userId);
    res.status(200).json({
        message: "Account deleted successfully",
    });
});
exports.getAllUsersHandler = (0, error_middleware_1.asyncHandler)(async (req, res) => {
    const limit = parseInt(req.query.limit) || 10;
    const page = parseInt(req.query.page) || 1;
    const skip = (page - 1) * limit;
    const users = await (0, user_service_1.getAllUsers)(limit, skip);
    const total = await (0, user_service_1.getTotalUsersCount)();
    res.status(200).json({
        message: "All users retrieved successfully",
        data: {
            users,
            pagination: {
                total,
                page,
                limit,
                pages: Math.ceil(total / limit),
            },
        },
    });
});
//# sourceMappingURL=user.controller.js.map
</file>

<file path="server/dist/controllers/user.controller.js.map">
{"version":3,"file":"user.controller.js","sourceRoot":"","sources":["../../src/controllers/user.controller.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/dto/auth.dto.d.ts">
import { z } from "zod";
export declare const registerSchema: z.ZodObject<{
    name: z.ZodString;
    email: z.ZodString;
    password: z.ZodString;
}, z.core.$strip>;
export type RegisterDTO = z.infer<typeof registerSchema>;
export declare const loginSchema: z.ZodObject<{
    email: z.ZodString;
    password: z.ZodString;
}, z.core.$strip>;
export type LoginDTO = z.infer<typeof loginSchema>;
export declare const resendVerificationSchema: z.ZodObject<{
    email: z.ZodString;
}, z.core.$strip>;
export type ResendVerificationDTO = z.infer<typeof resendVerificationSchema>;
export declare const forgotPasswordSchema: z.ZodObject<{
    email: z.ZodString;
}, z.core.$strip>;
export type ForgotPasswordDTO = z.infer<typeof forgotPasswordSchema>;
export declare const resetPasswordSchema: z.ZodObject<{
    token: z.ZodString;
    password: z.ZodString;
}, z.core.$strip>;
export type ResetPasswordDTO = z.infer<typeof resetPasswordSchema>;
//# sourceMappingURL=auth.dto.d.ts.map
</file>

<file path="server/dist/dto/auth.dto.d.ts.map">
{"version":3,"file":"auth.dto.d.ts","sourceRoot":"","sources":["../../src/dto/auth.dto.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAExB,eAAO,MAAM,cAAc;;;;iBAIzB,CAAC;AAEH,MAAM,MAAM,WAAW,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,cAAc,CAAC,CAAC;AAEzD,eAAO,MAAM,WAAW;;;iBAGtB,CAAC;AAEH,MAAM,MAAM,QAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,WAAW,CAAC,CAAC;AAGnD,eAAO,MAAM,wBAAwB;;iBAEnC,CAAC;AACH,MAAM,MAAM,qBAAqB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,wBAAwB,CAAC,CAAC;AAG7E,eAAO,MAAM,oBAAoB;;iBAE/B,CAAC;AACH,MAAM,MAAM,iBAAiB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,oBAAoB,CAAC,CAAC;AAGrE,eAAO,MAAM,mBAAmB;;;iBAG9B,CAAC;AACH,MAAM,MAAM,gBAAgB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,mBAAmB,CAAC,CAAC"}
</file>

<file path="server/dist/dto/auth.dto.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetPasswordSchema = exports.forgotPasswordSchema = exports.resendVerificationSchema = exports.loginSchema = exports.registerSchema = void 0;
const zod_1 = require("zod");
exports.registerSchema = zod_1.z.object({
    name: zod_1.z.string().min(2, "Name must be at least 2 characters"),
    email: zod_1.z.string().email({ message: "Invalid email address" }),
    password: zod_1.z.string().min(6, "Password must be at least 6 characters"),
});
exports.loginSchema = zod_1.z.object({
    email: zod_1.z.string().email({ message: "Invalid email address" }),
    password: zod_1.z.string().min(6, "Password must be at least 6 characters"),
});
exports.resendVerificationSchema = zod_1.z.object({
    email: zod_1.z.string().email({ message: "Invalid email address" }),
});
exports.forgotPasswordSchema = zod_1.z.object({
    email: zod_1.z.string().email({ message: "Invalid email address" }),
});
exports.resetPasswordSchema = zod_1.z.object({
    token: zod_1.z.string().min(10, "Invalid token"),
    password: zod_1.z.string().min(6, "Password must be at least 6 characters"),
});
//# sourceMappingURL=auth.dto.js.map
</file>

<file path="server/dist/dto/auth.dto.js.map">
{"version":3,"file":"auth.dto.js","sourceRoot":"","sources":["../../src/dto/auth.dto.ts"],"names":[],"mappings":";;;AAAA,6BAAwB;AAEX,QAAA,cAAc,GAAG,OAAC,CAAC,MAAM,CAAC;IACrC,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,oCAAoC,CAAC;IAC7D,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,uBAAuB,EAAE,CAAC;IAC7D,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,wCAAwC,CAAC;CACtE,CAAC,CAAC;AAIU,QAAA,WAAW,GAAG,OAAC,CAAC,MAAM,CAAC;IAClC,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,uBAAuB,EAAE,CAAC;IAC7D,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,wCAAwC,CAAC;CACtE,CAAC,CAAC;AAKU,QAAA,wBAAwB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC/C,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,uBAAuB,EAAE,CAAC;CAC9D,CAAC,CAAC;AAIU,QAAA,oBAAoB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC3C,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,uBAAuB,EAAE,CAAC;CAC9D,CAAC,CAAC;AAIU,QAAA,mBAAmB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC1C,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,eAAe,CAAC;IAC1C,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,wCAAwC,CAAC;CACtE,CAAC,CAAC"}
</file>

<file path="server/dist/dto/conversation.dto.d.ts">
import { z } from "zod";
export declare const createPrivateConversationSchema: z.ZodObject<{
    participantId: z.ZodString;
}, z.core.$strip>;
export declare const getOrCreateConversationSchema: z.ZodObject<{
    friendId: z.ZodString;
}, z.core.$strip>;
export type CreatePrivateConversationDTO = z.infer<typeof createPrivateConversationSchema>;
export declare const archiveConversationSchema: z.ZodObject<{
    conversationId: z.ZodString;
}, z.core.$strip>;
export type ArchiveConversationDTO = z.infer<typeof archiveConversationSchema>;
export declare const unarchiveConversationSchema: z.ZodObject<{
    conversationId: z.ZodString;
}, z.core.$strip>;
export type UnarchiveConversationDTO = z.infer<typeof unarchiveConversationSchema>;
export declare const deleteConversationSchema: z.ZodObject<{
    conversationId: z.ZodString;
}, z.core.$strip>;
export type DeleteConversationDTO = z.infer<typeof deleteConversationSchema>;
export declare const createGroupConversationSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    avatar: z.ZodOptional<z.ZodString>;
    memberIds: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
export type CreateGroupConversationDTO = z.infer<typeof createGroupConversationSchema>;
export declare const updateGroupConversationSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    description: z.ZodOptional<z.ZodString>;
    avatar: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type UpdateGroupConversationDTO = z.infer<typeof updateGroupConversationSchema>;
export declare const addMemberSchema: z.ZodObject<{
    memberId: z.ZodString;
}, z.core.$strip>;
export type AddMemberDTO = z.infer<typeof addMemberSchema>;
export declare const updateMemberRoleSchema: z.ZodObject<{
    memberId: z.ZodString;
    role: z.ZodEnum<{
        ADMIN: "ADMIN";
        MODERATOR: "MODERATOR";
        MEMBER: "MEMBER";
    }>;
}, z.core.$strip>;
export type UpdateMemberRoleDTO = z.infer<typeof updateMemberRoleSchema>;
export declare const updateConversationSettingsSchema: z.ZodObject<{
    isArchived: z.ZodOptional<z.ZodBoolean>;
    isMuted: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
export type UpdateConversationSettingsDTO = z.infer<typeof updateConversationSettingsSchema>;
export declare const getConversationsQuerySchema: z.ZodObject<{
    type: z.ZodDefault<z.ZodEnum<{
        PRIVATE: "PRIVATE";
        GROUP: "GROUP";
        ALL: "ALL";
    }>>;
    limit: z.ZodPipe<z.ZodDefault<z.ZodString>, z.ZodTransform<number, string>>;
    page: z.ZodPipe<z.ZodDefault<z.ZodString>, z.ZodTransform<number, string>>;
    archived: z.ZodDefault<z.ZodEnum<{
        true: "true";
        false: "false";
    }>>;
    search: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export declare const getUserConversationsQuerySchema: z.ZodObject<{
    limit: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
    page: z.ZodOptional<z.ZodCoercedNumber<unknown>>;
    search: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type GetConversationsQueryDTO = z.infer<typeof getConversationsQuerySchema>;
export declare const conversationIdSchema: z.ZodObject<{
    conversationId: z.ZodString;
}, z.core.$strip>;
export declare const getConversationSchema: z.ZodObject<{
    conversationId: z.ZodString;
}, z.core.$strip>;
export type ConversationIdDTO = z.infer<typeof conversationIdSchema>;
//# sourceMappingURL=conversation.dto.d.ts.map
</file>

<file path="server/dist/dto/conversation.dto.d.ts.map">
{"version":3,"file":"conversation.dto.d.ts","sourceRoot":"","sources":["../../src/dto/conversation.dto.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAKxB,eAAO,MAAM,+BAA+B;;iBAE1C,CAAC;AAEH,eAAO,MAAM,6BAA6B;;iBAExC,CAAC;AAEH,MAAM,MAAM,4BAA4B,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,+BAA+B,CAAC,CAAC;AAK3F,eAAO,MAAM,yBAAyB;;iBAEpC,CAAC;AAEH,MAAM,MAAM,sBAAsB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,yBAAyB,CAAC,CAAC;AAK/E,eAAO,MAAM,2BAA2B;;iBAEtC,CAAC;AAEH,MAAM,MAAM,wBAAwB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,2BAA2B,CAAC,CAAC;AAKnF,eAAO,MAAM,wBAAwB;;iBAEnC,CAAC;AAEH,MAAM,MAAM,qBAAqB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,wBAAwB,CAAC,CAAC;AAK7E,eAAO,MAAM,6BAA6B;;;;;iBAKxC,CAAC;AAEH,MAAM,MAAM,0BAA0B,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,6BAA6B,CAAC,CAAC;AAKvF,eAAO,MAAM,6BAA6B;;;;iBAIxC,CAAC;AAEH,MAAM,MAAM,0BAA0B,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,6BAA6B,CAAC,CAAC;AAKvF,eAAO,MAAM,eAAe;;iBAE1B,CAAC;AAEH,MAAM,MAAM,YAAY,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,eAAe,CAAC,CAAC;AAK3D,eAAO,MAAM,sBAAsB;;;;;;;iBAGjC,CAAC;AAEH,MAAM,MAAM,mBAAmB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,sBAAsB,CAAC,CAAC;AAKzE,eAAO,MAAM,gCAAgC;;;iBAG3C,CAAC;AAEH,MAAM,MAAM,6BAA6B,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,gCAAgC,CAAC,CAAC;AAK7F,eAAO,MAAM,2BAA2B;;;;;;;;;;;;;iBAMtC,CAAC;AAEH,eAAO,MAAM,+BAA+B;;;;iBAI1C,CAAC;AAEH,MAAM,MAAM,wBAAwB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,2BAA2B,CAAC,CAAC;AAKnF,eAAO,MAAM,oBAAoB;;iBAE/B,CAAC;AAEH,eAAO,MAAM,qBAAqB;;iBAEhC,CAAC;AAEH,MAAM,MAAM,iBAAiB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,oBAAoB,CAAC,CAAC"}
</file>

<file path="server/dist/dto/conversation.dto.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConversationSchema = exports.conversationIdSchema = exports.getUserConversationsQuerySchema = exports.getConversationsQuerySchema = exports.updateConversationSettingsSchema = exports.updateMemberRoleSchema = exports.addMemberSchema = exports.updateGroupConversationSchema = exports.createGroupConversationSchema = exports.deleteConversationSchema = exports.unarchiveConversationSchema = exports.archiveConversationSchema = exports.getOrCreateConversationSchema = exports.createPrivateConversationSchema = void 0;
const zod_1 = require("zod");
exports.createPrivateConversationSchema = zod_1.z.object({
    participantId: zod_1.z.string().cuid("Invalid participant ID"),
});
exports.getOrCreateConversationSchema = zod_1.z.object({
    friendId: zod_1.z.string().cuid("Invalid friend ID"),
});
exports.archiveConversationSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
});
exports.unarchiveConversationSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
});
exports.deleteConversationSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
});
exports.createGroupConversationSchema = zod_1.z.object({
    name: zod_1.z.string().min(1, "Group name is required").max(100, "Group name too long"),
    description: zod_1.z.string().max(500, "Description too long").optional(),
    avatar: zod_1.z.string().url("Invalid avatar URL").optional(),
    memberIds: zod_1.z.array(zod_1.z.string().cuid()).min(2, "At least 2 members required"),
});
exports.updateGroupConversationSchema = zod_1.z.object({
    name: zod_1.z.string().min(1).max(100).optional(),
    description: zod_1.z.string().max(500).optional(),
    avatar: zod_1.z.string().url().optional(),
});
exports.addMemberSchema = zod_1.z.object({
    memberId: zod_1.z.string().cuid("Invalid member ID"),
});
exports.updateMemberRoleSchema = zod_1.z.object({
    memberId: zod_1.z.string().cuid("Invalid member ID"),
    role: zod_1.z.enum(["ADMIN", "MODERATOR", "MEMBER"]),
});
exports.updateConversationSettingsSchema = zod_1.z.object({
    isArchived: zod_1.z.boolean().optional(),
    isMuted: zod_1.z.boolean().optional(),
});
exports.getConversationsQuerySchema = zod_1.z.object({
    type: zod_1.z.enum(["PRIVATE", "GROUP", "ALL"]).default("ALL"),
    limit: zod_1.z.string().default("20").transform(Number),
    page: zod_1.z.string().default("1").transform(Number),
    archived: zod_1.z.enum(["true", "false"]).default("false"),
    search: zod_1.z.string().optional(),
});
exports.getUserConversationsQuerySchema = zod_1.z.object({
    limit: zod_1.z.coerce.number().optional(),
    page: zod_1.z.coerce.number().optional(),
    search: zod_1.z.string().optional(),
});
exports.conversationIdSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
});
exports.getConversationSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
});
//# sourceMappingURL=conversation.dto.js.map
</file>

<file path="server/dist/dto/conversation.dto.js.map">
{"version":3,"file":"conversation.dto.js","sourceRoot":"","sources":["../../src/dto/conversation.dto.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/dto/friend.dto.d.ts">
import { z } from "zod";
export declare const sendFriendRequestSchema: z.ZodObject<{
    receiverId: z.ZodString;
}, z.core.$strip>;
export type SendFriendRequestDTO = z.infer<typeof sendFriendRequestSchema>;
export declare const friendRequestIdSchema: z.ZodObject<{
    requestId: z.ZodString;
}, z.core.$strip>;
export type FriendRequestIdDTO = z.infer<typeof friendRequestIdSchema>;
export declare const removeFriendSchema: z.ZodObject<{
    friendId: z.ZodString;
}, z.core.$strip>;
export type RemoveFriendDTO = z.infer<typeof removeFriendSchema>;
export declare const getFriendRequestsQuerySchema: z.ZodObject<{
    type: z.ZodDefault<z.ZodEnum<{
        pending: "pending";
        sent: "sent";
    }>>;
    limit: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    page: z.ZodDefault<z.ZodOptional<z.ZodString>>;
}, z.core.$strip>;
export type GetFriendRequestsQueryDTO = z.infer<typeof getFriendRequestsQuerySchema>;
export declare const getFriendsQuerySchema: z.ZodObject<{
    limit: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    page: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    search: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type GetFriendsQueryDTO = z.infer<typeof getFriendsQuerySchema>;
//# sourceMappingURL=friend.dto.d.ts.map
</file>

<file path="server/dist/dto/friend.dto.d.ts.map">
{"version":3,"file":"friend.dto.d.ts","sourceRoot":"","sources":["../../src/dto/friend.dto.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAMxB,eAAO,MAAM,uBAAuB;;iBAElC,CAAC;AAEH,MAAM,MAAM,oBAAoB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,uBAAuB,CAAC,CAAC;AAM3E,eAAO,MAAM,qBAAqB;;iBAEhC,CAAC;AAEH,MAAM,MAAM,kBAAkB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,qBAAqB,CAAC,CAAC;AAMvE,eAAO,MAAM,kBAAkB;;iBAE7B,CAAC;AAEH,MAAM,MAAM,eAAe,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,kBAAkB,CAAC,CAAC;AAMjE,eAAO,MAAM,4BAA4B;;;;;;;iBAIvC,CAAC;AAEH,MAAM,MAAM,yBAAyB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,4BAA4B,CAAC,CAAC;AAMrF,eAAO,MAAM,qBAAqB;;;;iBAIhC,CAAC;AAEH,MAAM,MAAM,kBAAkB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,qBAAqB,CAAC,CAAC"}
</file>

<file path="server/dist/dto/friend.dto.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFriendsQuerySchema = exports.getFriendRequestsQuerySchema = exports.removeFriendSchema = exports.friendRequestIdSchema = exports.sendFriendRequestSchema = void 0;
const zod_1 = require("zod");
exports.sendFriendRequestSchema = zod_1.z.object({
    receiverId: zod_1.z.string().min(1, "Receiver ID is required"),
});
exports.friendRequestIdSchema = zod_1.z.object({
    requestId: zod_1.z.string().min(1, "Request ID is required"),
});
exports.removeFriendSchema = zod_1.z.object({
    friendId: zod_1.z.string().min(1, "Friend ID is required"),
});
exports.getFriendRequestsQuerySchema = zod_1.z.object({
    type: zod_1.z.enum(["pending", "sent"]).default("pending"),
    limit: zod_1.z.string().optional().default("10"),
    page: zod_1.z.string().optional().default("1"),
});
exports.getFriendsQuerySchema = zod_1.z.object({
    limit: zod_1.z.string().optional().default("10"),
    page: zod_1.z.string().optional().default("1"),
    search: zod_1.z.string().optional(),
});
//# sourceMappingURL=friend.dto.js.map
</file>

<file path="server/dist/dto/friend.dto.js.map">
{"version":3,"file":"friend.dto.js","sourceRoot":"","sources":["../../src/dto/friend.dto.ts"],"names":[],"mappings":";;;AAAA,6BAAwB;AAMX,QAAA,uBAAuB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC9C,UAAU,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,yBAAyB,CAAC;CACzD,CAAC,CAAC;AAQU,QAAA,qBAAqB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC5C,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,wBAAwB,CAAC;CACvD,CAAC,CAAC;AAQU,QAAA,kBAAkB,GAAG,OAAC,CAAC,MAAM,CAAC;IACzC,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,uBAAuB,CAAC;CACrD,CAAC,CAAC;AAQU,QAAA,4BAA4B,GAAG,OAAC,CAAC,MAAM,CAAC;IACnD,IAAI,EAAE,OAAC,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC;IACpD,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC;IAC1C,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC;CACzC,CAAC,CAAC;AAQU,QAAA,qBAAqB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC5C,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC;IAC1C,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC;IACxC,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;CAC9B,CAAC,CAAC"}
</file>

<file path="server/dist/dto/message.dto.d.ts">
import { z } from "zod";
export declare const sendMessageSchema: z.ZodObject<{
    conversationId: z.ZodString;
    content: z.ZodString;
    type: z.ZodDefault<z.ZodEnum<{
        TEXT: "TEXT";
        IMAGE: "IMAGE";
        VIDEO: "VIDEO";
        FILE: "FILE";
        SYSTEM_MESSAGE: "SYSTEM_MESSAGE";
    }>>;
    mediaUrls: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
export type SendMessageDTO = z.infer<typeof sendMessageSchema>;
export declare const editMessageSchema: z.ZodObject<{
    messageId: z.ZodString;
    newContent: z.ZodString;
}, z.core.$strip>;
export type EditMessageDTO = z.infer<typeof editMessageSchema>;
export declare const deleteMessageSchema: z.ZodObject<{
    messageId: z.ZodString;
}, z.core.$strip>;
export type DeleteMessageDTO = z.infer<typeof deleteMessageSchema>;
export declare const markAsReadSchema: z.ZodObject<{
    conversationId: z.ZodString;
}, z.core.$strip>;
export type MarkAsReadDTO = z.infer<typeof markAsReadSchema>;
export declare const reactToMessageSchema: z.ZodObject<{
    messageId: z.ZodString;
    emoji: z.ZodString;
}, z.core.$strip>;
export type ReactToMessageDTO = z.infer<typeof reactToMessageSchema>;
export declare const removeReactionSchema: z.ZodObject<{
    messageId: z.ZodString;
    emoji: z.ZodString;
}, z.core.$strip>;
export type RemoveReactionDTO = z.infer<typeof removeReactionSchema>;
export declare const getMessagesQuerySchema: z.ZodObject<{
    limit: z.ZodPipe<z.ZodDefault<z.ZodString>, z.ZodTransform<number, string>>;
    page: z.ZodPipe<z.ZodDefault<z.ZodString>, z.ZodTransform<number, string>>;
    fromDate: z.ZodOptional<z.ZodString>;
    toDate: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type GetMessagesQueryDTO = z.infer<typeof getMessagesQuerySchema>;
export declare const markMessageReadSchema: z.ZodObject<{
    messageIds: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
export type MarkMessageReadDTO = z.infer<typeof markMessageReadSchema>;
export declare const messageIdSchema: z.ZodObject<{
    messageId: z.ZodString;
}, z.core.$strip>;
export type MessageIdDTO = z.infer<typeof messageIdSchema>;
//# sourceMappingURL=message.dto.d.ts.map
</file>

<file path="server/dist/dto/message.dto.d.ts.map">
{"version":3,"file":"message.dto.d.ts","sourceRoot":"","sources":["../../src/dto/message.dto.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAKxB,eAAO,MAAM,iBAAiB;;;;;;;;;;;iBAK5B,CAAC;AAEH,MAAM,MAAM,cAAc,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,iBAAiB,CAAC,CAAC;AAK/D,eAAO,MAAM,iBAAiB;;;iBAG5B,CAAC;AAEH,MAAM,MAAM,cAAc,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,iBAAiB,CAAC,CAAC;AAK/D,eAAO,MAAM,mBAAmB;;iBAE9B,CAAC;AAEH,MAAM,MAAM,gBAAgB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,mBAAmB,CAAC,CAAC;AAKnE,eAAO,MAAM,gBAAgB;;iBAE3B,CAAC;AAEH,MAAM,MAAM,aAAa,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,gBAAgB,CAAC,CAAC;AAK7D,eAAO,MAAM,oBAAoB;;;iBAG/B,CAAC;AAEH,MAAM,MAAM,iBAAiB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,oBAAoB,CAAC,CAAC;AAKrE,eAAO,MAAM,oBAAoB;;;iBAG/B,CAAC;AAEH,MAAM,MAAM,iBAAiB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,oBAAoB,CAAC,CAAC;AAKrE,eAAO,MAAM,sBAAsB;;;;;iBAKjC,CAAC;AAEH,MAAM,MAAM,mBAAmB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,sBAAsB,CAAC,CAAC;AAKzE,eAAO,MAAM,qBAAqB;;iBAEhC,CAAC;AAEH,MAAM,MAAM,kBAAkB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,qBAAqB,CAAC,CAAC;AAKvE,eAAO,MAAM,eAAe;;iBAE1B,CAAC;AAEH,MAAM,MAAM,YAAY,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,eAAe,CAAC,CAAC"}
</file>

<file path="server/dist/dto/message.dto.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.messageIdSchema = exports.markMessageReadSchema = exports.getMessagesQuerySchema = exports.removeReactionSchema = exports.reactToMessageSchema = exports.markAsReadSchema = exports.deleteMessageSchema = exports.editMessageSchema = exports.sendMessageSchema = void 0;
const zod_1 = require("zod");
exports.sendMessageSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
    content: zod_1.z.string().min(1, "Message cannot be empty").max(5000, "Message too long"),
    type: zod_1.z.enum(["TEXT", "IMAGE", "VIDEO", "FILE", "SYSTEM_MESSAGE"]).default("TEXT"),
    mediaUrls: zod_1.z.array(zod_1.z.string().url()).optional(),
});
exports.editMessageSchema = zod_1.z.object({
    messageId: zod_1.z.string().cuid("Invalid message ID"),
    newContent: zod_1.z.string().min(1, "Message cannot be empty").max(5000, "Message too long"),
});
exports.deleteMessageSchema = zod_1.z.object({
    messageId: zod_1.z.string().cuid("Invalid message ID"),
});
exports.markAsReadSchema = zod_1.z.object({
    conversationId: zod_1.z.string().cuid("Invalid conversation ID"),
});
exports.reactToMessageSchema = zod_1.z.object({
    messageId: zod_1.z.string().cuid("Invalid message ID"),
    emoji: zod_1.z.string().emoji("Must be a valid emoji"),
});
exports.removeReactionSchema = zod_1.z.object({
    messageId: zod_1.z.string().cuid("Invalid message ID"),
    emoji: zod_1.z.string().emoji("Must be a valid emoji"),
});
exports.getMessagesQuerySchema = zod_1.z.object({
    limit: zod_1.z.string().default("50").transform(Number),
    page: zod_1.z.string().default("1").transform(Number),
    fromDate: zod_1.z.string().datetime().optional(),
    toDate: zod_1.z.string().datetime().optional(),
});
exports.markMessageReadSchema = zod_1.z.object({
    messageIds: zod_1.z.array(zod_1.z.string().cuid()).min(1, "At least one message ID required"),
});
exports.messageIdSchema = zod_1.z.object({
    messageId: zod_1.z.string().cuid("Invalid message ID"),
});
//# sourceMappingURL=message.dto.js.map
</file>

<file path="server/dist/dto/message.dto.js.map">
{"version":3,"file":"message.dto.js","sourceRoot":"","sources":["../../src/dto/message.dto.ts"],"names":[],"mappings":";;;AAAA,6BAAwB;AAKX,QAAA,iBAAiB,GAAG,OAAC,CAAC,MAAM,CAAC;IACxC,cAAc,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,yBAAyB,CAAC;IAC1D,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,kBAAkB,CAAC;IACnF,IAAI,EAAE,OAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC;IAClF,SAAS,EAAE,OAAC,CAAC,KAAK,CAAC,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,QAAQ,EAAE;CAChD,CAAC,CAAC;AAOU,QAAA,iBAAiB,GAAG,OAAC,CAAC,MAAM,CAAC;IACxC,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC;IAChD,UAAU,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,kBAAkB,CAAC;CACvF,CAAC,CAAC;AAOU,QAAA,mBAAmB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC1C,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC;CACjD,CAAC,CAAC;AAOU,QAAA,gBAAgB,GAAG,OAAC,CAAC,MAAM,CAAC;IACvC,cAAc,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,yBAAyB,CAAC;CAC3D,CAAC,CAAC;AAOU,QAAA,oBAAoB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC3C,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC;IAChD,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,uBAAuB,CAAC;CACjD,CAAC,CAAC;AAOU,QAAA,oBAAoB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC3C,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC;IAChD,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,uBAAuB,CAAC;CACjD,CAAC,CAAC;AAOU,QAAA,sBAAsB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC7C,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC;IACjD,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/C,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE;IAC1C,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE;CACzC,CAAC,CAAC;AAOU,QAAA,qBAAqB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC5C,UAAU,EAAE,OAAC,CAAC,KAAK,CAAC,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,kCAAkC,CAAC;CAClF,CAAC,CAAC;AAOU,QAAA,eAAe,GAAG,OAAC,CAAC,MAAM,CAAC;IACtC,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC;CACjD,CAAC,CAAC"}
</file>

<file path="server/dist/dto/user.dto.d.ts">
import { z } from "zod";
export declare const updateProfileSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    bio: z.ZodOptional<z.ZodString>;
    status: z.ZodOptional<z.ZodEnum<{
        offline: "offline";
        online: "online";
        away: "away";
    }>>;
}, z.core.$strip>;
export type UpdateProfileDTO = z.infer<typeof updateProfileSchema>;
export declare const searchUsersSchema: z.ZodObject<{
    query: z.ZodString;
    limit: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type SearchUsersDTO = z.infer<typeof searchUsersSchema>;
//# sourceMappingURL=user.dto.d.ts.map
</file>

<file path="server/dist/dto/user.dto.d.ts.map">
{"version":3,"file":"user.dto.d.ts","sourceRoot":"","sources":["../../src/dto/user.dto.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAExB,eAAO,MAAM,mBAAmB;;;;;;;;iBAI9B,CAAC;AAEH,MAAM,MAAM,gBAAgB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,mBAAmB,CAAC,CAAC;AAEnE,eAAO,MAAM,iBAAiB;;;iBAG5B,CAAC;AAEH,MAAM,MAAM,cAAc,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,iBAAiB,CAAC,CAAC"}
</file>

<file path="server/dist/dto/user.dto.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchUsersSchema = exports.updateProfileSchema = void 0;
const zod_1 = require("zod");
exports.updateProfileSchema = zod_1.z.object({
    name: zod_1.z.string().min(2).max(50).optional(),
    bio: zod_1.z.string().max(200).optional(),
    status: zod_1.z.enum(["online", "offline", "away"]).optional(),
});
exports.searchUsersSchema = zod_1.z.object({
    query: zod_1.z.string().min(1),
    limit: zod_1.z.string().optional(),
});
//# sourceMappingURL=user.dto.js.map
</file>

<file path="server/dist/dto/user.dto.js.map">
{"version":3,"file":"user.dto.js","sourceRoot":"","sources":["../../src/dto/user.dto.ts"],"names":[],"mappings":";;;AAAA,6BAAwB;AAEX,QAAA,mBAAmB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC1C,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,QAAQ,EAAE;IAC1C,GAAG,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE;IACnC,MAAM,EAAE,OAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC,QAAQ,EAAE;CACzD,CAAC,CAAC;AAIU,QAAA,iBAAiB,GAAG,OAAC,CAAC,MAAM,CAAC;IACxC,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IACxB,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;CAC7B,CAAC,CAAC"}
</file>

<file path="server/dist/middleware/auth.middleware.d.ts">
import { Request, Response, NextFunction } from "express";
declare global {
    namespace Express {
        interface User {
            userId?: string;
            email?: string;
            role?: string;
        }
    }
}
export declare const authenticate: (req: Request, res: Response, next: NextFunction) => void;
export declare const optionalAuthenticate: (req: Request, res: Response, next: NextFunction) => void;
export declare const isAuthenticated: (req: Request) => boolean;
export declare const authorize: (...allowedRoles: string[]) => (req: Request, res: Response, next: NextFunction) => void;
//# sourceMappingURL=auth.middleware.d.ts.map
</file>

<file path="server/dist/middleware/auth.middleware.d.ts.map">
{"version":3,"file":"auth.middleware.d.ts","sourceRoot":"","sources":["../../src/middleware/auth.middleware.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAO1D,OAAO,CAAC,MAAM,CAAC;IACb,UAAU,OAAO,CAAC;QAChB,UAAU,IAAI;YACZ,MAAM,CAAC,EAAE,MAAM,CAAC;YAChB,KAAK,CAAC,EAAE,MAAM,CAAC;YACf,IAAI,CAAC,EAAE,MAAM,CAAC;SACf;KACF;CACF;AAKD,eAAO,MAAM,YAAY,GACvB,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,MAAM,YAAY,KACjB,IA+BF,CAAC;AAKF,eAAO,MAAM,oBAAoB,GAC/B,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,MAAM,YAAY,KACjB,IAoBF,CAAC;AAKF,eAAO,MAAM,eAAe,GAAI,KAAK,OAAO,KAAG,OAE9C,CAAC;AAKF,eAAO,MAAM,SAAS,GAAI,GAAG,cAAc,MAAM,EAAE,MACzC,KAAK,OAAO,EAAE,KAAK,QAAQ,EAAE,MAAM,YAAY,KAAG,IAqB3D,CAAC"}
</file>

<file path="server/dist/middleware/auth.middleware.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.authorize = exports.isAuthenticated = exports.optionalAuthenticate = exports.authenticate = void 0;
const jwt_util_1 = require("../utils/jwt.util");
const error_types_1 = require("../types/error.types");
const authenticate = (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        console.log("üîç Auth Header:", authHeader);
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
            throw new error_types_1.AuthenticationError("No token provided");
        }
        const token = authHeader.slice(7);
        console.log("üîç Token:", token);
        const decoded = (0, jwt_util_1.verifyAccessToken)(token);
        console.log("üîç Decoded:", decoded);
        req.user = {
            userId: decoded.userId,
            email: decoded.email,
            role: decoded.role || "USER",
        };
        next();
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("‚ùå Auth Error:", errorMessage);
        res.status(401).json({
            success: false,
            message: "Unauthorized",
            error: errorMessage,
        });
    }
};
exports.authenticate = authenticate;
const optionalAuthenticate = (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith("Bearer ")) {
            const token = authHeader.slice(7);
            const decoded = (0, jwt_util_1.verifyAccessToken)(token);
            req.user = {
                userId: decoded.userId,
                email: decoded.email,
                role: decoded.role || "USER",
            };
        }
        next();
    }
    catch (error) {
        next();
    }
};
exports.optionalAuthenticate = optionalAuthenticate;
const isAuthenticated = (req) => {
    return !!(req.user && req.user.userId);
};
exports.isAuthenticated = isAuthenticated;
const authorize = (...allowedRoles) => {
    return (req, res, next) => {
        if (!req.user) {
            res.status(401).json({
                success: false,
                message: "Not authenticated",
            });
            return;
        }
        if (!allowedRoles.includes(req.user.role || "USER")) {
            res.status(403).json({
                success: false,
                message: "Insufficient permissions. Required roles: " +
                    allowedRoles.join(", "),
            });
            return;
        }
        next();
    };
};
exports.authorize = authorize;
//# sourceMappingURL=auth.middleware.js.map
</file>

<file path="server/dist/middleware/auth.middleware.js.map">
{"version":3,"file":"auth.middleware.js","sourceRoot":"","sources":["../../src/middleware/auth.middleware.ts"],"names":[],"mappings":";;;AACA,gDAAsD;AACtD,sDAA2D;AAkBpD,MAAM,YAAY,GAAG,CAC1B,GAAY,EACZ,GAAa,EACb,IAAkB,EACZ,EAAE;IACR,IAAI,CAAC;QACH,MAAM,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC;QAC7C,OAAO,CAAC,GAAG,CAAC,iBAAiB,EAAE,UAAU,CAAC,CAAC;QAE3C,IAAI,CAAC,UAAU,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC;YACrD,MAAM,IAAI,iCAAmB,CAAC,mBAAmB,CAAC,CAAC;QACrD,CAAC;QAED,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAClC,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QAEhC,MAAM,OAAO,GAAG,IAAA,4BAAiB,EAAC,KAAK,CAAC,CAAC;QACzC,OAAO,CAAC,GAAG,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QAEpC,GAAG,CAAC,IAAI,GAAG;YACT,MAAM,EAAE,OAAO,CAAC,MAAM;YACtB,KAAK,EAAE,OAAO,CAAC,KAAK;YACpB,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,MAAM;SAC7B,CAAC;QAEF,IAAI,EAAE,CAAC;IACT,CAAC;IAAC,OAAO,KAAc,EAAE,CAAC;QACxB,MAAM,YAAY,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC5E,OAAO,CAAC,KAAK,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;QAC7C,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;YACnB,OAAO,EAAE,KAAK;YACd,OAAO,EAAE,cAAc;YACvB,KAAK,EAAE,YAAY;SACpB,CAAC,CAAC;IACL,CAAC;AACH,CAAC,CAAC;AAnCW,QAAA,YAAY,gBAmCvB;AAKK,MAAM,oBAAoB,GAAG,CAClC,GAAY,EACZ,GAAa,EACb,IAAkB,EACZ,EAAE;IACR,IAAI,CAAC;QACH,MAAM,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC;QAE7C,IAAI,UAAU,IAAI,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC;YACnD,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAClC,MAAM,OAAO,GAAG,IAAA,4BAAiB,EAAC,KAAK,CAAC,CAAC;YAEzC,GAAG,CAAC,IAAI,GAAG;gBACT,MAAM,EAAE,OAAO,CAAC,MAAM;gBACtB,KAAK,EAAE,OAAO,CAAC,KAAK;gBACpB,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,MAAM;aAC7B,CAAC;QACJ,CAAC;QAED,IAAI,EAAE,CAAC;IACT,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QAEf,IAAI,EAAE,CAAC;IACT,CAAC;AACH,CAAC,CAAC;AAxBW,QAAA,oBAAoB,wBAwB/B;AAKK,MAAM,eAAe,GAAG,CAAC,GAAY,EAAW,EAAE;IACvD,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACzC,CAAC,CAAC;AAFW,QAAA,eAAe,mBAE1B;AAKK,MAAM,SAAS,GAAG,CAAC,GAAG,YAAsB,EAAE,EAAE;IACrD,OAAO,CAAC,GAAY,EAAE,GAAa,EAAE,IAAkB,EAAQ,EAAE;QAC/D,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;YACd,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;gBACnB,OAAO,EAAE,KAAK;gBACd,OAAO,EAAE,mBAAmB;aAC7B,CAAC,CAAC;YACH,OAAO;QACT,CAAC;QAED,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC,EAAE,CAAC;YACpD,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;gBACnB,OAAO,EAAE,KAAK;gBACd,OAAO,EACL,4CAA4C;oBAC5C,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;aAC1B,CAAC,CAAC;YACH,OAAO;QACT,CAAC;QAED,IAAI,EAAE,CAAC;IACT,CAAC,CAAC;AACJ,CAAC,CAAC;AAtBW,QAAA,SAAS,aAsBpB"}
</file>

<file path="server/dist/middleware/error.middleware.d.ts">
import { Request, Response, NextFunction } from "express";
import { AppError } from "../types/error.types";
export declare const errorHandler: (error: Error | AppError, req: Request, res: Response, next: NextFunction) => Response<any, Record<string, any>>;
export declare const notFound: (req: Request, res: Response, next: NextFunction) => void;
export declare const asyncHandler: (fn: Function) => (req: Request, res: Response, next: NextFunction) => void;
//# sourceMappingURL=error.middleware.d.ts.map
</file>

<file path="server/dist/middleware/error.middleware.d.ts.map">
{"version":3,"file":"error.middleware.d.ts","sourceRoot":"","sources":["../../src/middleware/error.middleware.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAC1D,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAC;AAoGhD,eAAO,MAAM,YAAY,GACvB,OAAO,KAAK,GAAG,QAAQ,EACvB,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,MAAM,YAAY,uCA0DnB,CAAC;AAKF,eAAO,MAAM,QAAQ,GAAI,KAAK,OAAO,EAAE,KAAK,QAAQ,EAAE,MAAM,YAAY,SAGvE,CAAC;AAKF,eAAO,MAAM,YAAY,GAAI,IAAI,QAAQ,MAC/B,KAAK,OAAO,EAAE,KAAK,QAAQ,EAAE,MAAM,YAAY,SAGxD,CAAC"}
</file>

<file path="server/dist/middleware/error.middleware.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncHandler = exports.notFound = exports.errorHandler = void 0;
const error_types_1 = require("../types/error.types");
const zod_1 = require("zod");
const handlePrismaError = (error) => {
    if (typeof error !== 'object' || error === null) {
        return {
            success: false,
            message: "Database operation failed",
            statusCode: 500,
        };
    }
    const prismaError = error;
    if (prismaError.code) {
        switch (prismaError.code) {
            case "P2002":
                const field = prismaError.meta?.target?.join(", ") || "field";
                return {
                    success: false,
                    message: `${field} already exists`,
                    statusCode: 409,
                };
            case "P2025":
                return {
                    success: false,
                    message: "Record not found",
                    statusCode: 404,
                };
            case "P2003":
                return {
                    success: false,
                    message: "Related record not found",
                    statusCode: 400,
                };
            case "P2014":
                return {
                    success: false,
                    message: "Invalid ID provided",
                    statusCode: 400,
                };
            default:
                return {
                    success: false,
                    message: "Database operation failed",
                    statusCode: 500,
                };
        }
    }
    return {
        success: false,
        message: "Database operation failed",
        statusCode: 500,
    };
};
const handleZodError = (error) => {
    const errors = error.issues.map((issue) => ({
        field: issue.path.join("."),
        message: issue.message,
    }));
    return {
        success: false,
        message: "Validation failed",
        statusCode: 400,
        errors,
    };
};
const errorHandler = (error, req, res, next) => {
    console.error("‚ùå Error:", error);
    let response = {
        success: false,
        message: error.message || "Internal server error",
        statusCode: 500,
    };
    if (error instanceof error_types_1.AppError) {
        response = {
            success: false,
            message: error.message,
            statusCode: error.statusCode,
        };
    }
    else if ((error instanceof Error && error.name === "PrismaClientKnownRequestError") ||
        (typeof error === 'object' && error !== null && 'code' in error)) {
        response = handlePrismaError(error);
    }
    else if (error instanceof zod_1.ZodError) {
        response = handleZodError(error);
    }
    else if (error.name === "JsonWebTokenError") {
        response = {
            success: false,
            message: "Invalid token",
            statusCode: 401,
        };
    }
    else if (error.name === "TokenExpiredError") {
        response = {
            success: false,
            message: "Token expired",
            statusCode: 401,
        };
    }
    else if (error.name === "MulterError") {
        response = {
            success: false,
            message: `File upload error: ${error.message}`,
            statusCode: 400,
        };
    }
    if (process.env.NODE_ENV === "development") {
        response.stack = error.stack;
    }
    return res.status(response.statusCode).json(response);
};
exports.errorHandler = errorHandler;
const notFound = (req, res, next) => {
    const error = new error_types_1.AppError(`Route ${req.originalUrl} not found`, 404);
    next(error);
};
exports.notFound = notFound;
const asyncHandler = (fn) => {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
};
exports.asyncHandler = asyncHandler;
//# sourceMappingURL=error.middleware.js.map
</file>

<file path="server/dist/middleware/error.middleware.js.map">
{"version":3,"file":"error.middleware.js","sourceRoot":"","sources":["../../src/middleware/error.middleware.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/middleware/upload.middleware.d.ts">
import multer from "multer";
export declare const upload: multer.Multer;
//# sourceMappingURL=upload.middleware.d.ts.map
</file>

<file path="server/dist/middleware/upload.middleware.d.ts.map">
{"version":3,"file":"upload.middleware.d.ts","sourceRoot":"","sources":["../../src/middleware/upload.middleware.ts"],"names":[],"mappings":"AAAA,OAAO,MAAM,MAAM,QAAQ,CAAC;AAkB5B,eAAO,MAAM,MAAM,eAIjB,CAAC"}
</file>

<file path="server/dist/middleware/upload.middleware.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upload = void 0;
const multer_1 = __importDefault(require("multer"));
const storage = multer_1.default.memoryStorage();
const fileFilter = (req, file, cb) => {
    if (file.mimetype.startsWith("image/")) {
        cb(null, true);
    }
    else {
        cb(null, false);
    }
};
exports.upload = (0, multer_1.default)({
    storage,
    fileFilter,
    limits: { fileSize: 5 * 1024 * 1024 },
});
//# sourceMappingURL=upload.middleware.js.map
</file>

<file path="server/dist/middleware/upload.middleware.js.map">
{"version":3,"file":"upload.middleware.js","sourceRoot":"","sources":["../../src/middleware/upload.middleware.ts"],"names":[],"mappings":";;;;;;AAAA,oDAA4B;AAG5B,MAAM,OAAO,GAAG,gBAAM,CAAC,aAAa,EAAE,CAAC;AAGvC,MAAM,UAAU,GAAG,CACjB,GAAoB,EACpB,IAAyB,EACzB,EAA6B,EAC7B,EAAE;IACF,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC;QACvC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACjB,CAAC;SAAM,CAAC;QACN,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAClB,CAAC;AACH,CAAC,CAAC;AAEW,QAAA,MAAM,GAAG,IAAA,gBAAM,EAAC;IAC3B,OAAO;IACP,UAAU;IACV,MAAM,EAAE,EAAE,QAAQ,EAAE,CAAC,GAAG,IAAI,GAAG,IAAI,EAAE;CACtC,CAAC,CAAC"}
</file>

<file path="server/dist/middleware/validate.middleware.d.ts">
import { Request, Response, NextFunction } from "express";
import { ZodType } from "zod";
export declare const validate: (schema: ZodType) => (req: Request, res: Response, next: NextFunction) => Promise<void>;
export declare const validateQuery: (schema: ZodType) => (req: Request, res: Response, next: NextFunction) => Promise<void>;
export declare const validateParams: (schema: ZodType) => (req: Request, res: Response, next: NextFunction) => Promise<void>;
//# sourceMappingURL=validate.middleware.d.ts.map
</file>

<file path="server/dist/middleware/validate.middleware.d.ts.map">
{"version":3,"file":"validate.middleware.d.ts","sourceRoot":"","sources":["../../src/middleware/validate.middleware.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAC1D,OAAO,EAAE,OAAO,EAAY,MAAM,KAAK,CAAC;AAKxC,eAAO,MAAM,QAAQ,GAAI,QAAQ,OAAO,MAEpC,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,MAAM,YAAY,KACjB,OAAO,CAAC,IAAI,CAgChB,CAAC;AAKF,eAAO,MAAM,aAAa,GAAI,QAAQ,OAAO,MAEzC,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,MAAM,YAAY,KACjB,OAAO,CAAC,IAAI,CA0BhB,CAAC;AAKF,eAAO,MAAM,cAAc,GAAI,QAAQ,OAAO,MAE1C,KAAK,OAAO,EACZ,KAAK,QAAQ,EACb,MAAM,YAAY,KACjB,OAAO,CAAC,IAAI,CA0BhB,CAAC"}
</file>

<file path="server/dist/middleware/validate.middleware.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateParams = exports.validateQuery = exports.validate = void 0;
const zod_1 = require("zod");
const validate = (schema) => {
    return async (req, res, next) => {
        try {
            const validatedData = await schema.parseAsync(req.body);
            req.body = validatedData;
            next();
        }
        catch (error) {
            if (error instanceof zod_1.ZodError) {
                const errors = error.issues.map((issue) => ({
                    field: issue.path.join("."),
                    message: issue.message,
                }));
                res.status(400).json({
                    success: false,
                    message: "Validation failed",
                    errors,
                });
                return;
            }
            res.status(500).json({
                success: false,
                message: "Internal server error during validation",
            });
        }
    };
};
exports.validate = validate;
const validateQuery = (schema) => {
    return async (req, res, next) => {
        try {
            const validatedData = await schema.parseAsync(req.query);
            req.query = validatedData;
            next();
        }
        catch (error) {
            if (error instanceof zod_1.ZodError) {
                const errors = error.issues.map((issue) => ({
                    field: issue.path.join("."),
                    message: issue.message,
                }));
                res.status(400).json({
                    success: false,
                    message: "Query validation failed",
                    errors,
                });
                return;
            }
            res.status(500).json({
                success: false,
                message: "Internal server error during validation",
            });
        }
    };
};
exports.validateQuery = validateQuery;
const validateParams = (schema) => {
    return async (req, res, next) => {
        try {
            const validatedData = await schema.parseAsync(req.params);
            req.params = validatedData;
            next();
        }
        catch (error) {
            if (error instanceof zod_1.ZodError) {
                const errors = error.issues.map((issue) => ({
                    field: issue.path.join("."),
                    message: issue.message,
                }));
                res.status(400).json({
                    success: false,
                    message: "Params validation failed",
                    errors,
                });
                return;
            }
            res.status(500).json({
                success: false,
                message: "Internal server error during validation",
            });
        }
    };
};
exports.validateParams = validateParams;
//# sourceMappingURL=validate.middleware.js.map
</file>

<file path="server/dist/middleware/validate.middleware.js.map">
{"version":3,"file":"validate.middleware.js","sourceRoot":"","sources":["../../src/middleware/validate.middleware.ts"],"names":[],"mappings":";;;AACA,6BAAwC;AAKjC,MAAM,QAAQ,GAAG,CAAC,MAAe,EAAE,EAAE;IAC1C,OAAO,KAAK,EACV,GAAY,EACZ,GAAa,EACb,IAAkB,EACH,EAAE;QACjB,IAAI,CAAC;YAEH,MAAM,aAAa,GAAG,MAAM,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAGxD,GAAG,CAAC,IAAI,GAAG,aAAa,CAAC;YAEzB,IAAI,EAAE,CAAC;QACT,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,YAAY,cAAQ,EAAE,CAAC;gBAE9B,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;oBAC1C,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;oBAC3B,OAAO,EAAE,KAAK,CAAC,OAAO;iBACvB,CAAC,CAAC,CAAC;gBAEJ,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;oBACnB,OAAO,EAAE,KAAK;oBACd,OAAO,EAAE,mBAAmB;oBAC5B,MAAM;iBACP,CAAC,CAAC;gBACH,OAAO;YACT,CAAC;YAGD,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;gBACnB,OAAO,EAAE,KAAK;gBACd,OAAO,EAAE,yCAAyC;aACnD,CAAC,CAAC;QACL,CAAC;IACH,CAAC,CAAC;AACJ,CAAC,CAAC;AArCW,QAAA,QAAQ,YAqCnB;AAKK,MAAM,aAAa,GAAG,CAAC,MAAe,EAAE,EAAE;IAC/C,OAAO,KAAK,EACV,GAAY,EACZ,GAAa,EACb,IAAkB,EACH,EAAE;QACjB,IAAI,CAAC;YACH,MAAM,aAAa,GAAG,MAAM,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACzD,GAAG,CAAC,KAAK,GAAG,aAAoC,CAAC;YACjD,IAAI,EAAE,CAAC;QACT,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,YAAY,cAAQ,EAAE,CAAC;gBAC9B,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;oBAC1C,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;oBAC3B,OAAO,EAAE,KAAK,CAAC,OAAO;iBACvB,CAAC,CAAC,CAAC;gBAEJ,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;oBACnB,OAAO,EAAE,KAAK;oBACd,OAAO,EAAE,yBAAyB;oBAClC,MAAM;iBACP,CAAC,CAAC;gBACH,OAAO;YACT,CAAC;YAED,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;gBACnB,OAAO,EAAE,KAAK;gBACd,OAAO,EAAE,yCAAyC;aACnD,CAAC,CAAC;QACL,CAAC;IACH,CAAC,CAAC;AACJ,CAAC,CAAC;AA/BW,QAAA,aAAa,iBA+BxB;AAKK,MAAM,cAAc,GAAG,CAAC,MAAe,EAAE,EAAE;IAChD,OAAO,KAAK,EACV,GAAY,EACZ,GAAa,EACb,IAAkB,EACH,EAAE;QACjB,IAAI,CAAC;YACH,MAAM,aAAa,GAAG,MAAM,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAC1D,GAAG,CAAC,MAAM,GAAG,aAAoC,CAAC;YAClD,IAAI,EAAE,CAAC;QACT,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,YAAY,cAAQ,EAAE,CAAC;gBAC9B,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;oBAC1C,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;oBAC3B,OAAO,EAAE,KAAK,CAAC,OAAO;iBACvB,CAAC,CAAC,CAAC;gBAEJ,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;oBACnB,OAAO,EAAE,KAAK;oBACd,OAAO,EAAE,0BAA0B;oBACnC,MAAM;iBACP,CAAC,CAAC;gBACH,OAAO;YACT,CAAC;YAED,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;gBACnB,OAAO,EAAE,KAAK;gBACd,OAAO,EAAE,yCAAyC;aACnD,CAAC,CAAC;QACL,CAAC;IACH,CAAC,CAAC;AACJ,CAAC,CAAC;AA/BW,QAAA,cAAc,kBA+BzB"}
</file>

<file path="server/dist/routes/auth.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=auth.route.d.ts.map
</file>

<file path="server/dist/routes/auth.route.d.ts.map">
{"version":3,"file":"auth.route.d.ts","sourceRoot":"","sources":["../../src/routes/auth.route.ts"],"names":[],"mappings":"AAaA,QAAA,MAAM,MAAM,4CAAW,CAAC;AAkBxB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/auth.route.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const auth_controller_1 = require("../controllers/auth.controller");
const auth_middleware_1 = require("../middleware/auth.middleware");
const router = (0, express_1.Router)();
router.post("/register", auth_controller_1.register);
router.post("/login", auth_controller_1.login);
router.get("/verify-email", auth_controller_1.verifyEmail);
router.post("/resend-verification", auth_controller_1.resendVerification);
router.post("/forgot-password", auth_controller_1.forgotPassword);
router.post("/reset-password", auth_controller_1.resetPassword);
router.post("/refresh-tokens", auth_controller_1.refreshTokens);
router.post("/logout", auth_middleware_1.authenticate, auth_controller_1.logout);
exports.default = router;
//# sourceMappingURL=auth.route.js.map
</file>

<file path="server/dist/routes/auth.route.js.map">
{"version":3,"file":"auth.route.js","sourceRoot":"","sources":["../../src/routes/auth.route.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AACjC,oEASwC;AACxC,mEAA6D;AAE7D,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAKxB,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,0BAAQ,CAAC,CAAC;AACnC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,uBAAK,CAAC,CAAC;AAC7B,MAAM,CAAC,GAAG,CAAC,eAAe,EAAE,6BAAW,CAAC,CAAC;AACzC,MAAM,CAAC,IAAI,CAAC,sBAAsB,EAAE,oCAAkB,CAAC,CAAC;AACxD,MAAM,CAAC,IAAI,CAAC,kBAAkB,EAAE,gCAAc,CAAC,CAAC;AAChD,MAAM,CAAC,IAAI,CAAC,iBAAiB,EAAE,+BAAa,CAAC,CAAC;AAC9C,MAAM,CAAC,IAAI,CAAC,iBAAiB,EAAE,+BAAa,CAAC,CAAC;AAK9C,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,8BAAY,EAAE,wBAAM,CAAC,CAAC;AAE7C,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/call.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=call.route.d.ts.map
</file>

<file path="server/dist/routes/call.route.d.ts.map">
{"version":3,"file":"call.route.d.ts","sourceRoot":"","sources":["../../src/routes/call.route.ts"],"names":[],"mappings":"AAYA,QAAA,MAAM,MAAM,4CAAW,CAAC;AA2BxB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/call.route.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const auth_middleware_1 = require("../middleware/auth.middleware");
const call_controller_1 = require("../controllers/call.controller");
const router = (0, express_1.Router)();
router.post("/", auth_middleware_1.authenticate, call_controller_1.initiateCall);
router.patch("/status", auth_middleware_1.authenticate, call_controller_1.updateCallStatus);
router.patch("/end", auth_middleware_1.authenticate, call_controller_1.endCall);
router.patch("/decline", auth_middleware_1.authenticate, call_controller_1.declineCall);
router.patch("/miss", auth_middleware_1.authenticate, call_controller_1.missCall);
router.get("/:conversationId/history", auth_middleware_1.authenticate, call_controller_1.getCallHistory);
router.get("/:conversationId", auth_middleware_1.authenticate, call_controller_1.getActiveCall);
exports.default = router;
//# sourceMappingURL=call.route.js.map
</file>

<file path="server/dist/routes/call.route.js.map">
{"version":3,"file":"call.route.js","sourceRoot":"","sources":["../../src/routes/call.route.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AACjC,mEAA6D;AAC7D,oEAQwC;AAExC,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAOxB,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,8BAAY,EAAE,8BAAY,CAAC,CAAC;AAG7C,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,8BAAY,EAAE,kCAAgB,CAAC,CAAC;AAGxD,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,8BAAY,EAAE,yBAAO,CAAC,CAAC;AAG5C,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,8BAAY,EAAE,6BAAW,CAAC,CAAC;AAGpD,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,8BAAY,EAAE,0BAAQ,CAAC,CAAC;AAG9C,MAAM,CAAC,GAAG,CAAC,0BAA0B,EAAE,8BAAY,EAAE,gCAAc,CAAC,CAAC;AAGrE,MAAM,CAAC,GAAG,CAAC,kBAAkB,EAAE,8BAAY,EAAE,+BAAa,CAAC,CAAC;AAE5D,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/conversation.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=conversation.route.d.ts.map
</file>

<file path="server/dist/routes/conversation.route.d.ts.map">
{"version":3,"file":"conversation.route.d.ts","sourceRoot":"","sources":["../../src/routes/conversation.route.ts"],"names":[],"mappings":"AAYA,QAAA,MAAM,MAAM,4CAAW,CAAC;AA2BxB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/conversation.route.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const auth_middleware_1 = require("../middleware/auth.middleware");
const conversation_controller_1 = require("../controllers/conversation.controller");
const router = (0, express_1.Router)();
router.post("/", auth_middleware_1.authenticate, conversation_controller_1.getOrCreateConversation);
router.get("/", auth_middleware_1.authenticate, conversation_controller_1.getUserConversations);
router.patch("/archive", auth_middleware_1.authenticate, conversation_controller_1.archiveConversation);
router.patch("/unarchive", auth_middleware_1.authenticate, conversation_controller_1.unarchiveConversation);
router.delete("/", auth_middleware_1.authenticate, conversation_controller_1.deleteConversation);
router.get("/:conversationId/user", auth_middleware_1.authenticate, conversation_controller_1.getOtherUser);
router.get("/:conversationId", auth_middleware_1.authenticate, conversation_controller_1.getConversation);
exports.default = router;
//# sourceMappingURL=conversation.route.js.map
</file>

<file path="server/dist/routes/conversation.route.js.map">
{"version":3,"file":"conversation.route.js","sourceRoot":"","sources":["../../src/routes/conversation.route.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AACjC,mEAA6D;AAC7D,oFAQgD;AAEhD,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAOxB,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,8BAAY,EAAE,iDAAuB,CAAC,CAAC;AAGxD,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,8BAAY,EAAE,8CAAoB,CAAC,CAAC;AAGpD,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,8BAAY,EAAE,6CAAmB,CAAC,CAAC;AAG5D,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,8BAAY,EAAE,+CAAqB,CAAC,CAAC;AAGhE,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,8BAAY,EAAE,4CAAkB,CAAC,CAAC;AAGrD,MAAM,CAAC,GAAG,CAAC,uBAAuB,EAAE,8BAAY,EAAE,sCAAY,CAAC,CAAC;AAGhE,MAAM,CAAC,GAAG,CAAC,kBAAkB,EAAE,8BAAY,EAAE,yCAAe,CAAC,CAAC;AAE9D,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/friend.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=friend.route.d.ts.map
</file>

<file path="server/dist/routes/friend.route.d.ts.map">
{"version":3,"file":"friend.route.d.ts","sourceRoot":"","sources":["../../src/routes/friend.route.ts"],"names":[],"mappings":"AAYA,QAAA,MAAM,MAAM,4CAAW,CAAC;AAqBxB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/friend.route.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const auth_middleware_1 = require("../middleware/auth.middleware");
const friend_controller_1 = require("../controllers/friend.controller");
const router = (0, express_1.Router)();
router.post("/request", auth_middleware_1.authenticate, friend_controller_1.sendFriendRequestHandler);
router.patch("/request/:requestId/accept", auth_middleware_1.authenticate, friend_controller_1.acceptFriendRequestHandler);
router.patch("/request/:requestId/reject", auth_middleware_1.authenticate, friend_controller_1.rejectFriendRequestHandler);
router.delete("/request/:requestId", auth_middleware_1.authenticate, friend_controller_1.cancelFriendRequestHandler);
router.get("/requests", auth_middleware_1.authenticate, friend_controller_1.getFriendRequestsHandler);
router.get("/", auth_middleware_1.authenticate, friend_controller_1.getFriendsHandler);
router.delete("/:friendId", auth_middleware_1.authenticate, friend_controller_1.removeFriendHandler);
exports.default = router;
//# sourceMappingURL=friend.route.js.map
</file>

<file path="server/dist/routes/friend.route.js.map">
{"version":3,"file":"friend.route.js","sourceRoot":"","sources":["../../src/routes/friend.route.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AACjC,mEAA6D;AAC7D,wEAQ0C;AAE1C,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAOxB,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,8BAAY,EAAE,4CAAwB,CAAC,CAAC;AAChE,MAAM,CAAC,KAAK,CAAC,4BAA4B,EAAE,8BAAY,EAAE,8CAA0B,CAAC,CAAC;AACrF,MAAM,CAAC,KAAK,CAAC,4BAA4B,EAAE,8BAAY,EAAE,8CAA0B,CAAC,CAAC;AACrF,MAAM,CAAC,MAAM,CAAC,qBAAqB,EAAE,8BAAY,EAAE,8CAA0B,CAAC,CAAC;AAG/E,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,8BAAY,EAAE,4CAAwB,CAAC,CAAC;AAGhE,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,8BAAY,EAAE,qCAAiB,CAAC,CAAC;AAGjD,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,8BAAY,EAAE,uCAAmB,CAAC,CAAC;AAE/D,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/google-auth.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=google-auth.route.d.ts.map
</file>

<file path="server/dist/routes/google-auth.route.d.ts.map">
{"version":3,"file":"google-auth.route.d.ts","sourceRoot":"","sources":["../../src/routes/google-auth.route.ts"],"names":[],"mappings":"AAOA,QAAA,MAAM,MAAM,4CAAW,CAAC;AAuDxB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/google-auth.route.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const passport_1 = __importDefault(require("passport"));
const google_auth_controller_1 = require("../controllers/google-auth.controller");
const router = (0, express_1.Router)();
router.get("/google", passport_1.default.authenticate("google", {
    scope: ["email", "profile"],
    accessType: "offline",
    prompt: "consent",
}));
router.get("/google/callback", passport_1.default.authenticate("google", {
    failureRedirect: "/api/v1/auth/error",
    session: true,
}), google_auth_controller_1.googleCallback);
exports.default = router;
//# sourceMappingURL=google-auth.route.js.map
</file>

<file path="server/dist/routes/google-auth.route.js.map">
{"version":3,"file":"google-auth.route.js","sourceRoot":"","sources":["../../src/routes/google-auth.route.ts"],"names":[],"mappings":";;;;;AAAA,qCAAiC;AACjC,wDAAgC;AAChC,kFAG+C;AAE/C,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAqBxB,MAAM,CAAC,GAAG,CACR,SAAS,EACT,kBAAQ,CAAC,YAAY,CAAC,QAAQ,EAAE;IAC9B,KAAK,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC;IAC3B,UAAU,EAAE,SAAS;IACrB,MAAM,EAAE,SAAS;CAClB,CAAC,CACH,CAAC;AAkBF,MAAM,CAAC,GAAG,CACR,kBAAkB,EAClB,kBAAQ,CAAC,YAAY,CAAC,QAAQ,EAAE;IAC9B,eAAe,EAAE,oBAAoB;IACrC,OAAO,EAAE,IAAI;CACd,CAAC,EACF,uCAAc,CACf,CAAC;AAEF,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/message.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=message.route.d.ts.map
</file>

<file path="server/dist/routes/message.route.d.ts.map">
{"version":3,"file":"message.route.d.ts","sourceRoot":"","sources":["../../src/routes/message.route.ts"],"names":[],"mappings":"AAeA,QAAA,MAAM,MAAM,4CAAW,CAAC;AAsCxB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/message.route.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const auth_middleware_1 = require("../middleware/auth.middleware");
const message_controller_1 = require("../controllers/message.controller");
const router = (0, express_1.Router)();
router.post("/mark-as-read", auth_middleware_1.authenticate, message_controller_1.markAsRead);
router.patch("/mark-read", auth_middleware_1.authenticate, message_controller_1.markAsRead);
router.get("/search", auth_middleware_1.authenticate, message_controller_1.searchMessages);
router.post("/react", auth_middleware_1.authenticate, message_controller_1.reactToMessage);
router.delete("/react", auth_middleware_1.authenticate, message_controller_1.removeReaction);
router.patch("/edit", auth_middleware_1.authenticate, message_controller_1.editMessage);
router.get("/:messageId/reactions", auth_middleware_1.authenticate, message_controller_1.getReactions);
router.get("/:messageId/read-receipts", auth_middleware_1.authenticate, message_controller_1.getReadReceipts);
router.post("/", auth_middleware_1.authenticate, message_controller_1.sendMessage);
router.delete("/", auth_middleware_1.authenticate, message_controller_1.deleteMessage);
router.get("/:conversationId", auth_middleware_1.authenticate, message_controller_1.getMessages);
exports.default = router;
//# sourceMappingURL=message.route.js.map
</file>

<file path="server/dist/routes/message.route.js.map">
{"version":3,"file":"message.route.js","sourceRoot":"","sources":["../../src/routes/message.route.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AACjC,mEAA6D;AAC7D,0EAW2C;AAE3C,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAQxB,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,8BAAY,EAAE,+BAAU,CAAC,CAAC;AACvD,MAAM,CAAC,KAAK,CAAC,YAAY,EAAE,8BAAY,EAAE,+BAAU,CAAC,CAAC;AAGrD,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,8BAAY,EAAE,mCAAc,CAAC,CAAC;AAGpD,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,8BAAY,EAAE,mCAAc,CAAC,CAAC;AAGpD,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,8BAAY,EAAE,mCAAc,CAAC,CAAC;AAGtD,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,8BAAY,EAAE,gCAAW,CAAC,CAAC;AAGjD,MAAM,CAAC,GAAG,CAAC,uBAAuB,EAAE,8BAAY,EAAE,iCAAY,CAAC,CAAC;AAGhE,MAAM,CAAC,GAAG,CAAC,2BAA2B,EAAE,8BAAY,EAAE,oCAAe,CAAC,CAAC;AAGvE,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,8BAAY,EAAE,gCAAW,CAAC,CAAC;AAG5C,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,8BAAY,EAAE,kCAAa,CAAC,CAAC;AAGhD,MAAM,CAAC,GAAG,CAAC,kBAAkB,EAAE,8BAAY,EAAE,gCAAW,CAAC,CAAC;AAE1D,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/user.route.d.ts">
declare const router: import("express-serve-static-core").Router;
export default router;
//# sourceMappingURL=user.route.d.ts.map
</file>

<file path="server/dist/routes/user.route.d.ts.map">
{"version":3,"file":"user.route.d.ts","sourceRoot":"","sources":["../../src/routes/user.route.ts"],"names":[],"mappings":"AAeA,QAAA,MAAM,MAAM,4CAAW,CAAC;AAmExB,eAAe,MAAM,CAAC"}
</file>

<file path="server/dist/routes/user.route.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const auth_middleware_1 = require("../middleware/auth.middleware");
const auth_middleware_2 = require("../middleware/auth.middleware");
const upload_middleware_1 = require("../middleware/upload.middleware");
const user_controller_1 = require("../controllers/user.controller");
const router = (0, express_1.Router)();
router.get("/profile", auth_middleware_1.authenticate, user_controller_1.getProfile);
router.patch("/profile", auth_middleware_1.authenticate, user_controller_1.updateProfile);
router.post("/avatar", auth_middleware_1.authenticate, upload_middleware_1.upload.single("avatar"), user_controller_1.uploadAvatar);
router.patch("/status", auth_middleware_1.authenticate, user_controller_1.updateStatus);
router.delete("/profile", auth_middleware_1.authenticate, user_controller_1.deleteAccount);
router.get("/search", auth_middleware_1.authenticate, user_controller_1.searchUsersHandler);
router.get("/admin/all", auth_middleware_1.authenticate, (0, auth_middleware_2.authorize)("ADMIN"), user_controller_1.getAllUsersHandler);
router.get("/:id", auth_middleware_1.authenticate, user_controller_1.getUserByIdHandler);
exports.default = router;
//# sourceMappingURL=user.route.js.map
</file>

<file path="server/dist/routes/user.route.js.map">
{"version":3,"file":"user.route.js","sourceRoot":"","sources":["../../src/routes/user.route.ts"],"names":[],"mappings":";;AAAA,qCAAiC;AACjC,mEAA6D;AAC7D,mEAA0D;AAC1D,uEAAyD;AACzD,oEASwC;AAExC,MAAM,MAAM,GAAG,IAAA,gBAAM,GAAE,CAAC;AAYxB,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,8BAAY,EAAE,4BAAU,CAAC,CAAC;AAOjD,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,8BAAY,EAAE,+BAAa,CAAC,CAAC;AAQtD,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,8BAAY,EAAE,0BAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,8BAAY,CAAC,CAAC;AAQ5E,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,8BAAY,EAAE,8BAAY,CAAC,CAAC;AAOpD,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,8BAAY,EAAE,+BAAa,CAAC,CAAC;AAOvD,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,8BAAY,EAAE,oCAAkB,CAAC,CAAC;AASxD,MAAM,CAAC,GAAG,CAAC,YAAY,EAAE,8BAAY,EAAE,IAAA,2BAAS,EAAC,OAAO,CAAC,EAAE,oCAAkB,CAAC,CAAC;AAO/E,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,8BAAY,EAAE,oCAAkB,CAAC,CAAC;AAErD,kBAAe,MAAM,CAAC"}
</file>

<file path="server/dist/server.d.ts">
import http from "http";
import { Server as SocketIOServer } from "socket.io";
import { PrismaClient } from "@prisma/client";
declare const prisma: PrismaClient<import(".prisma/client").Prisma.PrismaClientOptions, never, import("@prisma/client/runtime/library").DefaultArgs>;
declare const server: http.Server<typeof http.IncomingMessage, typeof http.ServerResponse>;
export declare const io: SocketIOServer<import("socket.io").DefaultEventsMap, import("socket.io").DefaultEventsMap, import("socket.io").DefaultEventsMap, any>;
export { server, prisma };
//# sourceMappingURL=server.d.ts.map
</file>

<file path="server/dist/server.d.ts.map">
{"version":3,"file":"server.d.ts","sourceRoot":"","sources":["../src/server.ts"],"names":[],"mappings":"AAAA,OAAO,IAAI,MAAM,MAAM,CAAC;AACxB,OAAO,EAAE,MAAM,IAAI,cAAc,EAAE,MAAM,WAAW,CAAC;AAGrD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAO9C,QAAA,MAAM,MAAM,gIAAqB,CAAC;AAKlC,QAAA,MAAM,MAAM,sEAAyB,CAAC;AAKtC,eAAO,MAAM,EAAE,uIAMb,CAAC;AA0HH,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC"}
</file>

<file path="server/dist/server.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prisma = exports.server = exports.io = void 0;
const http_1 = __importDefault(require("http"));
const socket_io_1 = require("socket.io");
const app_1 = require("./app");
const env_config_1 = require("./config/env.config");
const client_1 = require("@prisma/client");
const chat_socket_1 = require("./socket/chat.socket");
const jwt_util_1 = require("./utils/jwt.util");
const prisma = new client_1.PrismaClient();
exports.prisma = prisma;
const server = http_1.default.createServer(app_1.app);
exports.server = server;
exports.io = new socket_io_1.Server(server, {
    cors: {
        origin: env_config_1.config.CLIENT_URL,
        methods: ["GET", "POST"],
        credentials: true,
    },
});
exports.io.use((socket, next) => {
    try {
        let token = socket.handshake.auth.token;
        if (!token && socket.handshake.headers.authorization) {
            const authHeader = socket.handshake.headers.authorization;
            token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : authHeader;
        }
        if (!token) {
            return next(new Error("No token provided"));
        }
        const decoded = (0, jwt_util_1.verifyAccessToken)(token);
        if (!decoded.userId) {
            return next(new Error("userId not found in token"));
        }
        socket.data.userId = decoded.userId;
        socket.data.email = decoded.email;
        socket.data.role = decoded.role;
        next();
    }
    catch (error) {
        console.error("‚ùå Socket.IO Auth Error:", error.message);
        return next(new Error(`Authentication failed: ${error.message}`));
    }
});
(0, chat_socket_1.setupChatSocket)(exports.io);
const connectDatabase = async () => {
    try {
        await prisma.$connect();
        console.log("‚úÖ Database connected successfully");
        return true;
    }
    catch (error) {
        console.warn("‚ö†Ô∏è  Database connection failed. Running in offline mode.");
        console.warn("   Make sure PostgreSQL is running at localhost:5432");
        return false;
    }
};
const gracefulShutdown = async () => {
    console.log("\nüõë Shutting down gracefully...");
    exports.io.close();
    server.close(() => {
        console.log("‚úÖ HTTP server closed");
    });
    await prisma.$disconnect();
    console.log("‚úÖ Database disconnected");
    process.exit(0);
};
process.on("SIGINT", gracefulShutdown);
process.on("SIGTERM", gracefulShutdown);
process.on("unhandledRejection", (reason, promise) => {
    console.error("‚ùå Unhandled Rejection at:", promise, "reason:", reason);
});
const startServer = async () => {
    try {
        const dbConnected = await connectDatabase();
        server.listen(env_config_1.config.PORT, () => {
            console.log(`üöÄ Server running on http://localhost:${env_config_1.config.PORT} in ${env_config_1.config.NODE_ENV} mode`);
            console.log(`üì° WebSocket server initialized with Socket.IO`);
            if (dbConnected) {
                console.log("‚úÖ Database is connected");
            }
            else {
                console.log("‚ö†Ô∏è  Running without database (offline mode)");
            }
        });
    }
    catch (error) {
        console.error("‚ùå Failed to start server:", error);
        process.exit(1);
    }
};
startServer();
//# sourceMappingURL=server.js.map
</file>

<file path="server/dist/server.js.map">
{"version":3,"file":"server.js","sourceRoot":"","sources":["../src/server.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/services/auth.service.d.ts">
import { RegisterDTO, LoginDTO } from "../dto/auth.dto";
export declare class AuthService {
    register(data: RegisterDTO): Promise<{
        success: boolean;
        message: string;
        data: {
            user: {
                name: string | null;
                id: string;
                email: string;
                role: import(".prisma/client").$Enums.UserRole;
                createdAt: Date;
            };
            verificationToken: string;
        };
    }>;
    login(data: LoginDTO): Promise<{
        success: boolean;
        message: string;
        data: {
            user: {
                id: string;
                name: string | null;
                email: string;
                createdAt: Date;
            };
            accessToken: string;
        };
        refreshToken: string;
    }>;
    verifyEmail(token: string): Promise<{
        success: boolean;
        message: string;
        data: {
            user: {
                name: string | null;
                id: string;
                email: string;
                createdAt: Date;
            };
        };
    }>;
    resendVerification(email: string): Promise<{
        success: boolean;
        message: string;
    }>;
    forgotPassword(email: string): Promise<{
        success: boolean;
        message: string;
    }>;
    resetPassword(token: string, newPassword: string): Promise<{
        success: boolean;
        message: string;
        data: {
            user: {
                name: string | null;
                id: string;
                email: string;
                createdAt: Date;
            };
        };
    }>;
    refreshTokens(refreshToken: string): Promise<{
        success: boolean;
        tokens: import("../utils/jwt.util").AuthTokens;
    }>;
    logout(userId: string): Promise<{
        success: boolean;
        message: string;
    }>;
}
//# sourceMappingURL=auth.service.d.ts.map
</file>

<file path="server/dist/services/auth.service.d.ts.map">
{"version":3,"file":"auth.service.d.ts","sourceRoot":"","sources":["../../src/services/auth.service.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,iBAAiB,CAAC;AAMxD,qBAAa,WAAW;IAChB,QAAQ,CAAC,IAAI,EAAE,WAAW;;;;;;;;;;;;;;IA8D1B,KAAK,CAAC,IAAI,EAAE,QAAQ;;;;;;;;;;;;;;IA8DpB,WAAW,CAAC,KAAK,EAAE,MAAM;;;;;;;;;;;;IA0CzB,kBAAkB,CAAC,KAAK,EAAE,MAAM;;;;IA0BhC,cAAc,CAAC,KAAK,EAAE,MAAM;;;;IA0B5B,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM;;;;;;;;;;;;IAyBhD,aAAa,CAAC,YAAY,EAAE,MAAM;;;;IAmBlC,MAAM,CAAC,MAAM,EAAE,MAAM;;;;CAK5B"}
</file>

<file path="server/dist/services/auth.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const bcrypt_1 = __importDefault(require("bcrypt"));
const db_1 = __importDefault(require("../config/db"));
const jwt_util_1 = require("../utils/jwt.util");
const error_types_1 = require("../types/error.types");
const crypto_1 = __importDefault(require("crypto"));
const email_util_1 = require("../utils/email.util");
class AuthService {
    async register(data) {
        const existingUser = await db_1.default.user.findUnique({
            where: { email: data.email },
        });
        if (existingUser) {
            throw new error_types_1.ConflictError("Email already registered");
        }
        const hashedPassword = await bcrypt_1.default.hash(data.password, parseInt(process.env.BCRYPT_ROUNDS || "10"));
        const user = await db_1.default.user.create({
            data: {
                name: data.name,
                email: data.email,
                password: hashedPassword,
            },
            select: {
                id: true,
                name: true,
                email: true,
                role: true,
                createdAt: true,
            },
        });
        const verificationToken = crypto_1.default.randomBytes(32).toString("hex");
        const verificationTokenHash = crypto_1.default
            .createHash("sha256")
            .update(verificationToken)
            .digest("hex");
        await db_1.default.emailVerification.create({
            data: {
                userId: user.id,
                token: verificationTokenHash,
                expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
            },
        });
        const verificationLink = `${process.env.CLIENT_URL}/verify-email?token=${verificationToken}`;
        await (0, email_util_1.sendVerificationEmail)(user.email, verificationToken, verificationLink, user.name || undefined);
        return {
            success: true,
            message: "User registered successfully. Please verify your email.",
            data: {
                user,
                verificationToken,
            },
        };
    }
    async login(data) {
        const user = await db_1.default.user.findUnique({
            where: { email: data.email },
            select: {
                id: true,
                email: true,
                password: true,
                name: true,
                role: true,
                createdAt: true,
            },
        });
        if (!user) {
            throw new error_types_1.AuthenticationError("Invalid email or password");
        }
        if (!user.password) {
            throw new error_types_1.AuthenticationError("Invalid email or password");
        }
        const isPasswordValid = await bcrypt_1.default.compare(data.password, user.password);
        if (!isPasswordValid) {
            throw new error_types_1.AuthenticationError("Invalid email or password");
        }
        const accessToken = (0, jwt_util_1.generateAccessToken)({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        const refreshToken = (0, jwt_util_1.generateRefreshToken)({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        await db_1.default.user.update({
            where: { id: user.id },
            data: { refreshToken },
        });
        return {
            success: true,
            message: "Login successful",
            data: {
                user: {
                    id: user.id,
                    name: user.name,
                    email: user.email,
                    createdAt: user.createdAt,
                },
                accessToken,
            },
            refreshToken,
        };
    }
    async verifyEmail(token) {
        const tokenHash = crypto_1.default.createHash("sha256").update(token).digest("hex");
        const verification = await db_1.default.emailVerification.findUnique({
            where: { token: tokenHash },
        });
        if (!verification) {
            throw new error_types_1.BadRequestError("Invalid verification token");
        }
        if (verification.expiresAt < new Date()) {
            throw new error_types_1.BadRequestError("Verification token has expired");
        }
        const user = await db_1.default.user.update({
            where: { id: verification.userId },
            data: { emailVerified: true },
            select: {
                id: true,
                name: true,
                email: true,
                createdAt: true,
            },
        });
        await db_1.default.emailVerification.delete({
            where: { id: verification.id },
        });
        return {
            success: true,
            message: "Email verified successfully. You can now login.",
            data: { user },
        };
    }
    async resendVerification(email) {
        const user = await db_1.default.user.findUnique({ where: { email } });
        if (!user)
            throw new error_types_1.NotFoundError("User not found");
        if (user.emailVerified)
            throw new error_types_1.BadRequestError("Email already verified");
        await db_1.default.emailVerification.deleteMany({ where: { userId: user.id } });
        const verificationToken = crypto_1.default.randomBytes(32).toString("hex");
        const verificationTokenHash = crypto_1.default.createHash("sha256").update(verificationToken).digest("hex");
        await db_1.default.emailVerification.create({
            data: {
                userId: user.id,
                token: verificationTokenHash,
                expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
            },
        });
        const verificationLink = `${process.env.CLIENT_URL}/verify-email?token=${verificationToken}`;
        await (0, email_util_1.sendVerificationEmail)(user.email, verificationToken, verificationLink, user.name || undefined);
        return { success: true, message: "Verification email resent" };
    }
    async forgotPassword(email) {
        const user = await db_1.default.user.findUnique({ where: { email } });
        if (!user)
            return { success: true, message: "If that email exists, a reset link has been sent" };
        if (!user.emailVerified)
            throw new error_types_1.BadRequestError("Email is not verified");
        await db_1.default.passwordReset.deleteMany({ where: { userId: user.id } });
        const resetToken = crypto_1.default.randomBytes(32).toString("hex");
        const resetTokenHash = crypto_1.default.createHash("sha256").update(resetToken).digest("hex");
        await db_1.default.passwordReset.create({
            data: {
                userId: user.id,
                token: resetTokenHash,
                expiresAt: new Date(Date.now() + 60 * 60 * 1000),
            },
        });
        const resetLink = `${process.env.CLIENT_URL}/reset-password?token=${resetToken}`;
        await (0, email_util_1.sendPasswordResetEmail)(user.email, resetToken, resetLink, user.name || undefined);
        return { success: true, message: "If that email exists, a reset link has been sent" };
    }
    async resetPassword(token, newPassword) {
        const tokenHash = crypto_1.default.createHash("sha256").update(token).digest("hex");
        const reset = await db_1.default.passwordReset.findUnique({ where: { token: tokenHash } });
        if (!reset)
            throw new error_types_1.BadRequestError("Invalid or expired reset token");
        if (reset.expiresAt < new Date())
            throw new error_types_1.BadRequestError("Reset token has expired");
        const hashed = await bcrypt_1.default.hash(newPassword, parseInt(process.env.BCRYPT_ROUNDS || "10"));
        const user = await db_1.default.user.update({
            where: { id: reset.userId },
            data: { password: hashed, refreshToken: null },
            select: { id: true, name: true, email: true, createdAt: true },
        });
        await db_1.default.passwordReset.deleteMany({ where: { userId: reset.userId } });
        await (0, email_util_1.sendWelcomeEmail)(user.email, user.name || user.email.split("@")[0]);
        return { success: true, message: "Password has been reset. Please login with your new password.", data: { user } };
    }
    async refreshTokens(refreshToken) {
        if (!refreshToken)
            throw new error_types_1.AuthenticationError("Refresh token missing");
        const decoded = (0, jwt_util_1.verifyRefreshToken)(refreshToken);
        const dbUser = await db_1.default.user.findUnique({ where: { id: decoded.userId } });
        if (!dbUser || !dbUser.refreshToken)
            throw new error_types_1.AuthenticationError("Invalid session");
        if (dbUser.refreshToken !== refreshToken)
            throw new error_types_1.AuthenticationError("Invalid refresh token");
        const tokens = (0, jwt_util_1.generateAuthTokens)({ userId: decoded.userId, email: decoded.email });
        await db_1.default.user.update({ where: { id: decoded.userId }, data: { refreshToken: tokens.refreshToken } });
        return { success: true, tokens };
    }
    async logout(userId) {
        await db_1.default.user.update({ where: { id: userId }, data: { refreshToken: null } });
        return { success: true, message: "Logged out" };
    }
}
exports.AuthService = AuthService;
//# sourceMappingURL=auth.service.js.map
</file>

<file path="server/dist/services/auth.service.js.map">
{"version":3,"file":"auth.service.js","sourceRoot":"","sources":["../../src/services/auth.service.ts"],"names":[],"mappings":";;;;;;AAAA,oDAA4B;AAC5B,sDAAkC;AAElC,gDAAsH;AACtH,sDAA0G;AAC1G,oDAA4B;AAC5B,oDAAsG;AAEtG,MAAa,WAAW;IACtB,KAAK,CAAC,QAAQ,CAAC,IAAiB;QAE9B,MAAM,YAAY,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAChD,KAAK,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE;SAC7B,CAAC,CAAC;QAEH,IAAI,YAAY,EAAE,CAAC;YACjB,MAAM,IAAI,2BAAa,CAAC,0BAA0B,CAAC,CAAC;QACtD,CAAC;QAGD,MAAM,cAAc,GAAG,MAAM,gBAAM,CAAC,IAAI,CACtC,IAAI,CAAC,QAAQ,EACb,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,IAAI,CAAC,CAC5C,CAAC;QAGF,MAAM,IAAI,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACpC,IAAI,EAAE;gBACJ,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,QAAQ,EAAE,cAAc;aACzB;YACD,MAAM,EAAE;gBACN,EAAE,EAAE,IAAI;gBACR,IAAI,EAAE,IAAI;gBACV,KAAK,EAAE,IAAI;gBACX,IAAI,EAAE,IAAI;gBACV,SAAS,EAAE,IAAI;aAChB;SACF,CAAC,CAAC;QAGH,MAAM,iBAAiB,GAAG,gBAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACjE,MAAM,qBAAqB,GAAG,gBAAM;aACjC,UAAU,CAAC,QAAQ,CAAC;aACpB,MAAM,CAAC,iBAAiB,CAAC;aACzB,MAAM,CAAC,KAAK,CAAC,CAAC;QAGjB,MAAM,YAAM,CAAC,iBAAiB,CAAC,MAAM,CAAC;YACpC,IAAI,EAAE;gBACJ,MAAM,EAAE,IAAI,CAAC,EAAE;gBACf,KAAK,EAAE,qBAAqB;gBAC5B,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;aACtD;SACF,CAAC,CAAC;QAGH,MAAM,gBAAgB,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,uBAAuB,iBAAiB,EAAE,CAAC;QAC7F,MAAM,IAAA,kCAAqB,EAAC,IAAI,CAAC,KAAK,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC;QAErG,OAAO;YACL,OAAO,EAAE,IAAI;YACb,OAAO,EAAE,yDAAyD;YAClE,IAAI,EAAE;gBACJ,IAAI;gBACJ,iBAAiB;aAClB;SACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,IAAc;QAExB,MAAM,IAAI,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACxC,KAAK,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE;YAC5B,MAAM,EAAE;gBACN,EAAE,EAAE,IAAI;gBACR,KAAK,EAAE,IAAI;gBACX,QAAQ,EAAE,IAAI;gBACd,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,SAAS,EAAE,IAAI;aAChB;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,IAAI,iCAAmB,CAAC,2BAA2B,CAAC,CAAC;QAC7D,CAAC;QAGD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,MAAM,IAAI,iCAAmB,CAAC,2BAA2B,CAAC,CAAC;QAC7D,CAAC;QACD,MAAM,eAAe,GAAG,MAAM,gBAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE3E,IAAI,CAAC,eAAe,EAAE,CAAC;YACrB,MAAM,IAAI,iCAAmB,CAAC,2BAA2B,CAAC,CAAC;QAC7D,CAAC;QAGD,MAAM,WAAW,GAAG,IAAA,8BAAmB,EAAC;YACtC,MAAM,EAAE,IAAI,CAAC,EAAE;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB,CAAC,CAAC;QACH,MAAM,YAAY,GAAG,IAAA,+BAAoB,EAAC;YACxC,MAAM,EAAE,IAAI,CAAC,EAAE;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB,CAAC,CAAC;QAGH,MAAM,YAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACvB,KAAK,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE;YACtB,IAAI,EAAE,EAAE,YAAY,EAAE;SACvB,CAAC,CAAC;QAEH,OAAO;YACL,OAAO,EAAE,IAAI;YACb,OAAO,EAAE,kBAAkB;YAC3B,IAAI,EAAE;gBACJ,IAAI,EAAE;oBACJ,EAAE,EAAE,IAAI,CAAC,EAAE;oBACX,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,KAAK,EAAE,IAAI,CAAC,KAAK;oBACjB,SAAS,EAAE,IAAI,CAAC,SAAS;iBAC1B;gBACD,WAAW;aACZ;YACD,YAAY;SACb,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,KAAa;QAE7B,MAAM,SAAS,GAAG,gBAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAG1E,MAAM,YAAY,GAAG,MAAM,YAAM,CAAC,iBAAiB,CAAC,UAAU,CAAC;YAC7D,KAAK,EAAE,EAAE,KAAK,EAAE,SAAS,EAAE;SAC5B,CAAC,CAAC;QAEH,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,MAAM,IAAI,6BAAe,CAAC,4BAA4B,CAAC,CAAC;QAC1D,CAAC;QAGD,IAAI,YAAY,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,EAAE,CAAC;YACxC,MAAM,IAAI,6BAAe,CAAC,gCAAgC,CAAC,CAAC;QAC9D,CAAC;QAGD,MAAM,IAAI,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACpC,KAAK,EAAE,EAAE,EAAE,EAAE,YAAY,CAAC,MAAM,EAAE;YAClC,IAAI,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE;YAC7B,MAAM,EAAE;gBACN,EAAE,EAAE,IAAI;gBACR,IAAI,EAAE,IAAI;gBACV,KAAK,EAAE,IAAI;gBACX,SAAS,EAAE,IAAI;aAChB;SACF,CAAC,CAAC;QAGH,MAAM,YAAM,CAAC,iBAAiB,CAAC,MAAM,CAAC;YACpC,KAAK,EAAE,EAAE,EAAE,EAAE,YAAY,CAAC,EAAE,EAAE;SAC/B,CAAC,CAAC;QAEH,OAAO;YACL,OAAO,EAAE,IAAI;YACb,OAAO,EAAE,iDAAiD;YAC1D,IAAI,EAAE,EAAE,IAAI,EAAE;SACf,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,KAAa;QACpC,MAAM,IAAI,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAChE,IAAI,CAAC,IAAI;YAAE,MAAM,IAAI,2BAAa,CAAC,gBAAgB,CAAC,CAAC;QACrD,IAAI,IAAI,CAAC,aAAa;YAAE,MAAM,IAAI,6BAAe,CAAC,wBAAwB,CAAC,CAAC;QAG5E,MAAM,YAAM,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAG1E,MAAM,iBAAiB,GAAG,gBAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACjE,MAAM,qBAAqB,GAAG,gBAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAElG,MAAM,YAAM,CAAC,iBAAiB,CAAC,MAAM,CAAC;YACpC,IAAI,EAAE;gBACJ,MAAM,EAAE,IAAI,CAAC,EAAE;gBACf,KAAK,EAAE,qBAAqB;gBAC5B,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;aACtD;SACF,CAAC,CAAC;QAEH,MAAM,gBAAgB,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,uBAAuB,iBAAiB,EAAE,CAAC;QAC7F,MAAM,IAAA,kCAAqB,EAAC,IAAI,CAAC,KAAK,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC;QAErG,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,2BAA2B,EAAE,CAAC;IACjE,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,KAAa;QAChC,MAAM,IAAI,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAEhE,IAAI,CAAC,IAAI;YAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,kDAAkD,EAAE,CAAC;QACjG,IAAI,CAAC,IAAI,CAAC,aAAa;YAAE,MAAM,IAAI,6BAAe,CAAC,uBAAuB,CAAC,CAAC;QAG5E,MAAM,YAAM,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAEtE,MAAM,UAAU,GAAG,gBAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC1D,MAAM,cAAc,GAAG,gBAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEpF,MAAM,YAAM,CAAC,aAAa,CAAC,MAAM,CAAC;YAChC,IAAI,EAAE;gBACJ,MAAM,EAAE,IAAI,CAAC,EAAE;gBACf,KAAK,EAAE,cAAc;gBACrB,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;aACjD;SACF,CAAC,CAAC;QAEH,MAAM,SAAS,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,yBAAyB,UAAU,EAAE,CAAC;QACjF,MAAM,IAAA,mCAAsB,EAAC,IAAI,CAAC,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC;QAExF,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,kDAAkD,EAAE,CAAC;IACxF,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,KAAa,EAAE,WAAmB;QACpD,MAAM,SAAS,GAAG,gBAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAE1E,MAAM,KAAK,GAAG,MAAM,YAAM,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;QACrF,IAAI,CAAC,KAAK;YAAE,MAAM,IAAI,6BAAe,CAAC,gCAAgC,CAAC,CAAC;QACxE,IAAI,KAAK,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE;YAAE,MAAM,IAAI,6BAAe,CAAC,yBAAyB,CAAC,CAAC;QAEvF,MAAM,MAAM,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,IAAI,CAAC,CAAC,CAAC;QAG3F,MAAM,IAAI,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACpC,KAAK,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE;YAC3B,IAAI,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE;YAC9C,MAAM,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE;SAC/D,CAAC,CAAC;QAGH,MAAM,YAAM,CAAC,aAAa,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAG3E,MAAM,IAAA,6BAAgB,EAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE1E,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,+DAA+D,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,EAAE,CAAC;IACrH,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,YAAoB;QACtC,IAAI,CAAC,YAAY;YAAE,MAAM,IAAI,iCAAmB,CAAC,uBAAuB,CAAC,CAAC;QAE1E,MAAM,OAAO,GAAG,IAAA,6BAAkB,EAAC,YAAY,CAAC,CAAC;QAGjD,MAAM,MAAM,GAAG,MAAM,YAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC/E,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,YAAY;YAAE,MAAM,IAAI,iCAAmB,CAAC,iBAAiB,CAAC,CAAC;QACtF,IAAI,MAAM,CAAC,YAAY,KAAK,YAAY;YAAE,MAAM,IAAI,iCAAmB,CAAC,uBAAuB,CAAC,CAAC;QAGjG,MAAM,MAAM,GAAG,IAAA,6BAAkB,EAAC,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;QAGpF,MAAM,YAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,OAAO,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,EAAE,YAAY,EAAE,MAAM,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAEzG,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;IACnC,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,MAAc;QAEzB,MAAM,YAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;QAClF,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,YAAY,EAAE,CAAC;IAClD,CAAC;CACF;AA5QD,kCA4QC"}
</file>

<file path="server/dist/services/call.service.d.ts">
import { CallStatus } from "@prisma/client";
export declare class CallService {
    initiateCall(conversationId: string, callerId: string, receiverId: string, callType: "AUDIO" | "VIDEO"): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    }>;
    updateCallStatus(callId: string, status: CallStatus): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    }>;
    endCall(callId: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    }>;
    declineCall(callId: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    }>;
    missCall(callId: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    }>;
    getActiveCall(conversationId: string): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    } | null>;
    getCallHistory(conversationId: string, userId: string, limit?: number, skip?: number): Promise<{
        id: string;
        status: import(".prisma/client").$Enums.CallStatus;
        createdAt: Date;
        receiverId: string | null;
        conversationId: string;
        type: import(".prisma/client").$Enums.CallType;
        callerId: string;
        duration: number | null;
        startedAt: Date | null;
        endedAt: Date | null;
    }[]>;
}
export declare const callService: CallService;
//# sourceMappingURL=call.service.d.ts.map
</file>

<file path="server/dist/services/call.service.d.ts.map">
{"version":3,"file":"call.service.d.ts","sourceRoot":"","sources":["../../src/services/call.service.ts"],"names":[],"mappings":"AACA,OAAO,EAAY,UAAU,EAAE,MAAM,gBAAgB,CAAC;AAOtD,qBAAa,WAAW;IAIhB,YAAY,CAChB,cAAc,EAAE,MAAM,EACtB,QAAQ,EAAE,MAAM,EAChB,UAAU,EAAE,MAAM,EAClB,QAAQ,EAAE,OAAO,GAAG,OAAO;;;;;;;;;;;;IA0DvB,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU;;;;;;;;;;;;IAqDnD,OAAO,CAAC,MAAM,EAAE,MAAM;;;;;;;;;;;;IAiCtB,WAAW,CAAC,MAAM,EAAE,MAAM;;;;;;;;;;;;IA2B1B,QAAQ,CAAC,MAAM,EAAE,MAAM;;;;;;;;;;;;IA2BvB,aAAa,CAAC,cAAc,EAAE,MAAM;;;;;;;;;;;;IAgBpC,cAAc,CAClB,cAAc,EAAE,MAAM,EACtB,MAAM,EAAE,MAAM,EACd,KAAK,GAAE,MAAW,EAClB,IAAI,GAAE,MAAU;;;;;;;;;;;;CAgCnB;AAGD,eAAO,MAAM,WAAW,aAAoB,CAAC"}
</file>

<file path="server/dist/services/call.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callService = exports.CallService = void 0;
const db_1 = __importDefault(require("../config/db"));
const error_types_1 = require("../types/error.types");
class CallService {
    async initiateCall(conversationId, callerId, receiverId, callType) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const callerParticipant = conversation.participants.find((p) => p.userId === callerId);
        const receiverParticipant = conversation.participants.find((p) => p.userId === receiverId);
        if (!callerParticipant || !receiverParticipant) {
            throw new error_types_1.AuthorizationError("Both users must be in the conversation");
        }
        const activeCall = await db_1.default.call.findFirst({
            where: {
                conversationId,
                status: {
                    in: ["INITIATING", "RINGING", "ACTIVE"],
                },
            },
        });
        if (activeCall) {
            throw new error_types_1.BadRequestError("There is already an active call in this conversation");
        }
        const call = await db_1.default.call.create({
            data: {
                conversationId,
                callerId,
                receiverId,
                type: callType,
                status: "INITIATING",
                startedAt: new Date(),
            },
        });
        return call;
    }
    async updateCallStatus(callId, status) {
        const call = await db_1.default.call.findUnique({
            where: { id: callId },
        });
        if (!call) {
            throw new error_types_1.NotFoundError("Call not found");
        }
        const validTransitions = {
            INITIATING: ["RINGING", "CANCELED"],
            RINGING: ["ACTIVE", "DECLINED", "MISSED"],
            ACTIVE: ["ENDED"],
            ENDED: [],
            DECLINED: [],
            MISSED: [],
            CANCELED: [],
        };
        if (!validTransitions[call.status].includes(status)) {
            throw new error_types_1.BadRequestError(`Cannot transition from ${call.status} to ${status}`);
        }
        const updateData = {
            status,
        };
        if (status === "ACTIVE") {
            updateData.startedAt = new Date();
        }
        else if (status === "ENDED") {
            updateData.endedAt = new Date();
            if (call.startedAt) {
                const duration = Math.floor((new Date().getTime() - call.startedAt.getTime()) / 1000);
                updateData.duration = duration;
            }
        }
        const updated = await db_1.default.call.update({
            where: { id: callId },
            data: updateData,
        });
        return updated;
    }
    async endCall(callId) {
        const call = await db_1.default.call.findUnique({
            where: { id: callId },
        });
        if (!call) {
            throw new error_types_1.NotFoundError("Call not found");
        }
        const endedAt = new Date();
        let duration = 0;
        if (call.startedAt) {
            duration = Math.floor((endedAt.getTime() - call.startedAt.getTime()) / 1000);
        }
        const updated = await db_1.default.call.update({
            where: { id: callId },
            data: {
                status: "ENDED",
                endedAt,
                duration,
            },
        });
        return updated;
    }
    async declineCall(callId) {
        const call = await db_1.default.call.findUnique({
            where: { id: callId },
        });
        if (!call) {
            throw new error_types_1.NotFoundError("Call not found");
        }
        if (call.status !== "RINGING") {
            throw new error_types_1.BadRequestError("Can only decline a ringing call");
        }
        const updated = await db_1.default.call.update({
            where: { id: callId },
            data: {
                status: "DECLINED",
                endedAt: new Date(),
            },
        });
        return updated;
    }
    async missCall(callId) {
        const call = await db_1.default.call.findUnique({
            where: { id: callId },
        });
        if (!call) {
            throw new error_types_1.NotFoundError("Call not found");
        }
        if (!["INITIATING", "RINGING"].includes(call.status)) {
            throw new error_types_1.BadRequestError("Call must be ringing to mark as missed");
        }
        const updated = await db_1.default.call.update({
            where: { id: callId },
            data: {
                status: "MISSED",
                endedAt: new Date(),
            },
        });
        return updated;
    }
    async getActiveCall(conversationId) {
        const call = await db_1.default.call.findFirst({
            where: {
                conversationId,
                status: {
                    in: ["INITIATING", "RINGING", "ACTIVE"],
                },
            },
        });
        return call || null;
    }
    async getCallHistory(conversationId, userId, limit = 20, skip = 0) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === userId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not a member of this conversation");
        }
        const calls = await db_1.default.call.findMany({
            where: {
                conversationId,
            },
            orderBy: {
                startedAt: "desc",
            },
            take: limit,
            skip,
        });
        return calls;
    }
}
exports.CallService = CallService;
exports.callService = new CallService();
//# sourceMappingURL=call.service.js.map
</file>

<file path="server/dist/services/call.service.js.map">
{"version":3,"file":"call.service.js","sourceRoot":"","sources":["../../src/services/call.service.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/services/conversation.service.d.ts">
export declare class ConversationService {
    getOrCreateConversation(userId: string, friendId: string): Promise<{
        participants: ({
            user: {
                name: string | null;
                id: string;
                email: string;
                avatar: string | null;
            };
        } & {
            id: string;
            userId: string;
            conversationId: string;
            isArchived: boolean;
            isMuted: boolean;
            lastReadAt: Date | null;
            joinedAt: Date;
        })[];
        messages: {
            id: string;
            status: import(".prisma/client").$Enums.MessageStatus;
            createdAt: Date;
            updatedAt: Date;
            senderId: string;
            conversationId: string;
            content: string;
            type: import(".prisma/client").$Enums.MessageType;
            mediaUrls: string[];
            isEdited: boolean;
            editedAt: Date | null;
            editedContent: string | null;
        }[];
    } & {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        isArchived: boolean;
        lastMessageAt: Date | null;
    }>;
    getUserConversations(userId: string, limit?: number, skip?: number, search?: string): Promise<({
        participants: ({
            user: {
                name: string | null;
                id: string;
                email: string;
                avatar: string | null;
                status: string;
            };
        } & {
            id: string;
            userId: string;
            conversationId: string;
            isArchived: boolean;
            isMuted: boolean;
            lastReadAt: Date | null;
            joinedAt: Date;
        })[];
        messages: {
            id: string;
            status: import(".prisma/client").$Enums.MessageStatus;
            createdAt: Date;
            updatedAt: Date;
            senderId: string;
            conversationId: string;
            content: string;
            type: import(".prisma/client").$Enums.MessageType;
            mediaUrls: string[];
            isEdited: boolean;
            editedAt: Date | null;
            editedContent: string | null;
        }[];
    } & {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        isArchived: boolean;
        lastMessageAt: Date | null;
    })[]>;
    getConversation(conversationId: string, userId: string): Promise<{
        participants: ({
            user: {
                name: string | null;
                id: string;
                email: string;
                avatar: string | null;
                status: string;
            };
        } & {
            id: string;
            userId: string;
            conversationId: string;
            isArchived: boolean;
            isMuted: boolean;
            lastReadAt: Date | null;
            joinedAt: Date;
        })[];
        messages: ({
            sender: {
                name: string | null;
                id: string;
                avatar: string | null;
            };
        } & {
            id: string;
            status: import(".prisma/client").$Enums.MessageStatus;
            createdAt: Date;
            updatedAt: Date;
            senderId: string;
            conversationId: string;
            content: string;
            type: import(".prisma/client").$Enums.MessageType;
            mediaUrls: string[];
            isEdited: boolean;
            editedAt: Date | null;
            editedContent: string | null;
        })[];
    } & {
        id: string;
        createdAt: Date;
        updatedAt: Date;
        isArchived: boolean;
        lastMessageAt: Date | null;
    }>;
    getOtherUser(conversationId: string, userId: string): Promise<{
        name: string | null;
        id: string;
        email: string;
        avatar: string | null;
        status: string;
    }>;
    archiveConversation(conversationId: string, userId: string): Promise<{
        id: string;
        userId: string;
        conversationId: string;
        isArchived: boolean;
        isMuted: boolean;
        lastReadAt: Date | null;
        joinedAt: Date;
    }>;
    unarchiveConversation(conversationId: string, userId: string): Promise<{
        id: string;
        userId: string;
        conversationId: string;
        isArchived: boolean;
        isMuted: boolean;
        lastReadAt: Date | null;
        joinedAt: Date;
    }>;
    deleteConversation(conversationId: string, userId: string): Promise<void>;
    updateConversationLastMessage(conversationId: string): Promise<{
        id: string;
        createdAt: Date;
        updatedAt: Date;
        isArchived: boolean;
        lastMessageAt: Date | null;
    }>;
}
export declare const conversationService: ConversationService;
//# sourceMappingURL=conversation.service.d.ts.map
</file>

<file path="server/dist/services/conversation.service.d.ts.map">
{"version":3,"file":"conversation.service.d.ts","sourceRoot":"","sources":["../../src/services/conversation.service.ts"],"names":[],"mappings":"AAOA,qBAAa,mBAAmB;IAIxB,uBAAuB,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA2ExD,oBAAoB,CACxB,MAAM,EAAE,MAAM,EACd,KAAK,GAAE,MAAW,EAClB,IAAI,GAAE,MAAU,EAChB,MAAM,CAAC,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAwCX,eAAe,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiCtD,YAAY,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;;;;IAgCnD,mBAAmB,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;;;;;;IAkC1D,qBAAqB,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;;;;;;IAkC5D,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;IAoDzD,6BAA6B,CAAC,cAAc,EAAE,MAAM;;;;;;;CAQ3D;AAGD,eAAO,MAAM,mBAAmB,qBAA4B,CAAC"}
</file>

<file path="server/dist/services/conversation.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.conversationService = exports.ConversationService = void 0;
const db_1 = __importDefault(require("../config/db"));
const error_types_1 = require("../types/error.types");
class ConversationService {
    async getOrCreateConversation(userId, friendId) {
        const friend = await db_1.default.user.findUnique({
            where: { id: friendId },
        });
        if (!friend) {
            throw new error_types_1.NotFoundError("Friend not found");
        }
        const friendship = await db_1.default.friend.findFirst({
            where: {
                OR: [
                    { userId, friendId },
                    { userId: friendId, friendId: userId },
                ],
            },
        });
        if (!friendship) {
            throw new error_types_1.BadRequestError("You must be friends to create a conversation");
        }
        const existingConversation = await db_1.default.conversation.findFirst({
            where: {
                participants: {
                    every: {
                        userId: { in: [userId, friendId] },
                    },
                },
            },
            include: {
                participants: {
                    include: {
                        user: { select: { id: true, name: true, email: true, avatar: true } },
                    },
                },
                messages: { take: 1, orderBy: { createdAt: "desc" } },
            },
        });
        if (existingConversation) {
            return existingConversation;
        }
        const conversation = await db_1.default.conversation.create({
            data: {
                participants: {
                    createMany: {
                        data: [
                            { userId },
                            { userId: friendId },
                        ],
                    },
                },
            },
            include: {
                participants: {
                    include: {
                        user: { select: { id: true, name: true, email: true, avatar: true } },
                    },
                },
                messages: { take: 1, orderBy: { createdAt: "desc" } },
            },
        });
        return conversation;
    }
    async getUserConversations(userId, limit = 20, skip = 0, search) {
        const conversations = await db_1.default.conversation.findMany({
            where: {
                participants: {
                    some: { userId },
                },
                AND: search
                    ? {
                        participants: {
                            some: {
                                user: {
                                    name: { contains: search, mode: "insensitive" },
                                },
                            },
                        },
                    }
                    : {},
            },
            include: {
                participants: {
                    include: {
                        user: { select: { id: true, name: true, email: true, avatar: true, status: true } },
                    },
                },
                messages: { take: 1, orderBy: { createdAt: "desc" } },
            },
            orderBy: {
                lastMessageAt: "desc",
            },
            take: limit,
            skip,
        });
        return conversations;
    }
    async getConversation(conversationId, userId) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: {
                    include: {
                        user: { select: { id: true, name: true, email: true, avatar: true, status: true } },
                    },
                },
                messages: {
                    take: 50,
                    orderBy: { createdAt: "desc" },
                    include: { sender: { select: { id: true, name: true, avatar: true } } },
                },
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === userId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not part of this conversation");
        }
        return conversation;
    }
    async getOtherUser(conversationId, userId) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: {
                    include: {
                        user: { select: { id: true, name: true, email: true, avatar: true, status: true } },
                    },
                },
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const participant = conversation.participants.find((p) => p.userId === userId);
        if (!participant) {
            throw new error_types_1.AuthorizationError("You are not part of this conversation");
        }
        const otherParticipant = conversation.participants.find((p) => p.userId !== userId);
        if (!otherParticipant) {
            throw new error_types_1.NotFoundError("Other user not found in conversation");
        }
        return otherParticipant.user;
    }
    async archiveConversation(conversationId, userId) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === userId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not part of this conversation");
        }
        const updated = await db_1.default.conversationParticipant.update({
            where: {
                conversationId_userId: {
                    conversationId,
                    userId,
                },
            },
            data: { isArchived: true },
        });
        return updated;
    }
    async unarchiveConversation(conversationId, userId) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === userId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not part of this conversation");
        }
        const updated = await db_1.default.conversationParticipant.update({
            where: {
                conversationId_userId: {
                    conversationId,
                    userId,
                },
            },
            data: { isArchived: false },
        });
        return updated;
    }
    async deleteConversation(conversationId, userId) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === userId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not part of this conversation");
        }
        await db_1.default.messageReaction.deleteMany({
            where: {
                message: { conversationId },
            },
        });
        await db_1.default.messageRead.deleteMany({
            where: {
                message: { conversationId },
            },
        });
        await db_1.default.message.deleteMany({
            where: { conversationId },
        });
        await db_1.default.call.deleteMany({
            where: { conversationId },
        });
        await db_1.default.conversationParticipant.deleteMany({
            where: { conversationId },
        });
        await db_1.default.conversation.delete({
            where: { id: conversationId },
        });
    }
    async updateConversationLastMessage(conversationId) {
        const updated = await db_1.default.conversation.update({
            where: { id: conversationId },
            data: { lastMessageAt: new Date() },
        });
        return updated;
    }
}
exports.ConversationService = ConversationService;
exports.conversationService = new ConversationService();
//# sourceMappingURL=conversation.service.js.map
</file>

<file path="server/dist/services/conversation.service.js.map">
{"version":3,"file":"conversation.service.js","sourceRoot":"","sources":["../../src/services/conversation.service.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/services/email.service.d.ts">
export declare const initializeEmailService: () => void;
export interface EmailOptions {
    to: string;
    subject: string;
    html: string;
    text?: string;
}
export declare const sendEmail: (options: EmailOptions) => Promise<void>;
export declare const sendVerificationEmail: (email: string, verificationToken: string, verificationUrl: string) => Promise<void>;
export declare const sendPasswordResetEmail: (email: string, resetToken: string, resetUrl: string) => Promise<void>;
export declare const sendWelcomeEmail: (email: string, name: string) => Promise<void>;
export declare const verifyEmailService: () => Promise<boolean>;
//# sourceMappingURL=email.service.d.ts.map
</file>

<file path="server/dist/services/email.service.d.ts.map">
{"version":3,"file":"email.service.d.ts","sourceRoot":"","sources":["../../src/services/email.service.ts"],"names":[],"mappings":"AAWA,eAAO,MAAM,sBAAsB,QAAO,IAezC,CAAC;AAKF,MAAM,WAAW,YAAY;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,MAAM,CAAC;CACf;AAKD,eAAO,MAAM,SAAS,GAAU,SAAS,YAAY,KAAG,OAAO,CAAC,IAAI,CAoBnE,CAAC;AAKF,eAAO,MAAM,qBAAqB,GAChC,OAAO,MAAM,EACb,mBAAmB,MAAM,EACzB,iBAAiB,MAAM,KACtB,OAAO,CAAC,IAAI,CAuBd,CAAC;AAKF,eAAO,MAAM,sBAAsB,GACjC,OAAO,MAAM,EACb,YAAY,MAAM,EAClB,UAAU,MAAM,KACf,OAAO,CAAC,IAAI,CAuBd,CAAC;AAKF,eAAO,MAAM,gBAAgB,GAC3B,OAAO,MAAM,EACb,MAAM,MAAM,KACX,OAAO,CAAC,IAAI,CAuBd,CAAC;AAKF,eAAO,MAAM,kBAAkB,QAAa,OAAO,CAAC,OAAO,CAY1D,CAAC"}
</file>

<file path="server/dist/services/email.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyEmailService = exports.sendWelcomeEmail = exports.sendPasswordResetEmail = exports.sendVerificationEmail = exports.sendEmail = exports.initializeEmailService = void 0;
const nodemailer_1 = __importDefault(require("nodemailer"));
const env_config_1 = require("../config/env.config");
let transporter;
const initializeEmailService = () => {
    try {
        transporter = nodemailer_1.default.createTransport({
            service: env_config_1.config.EMAIL_SERVICE,
            auth: {
                user: env_config_1.config.EMAIL_USER,
                pass: env_config_1.config.EMAIL_PASSWORD,
            },
        });
        console.log("‚úÖ Email service initialized successfully");
    }
    catch (error) {
        console.error("‚ùå Failed to initialize email service:", error);
        throw new Error("Email service initialization failed");
    }
};
exports.initializeEmailService = initializeEmailService;
const sendEmail = async (options) => {
    try {
        if (!transporter) {
            (0, exports.initializeEmailService)();
        }
        const mailOptions = {
            from: env_config_1.config.EMAIL_FROM,
            to: options.to,
            subject: options.subject,
            html: options.html,
            text: options.text || options.html,
        };
        const info = await transporter.sendMail(mailOptions);
        console.log(`‚úÖ Email sent: ${info.messageId}`);
    }
    catch (error) {
        console.error("‚ùå Failed to send email:", error);
        throw new Error("Failed to send email");
    }
};
exports.sendEmail = sendEmail;
const sendVerificationEmail = async (email, verificationToken, verificationUrl) => {
    const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Email Verification</h2>
      <p>Thank you for signing up! Please verify your email address by clicking the link below:</p>
      <p style="margin: 30px 0;">
        <a href="${verificationUrl}" style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
          Verify Email
        </a>
      </p>
      <p>Or copy and paste this link in your browser:</p>
      <p style="word-break: break-all; color: #666;">${verificationUrl}</p>
      <p style="color: #999; font-size: 12px;">This verification link will expire in ${env_config_1.config.VERIFICATION_EXPIRY}.</p>
      <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;" />
      <p style="color: #999; font-size: 12px;">If you didn't create this account, please ignore this email.</p>
    </div>
  `;
    await (0, exports.sendEmail)({
        to: email,
        subject: "Verify Your Email Address",
        html,
    });
};
exports.sendVerificationEmail = sendVerificationEmail;
const sendPasswordResetEmail = async (email, resetToken, resetUrl) => {
    const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Reset Your Password</h2>
      <p>We received a request to reset your password. Click the link below to create a new password:</p>
      <p style="margin: 30px 0;">
        <a href="${resetUrl}" style="background-color: #28a745; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
          Reset Password
        </a>
      </p>
      <p>Or copy and paste this link in your browser:</p>
      <p style="word-break: break-all; color: #666;">${resetUrl}</p>
      <p style="color: #999; font-size: 12px;">This reset link will expire in 1 hour.</p>
      <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;" />
      <p style="color: #999; font-size: 12px;">If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
    </div>
  `;
    await (0, exports.sendEmail)({
        to: email,
        subject: "Reset Your Password",
        html,
    });
};
exports.sendPasswordResetEmail = sendPasswordResetEmail;
const sendWelcomeEmail = async (email, name) => {
    const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Welcome to Chat App!</h2>
      <p>Hi ${name},</p>
      <p>Thank you for joining our community! We're excited to have you on board.</p>
      <p>You can now:</p>
      <ul style="color: #666;">
        <li>Connect with friends and colleagues</li>
        <li>Send and receive messages in real-time</li>
        <li>Create and manage your profile</li>
      </ul>
      <p>If you have any questions or need assistance, feel free to reach out to our support team.</p>
      <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;" />
      <p style="color: #999; font-size: 12px;">¬© 2025 Chat App. All rights reserved.</p>
    </div>
  `;
    await (0, exports.sendEmail)({
        to: email,
        subject: "Welcome to Chat App!",
        html,
    });
};
exports.sendWelcomeEmail = sendWelcomeEmail;
const verifyEmailService = async () => {
    try {
        if (!transporter) {
            (0, exports.initializeEmailService)();
        }
        await transporter.verify();
        console.log("‚úÖ Email service verified");
        return true;
    }
    catch (error) {
        console.error("‚ùå Email service verification failed:", error);
        return false;
    }
};
exports.verifyEmailService = verifyEmailService;
//# sourceMappingURL=email.service.js.map
</file>

<file path="server/dist/services/email.service.js.map">
{"version":3,"file":"email.service.js","sourceRoot":"","sources":["../../src/services/email.service.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/services/friend.service.d.ts">
export declare function sendFriendRequest(senderId: string, receiverId: string): Promise<{
    sender: {
        name: string | null;
        id: string;
        email: string;
        avatar: string | null;
    };
    receiver: {
        name: string | null;
        id: string;
        email: string;
        avatar: string | null;
    };
} & {
    id: string;
    status: string;
    createdAt: Date;
    updatedAt: Date;
    senderId: string;
    receiverId: string;
}>;
export declare function acceptFriendRequest(requestId: string, userId: string): Promise<{
    request: {
        id: string;
        status: string;
        createdAt: Date;
        updatedAt: Date;
        senderId: string;
        receiverId: string;
    };
    friendship: {
        id: string;
        createdAt: Date;
        userId: string;
        friendId: string;
    };
}>;
export declare function rejectFriendRequest(requestId: string, userId: string): Promise<{
    id: string;
    status: string;
    createdAt: Date;
    updatedAt: Date;
    senderId: string;
    receiverId: string;
}>;
export declare function cancelFriendRequest(requestId: string, userId: string): Promise<{
    message: string;
}>;
export declare function getFriendRequests(userId: string, type: "pending" | "sent", limit: number, skip: number): Promise<({} & {
    id: string;
    status: string;
    createdAt: Date;
    updatedAt: Date;
    senderId: string;
    receiverId: string;
})[]>;
export declare function getFriendRequestsCount(userId: string, type: "pending" | "sent"): Promise<number>;
export declare function getFriends(userId: string, limit: number, skip: number, search?: string): Promise<{
    name: string | null;
    id: string;
    email: string;
    avatar: string | null;
    bio: string | null;
    status: string;
}[]>;
export declare function getFriendsCount(userId: string, search?: string): Promise<number>;
export declare function removeFriend(userId: string, friendId: string): Promise<{
    message: string;
}>;
//# sourceMappingURL=friend.service.d.ts.map
</file>

<file path="server/dist/services/friend.service.d.ts.map">
{"version":3,"file":"friend.service.d.ts","sourceRoot":"","sources":["../../src/services/friend.service.ts"],"names":[],"mappings":"AAYA,wBAAsB,iBAAiB,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;GAkF3E;AAKD,wBAAsB,mBAAmB,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;;;;;;;;;;;;GA6C1E;AAKD,wBAAsB,mBAAmB,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;;;;GA8B1E;AAKD,wBAAsB,mBAAmB,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;GA0B1E;AAKD,wBAAsB,iBAAiB,CACrC,MAAM,EAAE,MAAM,EACd,IAAI,EAAE,SAAS,GAAG,MAAM,EACxB,KAAK,EAAE,MAAM,EACb,IAAI,EAAE,MAAM;;;;;;;MAsCb;AAKD,wBAAsB,sBAAsB,CAC1C,MAAM,EAAE,MAAM,EACd,IAAI,EAAE,SAAS,GAAG,MAAM,mBAUzB;AAKD,wBAAsB,UAAU,CAC9B,MAAM,EAAE,MAAM,EACd,KAAK,EAAE,MAAM,EACb,IAAI,EAAE,MAAM,EACZ,MAAM,CAAC,EAAE,MAAM;;;;;;;KA6ChB;AAKD,wBAAsB,eAAe,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,MAAM,mBA2BpE;AAKD,wBAAsB,YAAY,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM;;GAqBlE"}
</file>

<file path="server/dist/services/friend.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendFriendRequest = sendFriendRequest;
exports.acceptFriendRequest = acceptFriendRequest;
exports.rejectFriendRequest = rejectFriendRequest;
exports.cancelFriendRequest = cancelFriendRequest;
exports.getFriendRequests = getFriendRequests;
exports.getFriendRequestsCount = getFriendRequestsCount;
exports.getFriends = getFriends;
exports.getFriendsCount = getFriendsCount;
exports.removeFriend = removeFriend;
const db_1 = __importDefault(require("../config/db"));
const error_types_1 = require("../types/error.types");
async function sendFriendRequest(senderId, receiverId) {
    if (senderId === receiverId) {
        throw new error_types_1.BadRequestError("You cannot send a friend request to yourself");
    }
    const receiver = await db_1.default.user.findUnique({
        where: { id: receiverId },
    });
    if (!receiver) {
        throw new error_types_1.NotFoundError("User not found");
    }
    const existingFriendship = await db_1.default.friend.findFirst({
        where: {
            OR: [
                { userId: senderId, friendId: receiverId },
                { userId: receiverId, friendId: senderId },
            ],
        },
    });
    if (existingFriendship) {
        throw new error_types_1.BadRequestError("You are already friends with this user");
    }
    const pendingRequest = await db_1.default.friendRequest.findFirst({
        where: {
            OR: [
                { senderId, receiverId, status: "PENDING" },
                { senderId: receiverId, receiverId: senderId, status: "PENDING" },
            ],
        },
    });
    if (pendingRequest) {
        if (pendingRequest.senderId === senderId) {
            throw new error_types_1.BadRequestError("Friend request already sent");
        }
        else {
            throw new error_types_1.BadRequestError("This user has already sent you a friend request");
        }
    }
    return db_1.default.friendRequest.upsert({
        where: {
            senderId_receiverId: { senderId, receiverId },
        },
        update: {
            status: "PENDING",
        },
        create: {
            senderId,
            receiverId,
            status: "PENDING",
        },
        include: {
            sender: {
                select: {
                    id: true,
                    name: true,
                    email: true,
                    avatar: true,
                },
            },
            receiver: {
                select: {
                    id: true,
                    name: true,
                    email: true,
                    avatar: true,
                },
            },
        },
    });
}
async function acceptFriendRequest(requestId, userId) {
    const request = await db_1.default.friendRequest.findUnique({
        where: { id: requestId },
    });
    if (!request) {
        throw new error_types_1.NotFoundError("Friend request not found");
    }
    if (request.receiverId !== userId) {
        throw new error_types_1.BadRequestError("You can only accept requests sent to you");
    }
    if (request.status === "ACCEPTED") {
        throw new error_types_1.BadRequestError("Friend request already accepted");
    }
    if (request.status === "REJECTED") {
        throw new error_types_1.BadRequestError("Cannot accept a rejected friend request");
    }
    const result = await db_1.default.$transaction(async (tx) => {
        const updatedRequest = await tx.friendRequest.update({
            where: { id: requestId },
            data: { status: "ACCEPTED" },
        });
        const friendship = await tx.friend.create({
            data: {
                userId: request.senderId,
                friendId: request.receiverId,
            },
        });
        return { request: updatedRequest, friendship };
    });
    return result;
}
async function rejectFriendRequest(requestId, userId) {
    const request = await db_1.default.friendRequest.findUnique({
        where: { id: requestId },
    });
    if (!request) {
        throw new error_types_1.NotFoundError("Friend request not found");
    }
    if (request.receiverId !== userId) {
        throw new error_types_1.BadRequestError("You can only reject requests sent to you");
    }
    if (request.status === "REJECTED") {
        throw new error_types_1.BadRequestError("Friend request already rejected");
    }
    if (request.status === "ACCEPTED") {
        throw new error_types_1.BadRequestError("Cannot reject an accepted friend request");
    }
    return db_1.default.friendRequest.update({
        where: { id: requestId },
        data: { status: "REJECTED" },
    });
}
async function cancelFriendRequest(requestId, userId) {
    const request = await db_1.default.friendRequest.findUnique({
        where: { id: requestId },
    });
    if (!request) {
        throw new error_types_1.NotFoundError("Friend request not found");
    }
    if (request.senderId !== userId) {
        throw new error_types_1.BadRequestError("You can only cancel requests you sent");
    }
    if (request.status === "ACCEPTED") {
        throw new error_types_1.BadRequestError("Cannot cancel an accepted friend request");
    }
    await db_1.default.friendRequest.delete({
        where: { id: requestId },
    });
    return { message: "Friend request cancelled successfully" };
}
async function getFriendRequests(userId, type, limit, skip) {
    const isPending = type === "pending";
    return db_1.default.friendRequest.findMany({
        where: {
            ...(isPending ? { receiverId: userId } : { senderId: userId }),
            status: "PENDING",
        },
        include: {
            ...(isPending
                ? {
                    sender: {
                        select: {
                            id: true,
                            name: true,
                            email: true,
                            avatar: true,
                            bio: true,
                        },
                    },
                }
                : {
                    receiver: {
                        select: {
                            id: true,
                            name: true,
                            email: true,
                            avatar: true,
                            bio: true,
                        },
                    },
                }),
        },
        orderBy: { createdAt: "desc" },
        take: limit,
        skip,
    });
}
async function getFriendRequestsCount(userId, type) {
    const isPending = type === "pending";
    return db_1.default.friendRequest.count({
        where: {
            ...(isPending ? { receiverId: userId } : { senderId: userId }),
            status: "PENDING",
        },
    });
}
async function getFriends(userId, limit, skip, search) {
    const friendships = await db_1.default.friend.findMany({
        where: {
            OR: [{ userId }, { friendId: userId }],
        },
        select: {
            userId: true,
            friendId: true,
        },
    });
    const friendIds = friendships.map((f) => f.userId === userId ? f.friendId : f.userId);
    const whereClause = {
        id: { in: friendIds },
    };
    if (search) {
        whereClause.OR = [
            { name: { contains: search, mode: "insensitive" } },
            { email: { contains: search, mode: "insensitive" } },
        ];
    }
    return db_1.default.user.findMany({
        where: whereClause,
        select: {
            id: true,
            name: true,
            email: true,
            avatar: true,
            bio: true,
            status: true,
        },
        orderBy: { name: "asc" },
        take: limit,
        skip,
    });
}
async function getFriendsCount(userId, search) {
    const friendships = await db_1.default.friend.findMany({
        where: {
            OR: [{ userId }, { friendId: userId }],
        },
        select: {
            userId: true,
            friendId: true,
        },
    });
    const friendIds = friendships.map((f) => f.userId === userId ? f.friendId : f.userId);
    const whereClause = {
        id: { in: friendIds },
    };
    if (search) {
        whereClause.OR = [
            { name: { contains: search, mode: "insensitive" } },
            { email: { contains: search, mode: "insensitive" } },
        ];
    }
    return db_1.default.user.count({ where: whereClause });
}
async function removeFriend(userId, friendId) {
    const friendship = await db_1.default.friend.findFirst({
        where: {
            OR: [
                { userId, friendId },
                { userId: friendId, friendId: userId },
            ],
        },
    });
    if (!friendship) {
        throw new error_types_1.NotFoundError("Friendship not found");
    }
    await db_1.default.friend.delete({
        where: { id: friendship.id },
    });
    return { message: "Friend removed successfully" };
}
//# sourceMappingURL=friend.service.js.map
</file>

<file path="server/dist/services/friend.service.js.map">
{"version":3,"file":"friend.service.js","sourceRoot":"","sources":["../../src/services/friend.service.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/services/message.service.d.ts">
export declare class MessageService {
    sendMessage(conversationId: string, senderId: string, content: string, type?: string, mediaUrls?: string[]): Promise<{
        sender: {
            name: string | null;
            id: string;
            avatar: string | null;
        };
    } & {
        id: string;
        status: import(".prisma/client").$Enums.MessageStatus;
        createdAt: Date;
        updatedAt: Date;
        senderId: string;
        conversationId: string;
        content: string;
        type: import(".prisma/client").$Enums.MessageType;
        mediaUrls: string[];
        isEdited: boolean;
        editedAt: Date | null;
        editedContent: string | null;
    }>;
    getMessages(conversationId: string, limit?: number, skip?: number): Promise<({
        sender: {
            name: string | null;
            id: string;
            avatar: string | null;
        };
        readBy: {
            userId: string;
            readAt: Date;
        }[];
        reactions: {
            userId: string;
            emoji: string;
        }[];
    } & {
        id: string;
        status: import(".prisma/client").$Enums.MessageStatus;
        createdAt: Date;
        updatedAt: Date;
        senderId: string;
        conversationId: string;
        content: string;
        type: import(".prisma/client").$Enums.MessageType;
        mediaUrls: string[];
        isEdited: boolean;
        editedAt: Date | null;
        editedContent: string | null;
    })[]>;
    editMessage(messageId: string, userId: string, newContent: string): Promise<{
        sender: {
            name: string | null;
            id: string;
            avatar: string | null;
        };
        reactions: {
            userId: string;
            emoji: string;
        }[];
    } & {
        id: string;
        status: import(".prisma/client").$Enums.MessageStatus;
        createdAt: Date;
        updatedAt: Date;
        senderId: string;
        conversationId: string;
        content: string;
        type: import(".prisma/client").$Enums.MessageType;
        mediaUrls: string[];
        isEdited: boolean;
        editedAt: Date | null;
        editedContent: string | null;
    }>;
    deleteMessage(messageId: string, userId: string): Promise<{
        success: boolean;
        message: string;
    }>;
    markMessagesAsRead(conversationId: string, userId: string): Promise<void>;
    getMessageReadReceipts(messageId: string): Promise<({
        user: {
            name: string | null;
            id: string;
            avatar: string | null;
        };
    } & {
        id: string;
        userId: string;
        messageId: string;
        readAt: Date;
    })[]>;
    reactToMessage(messageId: string, userId: string, emoji: string): Promise<{
        id: string;
        createdAt: Date;
        userId: string;
        messageId: string;
        emoji: string;
    } | {
        removed: boolean;
    }>;
    getMessageReactions(messageId: string): Promise<Record<string, {
        userId: string;
        userName: string | null;
        userAvatar: string | null;
    }[]>>;
    removeReaction(messageId: string, userId: string, emoji: string): Promise<{
        success: boolean;
        message: string;
    }>;
    searchMessages(conversationId: string, searchText: string): Promise<({
        sender: {
            name: string | null;
            id: string;
            avatar: string | null;
        };
        reactions: {
            userId: string;
            emoji: string;
        }[];
    } & {
        id: string;
        status: import(".prisma/client").$Enums.MessageStatus;
        createdAt: Date;
        updatedAt: Date;
        senderId: string;
        conversationId: string;
        content: string;
        type: import(".prisma/client").$Enums.MessageType;
        mediaUrls: string[];
        isEdited: boolean;
        editedAt: Date | null;
        editedContent: string | null;
    })[]>;
}
export declare const messageService: MessageService;
//# sourceMappingURL=message.service.d.ts.map
</file>

<file path="server/dist/services/message.service.d.ts.map">
{"version":3,"file":"message.service.d.ts","sourceRoot":"","sources":["../../src/services/message.service.ts"],"names":[],"mappings":"AAQA,qBAAa,cAAc;IAInB,WAAW,CACf,cAAc,EAAE,MAAM,EACtB,QAAQ,EAAE,MAAM,EAChB,OAAO,EAAE,MAAM,EACf,IAAI,CAAC,EAAE,MAAM,EACb,SAAS,CAAC,EAAE,MAAM,EAAE;;;;;;;;;;;;;;;;;;;;IA8ChB,WAAW,CACf,cAAc,EAAE,MAAM,EACtB,KAAK,GAAE,MAAW,EAClB,IAAI,GAAE,MAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6BZ,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;;;;;IAuCjE,aAAa,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;;;;IAuB/C,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;IAoCzD,sBAAsB,CAAC,SAAS,EAAE,MAAM;;;;;;;;;;;;IAsBxC,cAAc,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;;;;;;;;;IAkE/D,mBAAmB,CAAC,SAAS,EAAE,MAAM;gBAsCF,MAAM;kBAAY,MAAM,GAAG,IAAI;oBAAc,MAAM,GAAG,IAAI;;IAS7F,cAAc,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;;;;IAyB/D,cAAc,CAAC,cAAc,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM;;;;;;;;;;;;;;;;;;;;;;;;CA2BhE;AAGD,eAAO,MAAM,cAAc,gBAAuB,CAAC"}
</file>

<file path="server/dist/services/message.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.messageService = exports.MessageService = void 0;
const db_1 = __importDefault(require("../config/db"));
const error_types_1 = require("../types/error.types");
class MessageService {
    async sendMessage(conversationId, senderId, content, type, mediaUrls) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === senderId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not part of this conversation");
        }
        const message = await db_1.default.message.create({
            data: {
                conversationId,
                senderId,
                content,
                type: (type || "TEXT"),
                mediaUrls: mediaUrls || [],
                status: "SENT",
            },
            include: {
                sender: { select: { id: true, name: true, avatar: true } },
            },
        });
        await db_1.default.conversation.update({
            where: { id: conversationId },
            data: { lastMessageAt: new Date() },
        });
        return message;
    }
    async getMessages(conversationId, limit = 20, skip = 0) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const messages = await db_1.default.message.findMany({
            where: { conversationId },
            include: {
                sender: { select: { id: true, name: true, avatar: true } },
                readBy: { select: { userId: true, readAt: true } },
                reactions: { select: { emoji: true, userId: true } },
            },
            orderBy: { createdAt: "desc" },
            take: limit,
            skip,
        });
        return messages;
    }
    async editMessage(messageId, userId, newContent) {
        const message = await db_1.default.message.findUnique({
            where: { id: messageId },
        });
        if (!message) {
            throw new error_types_1.NotFoundError("Message not found");
        }
        if (message.senderId !== userId) {
            throw new error_types_1.AuthorizationError("You can only edit your own messages");
        }
        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
        if (message.createdAt < fiveMinutesAgo) {
            throw new error_types_1.BadRequestError("Message can only be edited within 5 minutes of sending");
        }
        const updated = await db_1.default.message.update({
            where: { id: messageId },
            data: {
                content: newContent,
                isEdited: true,
                editedAt: new Date(),
                editedContent: message.content,
            },
            include: {
                sender: { select: { id: true, name: true, avatar: true } },
                reactions: { select: { emoji: true, userId: true } },
            },
        });
        return updated;
    }
    async deleteMessage(messageId, userId) {
        const message = await db_1.default.message.findUnique({
            where: { id: messageId },
        });
        if (!message) {
            throw new error_types_1.NotFoundError("Message not found");
        }
        if (message.senderId !== userId) {
            throw new error_types_1.AuthorizationError("You can only delete your own messages");
        }
        await db_1.default.message.delete({
            where: { id: messageId },
        });
        return { success: true, message: "Message deleted" };
    }
    async markMessagesAsRead(conversationId, userId) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const unreadMessages = await db_1.default.message.findMany({
            where: {
                conversationId,
                senderId: { not: userId },
            },
            select: { id: true },
        });
        if (unreadMessages.length === 0) {
            return;
        }
        await db_1.default.messageRead.createMany({
            data: unreadMessages.map((msg) => ({
                messageId: msg.id,
                userId,
                readAt: new Date(),
            })),
            skipDuplicates: true,
        });
    }
    async getMessageReadReceipts(messageId) {
        const message = await db_1.default.message.findUnique({
            where: { id: messageId },
            include: {
                readBy: {
                    include: {
                        user: { select: { id: true, name: true, avatar: true } },
                    },
                },
            },
        });
        if (!message) {
            throw new error_types_1.NotFoundError("Message not found");
        }
        return message.readBy;
    }
    async reactToMessage(messageId, userId, emoji) {
        const message = await db_1.default.message.findUnique({
            where: { id: messageId },
        });
        if (!message) {
            throw new error_types_1.NotFoundError("Message not found");
        }
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: message.conversationId },
            include: {
                participants: true,
            },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const isParticipant = conversation.participants.some((p) => p.userId === userId);
        if (!isParticipant) {
            throw new error_types_1.AuthorizationError("You are not a member of this conversation");
        }
        const existingReaction = await db_1.default.messageReaction.findUnique({
            where: {
                messageId_userId_emoji: {
                    messageId,
                    userId,
                    emoji,
                },
            },
        });
        if (existingReaction) {
            await db_1.default.messageReaction.delete({
                where: {
                    messageId_userId_emoji: {
                        messageId,
                        userId,
                        emoji,
                    },
                },
            });
            return { removed: true };
        }
        const reaction = await db_1.default.messageReaction.create({
            data: {
                messageId,
                userId,
                emoji,
            },
        });
        return reaction;
    }
    async getMessageReactions(messageId) {
        const message = await db_1.default.message.findUnique({
            where: { id: messageId },
        });
        if (!message) {
            throw new error_types_1.NotFoundError("Message not found");
        }
        const reactions = await db_1.default.messageReaction.findMany({
            where: { messageId },
            include: {
                user: {
                    select: {
                        id: true,
                        name: true,
                        avatar: true,
                    },
                },
            },
            orderBy: {
                createdAt: "asc",
            },
        });
        const grouped = reactions.reduce((acc, reaction) => {
            if (!acc[reaction.emoji]) {
                acc[reaction.emoji] = [];
            }
            acc[reaction.emoji].push({
                userId: reaction.user.id,
                userName: reaction.user.name,
                userAvatar: reaction.user.avatar,
            });
            return acc;
        }, {});
        return grouped;
    }
    async removeReaction(messageId, userId, emoji) {
        const reaction = await db_1.default.messageReaction.findUnique({
            where: {
                messageId_userId_emoji: {
                    messageId,
                    userId,
                    emoji,
                },
            },
        });
        if (!reaction) {
            throw new error_types_1.NotFoundError("Reaction not found");
        }
        await db_1.default.messageReaction.delete({
            where: { id: reaction.id },
        });
        return { success: true, message: "Reaction removed" };
    }
    async searchMessages(conversationId, searchText) {
        const conversation = await db_1.default.conversation.findUnique({
            where: { id: conversationId },
        });
        if (!conversation) {
            throw new error_types_1.NotFoundError("Conversation not found");
        }
        const messages = await db_1.default.message.findMany({
            where: {
                conversationId,
                content: {
                    contains: searchText,
                    mode: "insensitive",
                },
            },
            include: {
                sender: { select: { id: true, name: true, avatar: true } },
                reactions: { select: { emoji: true, userId: true } },
            },
            orderBy: { createdAt: "desc" },
            take: 50,
        });
        return messages;
    }
}
exports.MessageService = MessageService;
exports.messageService = new MessageService();
//# sourceMappingURL=message.service.js.map
</file>

<file path="server/dist/services/message.service.js.map">
{"version":3,"file":"message.service.js","sourceRoot":"","sources":["../../src/services/message.service.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/services/user.service.d.ts">
import { UpdateProfileDTO } from "../dto/user.dto";
export declare const getUserProfile: (userId: string) => Promise<{
    name: string | null;
    id: string;
    email: string;
    avatar: string | null;
    bio: string | null;
    role: import(".prisma/client").$Enums.UserRole;
    status: string;
    emailVerified: boolean;
    createdAt: Date;
    updatedAt: Date;
}>;
export declare const getUserById: (userId: string) => Promise<{
    name: string | null;
    id: string;
    avatar: string | null;
    bio: string | null;
    status: string;
    createdAt: Date;
}>;
export declare const updateUserProfile: (userId: string, data: UpdateProfileDTO) => Promise<{
    name: string | null;
    id: string;
    email: string;
    avatar: string | null;
    bio: string | null;
    role: import(".prisma/client").$Enums.UserRole;
    status: string;
    updatedAt: Date;
}>;
export declare const uploadUserAvatar: (userId: string, file: Express.Multer.File) => Promise<{
    name: string | null;
    id: string;
    email: string;
    avatar: string | null;
    bio: string | null;
    status: string;
    updatedAt: Date;
}>;
export declare const searchUsers: (query: string, limit?: number) => Promise<{
    name: string | null;
    id: string;
    email: string;
    avatar: string | null;
    bio: string | null;
    status: string;
}[]>;
export declare const deleteUserAccount: (userId: string) => Promise<{
    message: string;
}>;
export declare const updateUserStatus: (userId: string, status: string) => Promise<{
    id: string;
    status: string;
    updatedAt: Date;
}>;
export declare const getAllUsers: (limit?: number, skip?: number) => Promise<{
    name: string | null;
    id: string;
    email: string;
    avatar: string | null;
    bio: string | null;
    role: import(".prisma/client").$Enums.UserRole;
    status: string;
    createdAt: Date;
}[]>;
export declare const getTotalUsersCount: () => Promise<number>;
//# sourceMappingURL=user.service.d.ts.map
</file>

<file path="server/dist/services/user.service.d.ts.map">
{"version":3,"file":"user.service.d.ts","sourceRoot":"","sources":["../../src/services/user.service.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,gBAAgB,EAAE,MAAM,iBAAiB,CAAC;AAKnD,eAAO,MAAM,cAAc,GAAU,QAAQ,MAAM;;;;;;;;;;;EAsBlD,CAAC;AAKF,eAAO,MAAM,WAAW,GAAU,QAAQ,MAAM;;;;;;;EAkB/C,CAAC;AAKF,eAAO,MAAM,iBAAiB,GAAU,QAAQ,MAAM,EAAE,MAAM,gBAAgB;;;;;;;;;EAqB7E,CAAC;AAKF,eAAO,MAAM,gBAAgB,GAAU,QAAQ,MAAM,EAAE,MAAM,OAAO,CAAC,MAAM,CAAC,IAAI;;;;;;;;EAwC/E,CAAC;AAKF,eAAO,MAAM,WAAW,GAAU,OAAO,MAAM,EAAE,QAAO,MAAW;;;;;;;IAoBlE,CAAC;AAKF,eAAO,MAAM,iBAAiB,GAAU,QAAQ,MAAM;;EAsBrD,CAAC;AAKF,eAAO,MAAM,gBAAgB,GAAU,QAAQ,MAAM,EAAE,QAAQ,MAAM;;;;EAkBpE,CAAC;AAKF,eAAO,MAAM,WAAW,GAAU,QAAO,MAAW,EAAE,OAAM,MAAU;;;;;;;;;IAkBrE,CAAC;AAKF,eAAO,MAAM,kBAAkB,uBAE9B,CAAC"}
</file>

<file path="server/dist/services/user.service.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTotalUsersCount = exports.getAllUsers = exports.updateUserStatus = exports.deleteUserAccount = exports.searchUsers = exports.uploadUserAvatar = exports.updateUserProfile = exports.getUserById = exports.getUserProfile = void 0;
const db_1 = __importDefault(require("../config/db"));
const cloudinary_util_1 = require("../utils/cloudinary.util");
const getUserProfile = async (userId) => {
    const user = await db_1.default.user.findUnique({
        where: { id: userId },
        select: {
            id: true,
            email: true,
            name: true,
            avatar: true,
            bio: true,
            status: true,
            role: true,
            emailVerified: true,
            createdAt: true,
            updatedAt: true,
        },
    });
    if (!user) {
        throw new Error("User not found");
    }
    return user;
};
exports.getUserProfile = getUserProfile;
const getUserById = async (userId) => {
    const user = await db_1.default.user.findUnique({
        where: { id: userId },
        select: {
            id: true,
            name: true,
            avatar: true,
            bio: true,
            status: true,
            createdAt: true,
        },
    });
    if (!user) {
        throw new Error("User not found");
    }
    return user;
};
exports.getUserById = getUserById;
const updateUserProfile = async (userId, data) => {
    const user = await db_1.default.user.update({
        where: { id: userId },
        data: {
            ...(data.name && { name: data.name }),
            ...(data.bio !== undefined && { bio: data.bio }),
            ...(data.status && { status: data.status }),
        },
        select: {
            id: true,
            email: true,
            name: true,
            avatar: true,
            bio: true,
            status: true,
            role: true,
            updatedAt: true,
        },
    });
    return user;
};
exports.updateUserProfile = updateUserProfile;
const uploadUserAvatar = async (userId, file) => {
    if (!file) {
        throw new Error("No file provided");
    }
    const currentUser = await db_1.default.user.findUnique({
        where: { id: userId },
        select: { avatar: true },
    });
    if (currentUser?.avatar) {
        try {
            const publicId = (0, cloudinary_util_1.getPublicIdFromUrl)(currentUser.avatar);
            await (0, cloudinary_util_1.deleteFromCloudinary)(publicId);
        }
        catch (error) {
            console.error("Error deleting old avatar:", error);
        }
    }
    const uploadResult = await (0, cloudinary_util_1.uploadToCloudinary)(file, "chat-app/avatars");
    const updatedUser = await db_1.default.user.update({
        where: { id: userId },
        data: { avatar: uploadResult.secure_url },
        select: {
            id: true,
            email: true,
            name: true,
            avatar: true,
            bio: true,
            status: true,
            updatedAt: true,
        },
    });
    return updatedUser;
};
exports.uploadUserAvatar = uploadUserAvatar;
const searchUsers = async (query, limit = 10) => {
    const users = await db_1.default.user.findMany({
        where: {
            OR: [
                { name: { contains: query, mode: "insensitive" } },
                { email: { contains: query, mode: "insensitive" } },
            ],
        },
        select: {
            id: true,
            name: true,
            email: true,
            avatar: true,
            bio: true,
            status: true,
        },
        take: limit,
    });
    return users;
};
exports.searchUsers = searchUsers;
const deleteUserAccount = async (userId) => {
    const user = await db_1.default.user.findUnique({
        where: { id: userId },
        select: { avatar: true },
    });
    if (user?.avatar) {
        try {
            const publicId = (0, cloudinary_util_1.getPublicIdFromUrl)(user.avatar);
            await (0, cloudinary_util_1.deleteFromCloudinary)(publicId);
        }
        catch (error) {
            console.error("Error deleting avatar:", error);
        }
    }
    await db_1.default.user.delete({
        where: { id: userId },
    });
    return { message: "Account deleted successfully" };
};
exports.deleteUserAccount = deleteUserAccount;
const updateUserStatus = async (userId, status) => {
    const validStatuses = ["online", "offline", "away"];
    if (!validStatuses.includes(status)) {
        throw new Error("Invalid status. Must be one of: online, offline, away");
    }
    const user = await db_1.default.user.update({
        where: { id: userId },
        data: { status },
        select: {
            id: true,
            status: true,
            updatedAt: true,
        },
    });
    return user;
};
exports.updateUserStatus = updateUserStatus;
const getAllUsers = async (limit = 10, skip = 0) => {
    const users = await db_1.default.user.findMany({
        select: {
            id: true,
            name: true,
            email: true,
            avatar: true,
            bio: true,
            role: true,
            status: true,
            createdAt: true,
        },
        take: limit,
        skip: skip,
        orderBy: { createdAt: "desc" },
    });
    return users;
};
exports.getAllUsers = getAllUsers;
const getTotalUsersCount = async () => {
    return db_1.default.user.count();
};
exports.getTotalUsersCount = getTotalUsersCount;
//# sourceMappingURL=user.service.js.map
</file>

<file path="server/dist/services/user.service.js.map">
{"version":3,"file":"user.service.js","sourceRoot":"","sources":["../../src/services/user.service.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/socket/chat.socket.d.ts">
import { Server } from "socket.io";
export declare function setupChatSocket(io: Server): void;
//# sourceMappingURL=chat.socket.d.ts.map
</file>

<file path="server/dist/socket/chat.socket.d.ts.map">
{"version":3,"file":"chat.socket.d.ts","sourceRoot":"","sources":["../../src/socket/chat.socket.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAU,MAAM,WAAW,CAAC;AAG3C,wBAAgB,eAAe,CAAC,EAAE,EAAE,MAAM,QAmPzC"}
</file>

<file path="server/dist/socket/chat.socket.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupChatSocket = setupChatSocket;
const message_service_1 = require("../services/message.service");
function setupChatSocket(io) {
    io.on("connection", (socket) => {
        const userId = socket.data.userId;
        if (!userId) {
            socket.disconnect();
            return;
        }
        console.log(`‚úÖ User ${userId} connected - Socket: ${socket.id}`);
        socket.on("conversation:open", async (conversationId) => {
            try {
                console.log(`üìñ ${userId} opened conversation ${conversationId}`);
                socket.join(conversationId);
                await message_service_1.messageService.markMessagesAsRead(conversationId, userId);
                socket.to(conversationId).emit("messages:read", {
                    conversationId,
                    userId,
                    readAt: new Date(),
                });
                console.log(`‚úÖ Auto-marked messages as read for ${userId}`);
            }
            catch (error) {
                console.error("Error in conversation:open:", error);
                socket.emit("error", { message: "Failed to mark messages as read" });
            }
        });
        socket.on("conversation:close", (conversationId) => {
            console.log(`üëã ${userId} closed conversation ${conversationId}`);
            socket.leave(conversationId);
        });
        socket.on("message:send", async (data) => {
            try {
                const { conversationId, content, type = "TEXT", mediaUrls = [] } = data;
                console.log(`üì® Message from ${userId} in ${conversationId}`);
                const message = await message_service_1.messageService.sendMessage(conversationId, userId, content, type, mediaUrls);
                io.to(conversationId).emit("message:received", {
                    id: message.id,
                    conversationId,
                    senderId: userId,
                    content: message.content,
                    type: message.type,
                    status: "SENT",
                    createdAt: message.createdAt,
                    sender: {
                        id: userId,
                        name: message.sender?.name,
                        avatar: message.sender?.avatar,
                    },
                });
                console.log(`üì§ Message broadcasted to ${conversationId}`);
            }
            catch (error) {
                console.error("Error sending message:", error);
                socket.emit("error", { message: "Failed to send message" });
            }
        });
        socket.on("message:edit", async (data) => {
            try {
                const { messageId, conversationId, newContent } = data;
                console.log(`‚úèÔ∏è User ${userId} editing message ${messageId}`);
                const updatedMessage = await message_service_1.messageService.editMessage(messageId, userId, newContent);
                io.to(conversationId).emit("message:edited", {
                    messageId,
                    conversationId,
                    newContent: updatedMessage.content,
                    isEdited: true,
                    editedAt: updatedMessage.editedAt,
                });
                console.log(`‚úÖ Message edit broadcasted to ${conversationId}`);
            }
            catch (error) {
                console.error("Error editing message:", error);
                socket.emit("error", { message: "Failed to edit message" });
            }
        });
        socket.on("message:delete", async (data) => {
            try {
                const { messageId, conversationId } = data;
                console.log(`üóëÔ∏è User ${userId} deleting message ${messageId}`);
                await message_service_1.messageService.deleteMessage(messageId, userId);
                io.to(conversationId).emit("message:deleted", {
                    messageId,
                    conversationId,
                });
                console.log(`‚úÖ Message deletion broadcasted to ${conversationId}`);
            }
            catch (error) {
                console.error("Error deleting message:", error);
                socket.emit("error", { message: "Failed to delete message" });
            }
        });
        socket.on("typing:start", (conversationId) => {
            console.log(`‚å®Ô∏è ${userId} is typing in ${conversationId}`);
            socket.to(conversationId).emit("user:typing", {
                conversationId,
                userId,
                isTyping: true,
            });
        });
        socket.on("typing:stop", (conversationId) => {
            console.log(`‚å®Ô∏è ${userId} stopped typing in ${conversationId}`);
            socket.to(conversationId).emit("user:typing", {
                conversationId,
                userId,
                isTyping: false,
            });
        });
        socket.on("message:read", (data) => {
            try {
                const { conversationId, messageIds } = data;
                console.log(`üëÅÔ∏è ${userId} read messages in ${conversationId}`);
                socket.to(conversationId).emit("user:read-receipt", {
                    conversationId,
                    userId,
                    messageIds,
                    readAt: new Date(),
                });
                console.log(`‚úÖ Read receipt broadcasted to ${conversationId}`);
            }
            catch (error) {
                console.error("Error broadcasting read receipt:", error);
            }
        });
        socket.on("message:react", async (data) => {
            try {
                const { messageId, conversationId, emoji } = data;
                console.log(`üòä ${userId} reacted with ${emoji} to message ${messageId}`);
                const reaction = await message_service_1.messageService.reactToMessage(messageId, userId, emoji);
                io.to(conversationId).emit("message:reaction", {
                    messageId,
                    conversationId,
                    userId,
                    emoji,
                    removed: reaction.removed || false,
                });
                console.log(`‚úÖ Reaction broadcasted to ${conversationId}`);
            }
            catch (error) {
                console.error("Error reacting to message:", error);
                socket.emit("error", { message: "Failed to react to message" });
            }
        });
        socket.on("user:online", () => {
            console.log(`üü¢ ${userId} is online`);
            io.emit("user:status", { userId, status: "online" });
        });
        socket.on("disconnect", () => {
            console.log(`üî¥ ${userId} disconnected`);
            io.emit("user:status", { userId, status: "offline" });
        });
    });
}
//# sourceMappingURL=chat.socket.js.map
</file>

<file path="server/dist/socket/chat.socket.js.map">
{"version":3,"file":"chat.socket.js","sourceRoot":"","sources":["../../src/socket/chat.socket.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/types/error.types.d.ts">
export declare class AppError extends Error {
    statusCode: number;
    isOperational: boolean;
    constructor(message: string, statusCode?: number);
}
export declare class ValidationError extends AppError {
    constructor(message?: string);
}
export declare class BadRequestError extends AppError {
    constructor(message?: string);
}
export declare class AuthenticationError extends AppError {
    constructor(message?: string);
}
export declare class AuthorizationError extends AppError {
    constructor(message?: string);
}
export declare class NotFoundError extends AppError {
    constructor(message?: string);
}
export declare class ConflictError extends AppError {
    constructor(message?: string);
}
export declare class DatabaseError extends AppError {
    constructor(message?: string);
}
//# sourceMappingURL=error.types.d.ts.map
</file>

<file path="server/dist/types/error.types.d.ts.map">
{"version":3,"file":"error.types.d.ts","sourceRoot":"","sources":["../../src/types/error.types.ts"],"names":[],"mappings":"AAIA,qBAAa,QAAS,SAAQ,KAAK;IACjC,UAAU,EAAE,MAAM,CAAC;IACnB,aAAa,EAAE,OAAO,CAAC;gBAEX,OAAO,EAAE,MAAM,EAAE,UAAU,GAAE,MAAY;CAOtD;AAED,qBAAa,eAAgB,SAAQ,QAAQ;gBAC/B,OAAO,GAAE,MAA4B;CAGlD;AAED,qBAAa,eAAgB,SAAQ,QAAQ;gBAC/B,OAAO,GAAE,MAAsB;CAG5C;AAED,qBAAa,mBAAoB,SAAQ,QAAQ;gBACnC,OAAO,GAAE,MAAgC;CAGtD;AAED,qBAAa,kBAAmB,SAAQ,QAAQ;gBAClC,OAAO,GAAE,MAAwB;CAG9C;AAED,qBAAa,aAAc,SAAQ,QAAQ;gBAC7B,OAAO,GAAE,MAA6B;CAGnD;AAED,qBAAa,aAAc,SAAQ,QAAQ;gBAC7B,OAAO,GAAE,MAAkC;CAGxD;AAED,qBAAa,aAAc,SAAQ,QAAQ;gBAC7B,OAAO,GAAE,MAAoC;CAG1D"}
</file>

<file path="server/dist/types/error.types.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseError = exports.ConflictError = exports.NotFoundError = exports.AuthorizationError = exports.AuthenticationError = exports.BadRequestError = exports.ValidationError = exports.AppError = void 0;
class AppError extends Error {
    constructor(message, statusCode = 500) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = true;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.AppError = AppError;
class ValidationError extends AppError {
    constructor(message = "Validation failed") {
        super(message, 400);
    }
}
exports.ValidationError = ValidationError;
class BadRequestError extends AppError {
    constructor(message = "Bad request") {
        super(message, 400);
    }
}
exports.BadRequestError = BadRequestError;
class AuthenticationError extends AppError {
    constructor(message = "Authentication failed") {
        super(message, 401);
    }
}
exports.AuthenticationError = AuthenticationError;
class AuthorizationError extends AppError {
    constructor(message = "Access denied") {
        super(message, 403);
    }
}
exports.AuthorizationError = AuthorizationError;
class NotFoundError extends AppError {
    constructor(message = "Resource not found") {
        super(message, 404);
    }
}
exports.NotFoundError = NotFoundError;
class ConflictError extends AppError {
    constructor(message = "Resource already exists") {
        super(message, 409);
    }
}
exports.ConflictError = ConflictError;
class DatabaseError extends AppError {
    constructor(message = "Database operation failed") {
        super(message, 500);
    }
}
exports.DatabaseError = DatabaseError;
//# sourceMappingURL=error.types.js.map
</file>

<file path="server/dist/types/error.types.js.map">
{"version":3,"file":"error.types.js","sourceRoot":"","sources":["../../src/types/error.types.ts"],"names":[],"mappings":";;;AAIA,MAAa,QAAS,SAAQ,KAAK;IAIjC,YAAY,OAAe,EAAE,aAAqB,GAAG;QACnD,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAE1B,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IAClD,CAAC;CACF;AAXD,4BAWC;AAED,MAAa,eAAgB,SAAQ,QAAQ;IAC3C,YAAY,UAAkB,mBAAmB;QAC/C,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,0CAIC;AAED,MAAa,eAAgB,SAAQ,QAAQ;IAC3C,YAAY,UAAkB,aAAa;QACzC,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,0CAIC;AAED,MAAa,mBAAoB,SAAQ,QAAQ;IAC/C,YAAY,UAAkB,uBAAuB;QACnD,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,kDAIC;AAED,MAAa,kBAAmB,SAAQ,QAAQ;IAC9C,YAAY,UAAkB,eAAe;QAC3C,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,gDAIC;AAED,MAAa,aAAc,SAAQ,QAAQ;IACzC,YAAY,UAAkB,oBAAoB;QAChD,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,sCAIC;AAED,MAAa,aAAc,SAAQ,QAAQ;IACzC,YAAY,UAAkB,yBAAyB;QACrD,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,sCAIC;AAED,MAAa,aAAc,SAAQ,QAAQ;IACzC,YAAY,UAAkB,2BAA2B;QACvD,KAAK,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IACtB,CAAC;CACF;AAJD,sCAIC"}
</file>

<file path="server/dist/utils/cloudinary.util.d.ts">
import { UploadApiResponse } from "cloudinary";
export declare const uploadToCloudinary: (file: Express.Multer.File, folder?: string) => Promise<UploadApiResponse>;
export declare const deleteFromCloudinary: (publicId: string) => Promise<void>;
export declare const getPublicIdFromUrl: (url: string) => string;
//# sourceMappingURL=cloudinary.util.d.ts.map
</file>

<file path="server/dist/utils/cloudinary.util.d.ts.map">
{"version":3,"file":"cloudinary.util.d.ts","sourceRoot":"","sources":["../../src/utils/cloudinary.util.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,iBAAiB,EAAE,MAAM,YAAY,CAAC;AAK/C,eAAO,MAAM,kBAAkB,GAC7B,MAAM,OAAO,CAAC,MAAM,CAAC,IAAI,EACzB,SAAQ,MAA2B,KAClC,OAAO,CAAC,iBAAiB,CAW3B,CAAC;AAKF,eAAO,MAAM,oBAAoB,GAAU,UAAU,MAAM,KAAG,OAAO,CAAC,IAAI,CAMzE,CAAC;AAKF,eAAO,MAAM,kBAAkB,GAAI,KAAK,MAAM,KAAG,MAKhD,CAAC"}
</file>

<file path="server/dist/utils/cloudinary.util.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicIdFromUrl = exports.deleteFromCloudinary = exports.uploadToCloudinary = void 0;
const cloudinary_config_1 = __importDefault(require("../config/cloudinary.config"));
const uploadToCloudinary = async (file, folder = "chat-app/avatars") => {
    return new Promise((resolve, reject) => {
        const upload = cloudinary_config_1.default.uploader.upload_stream({ folder, resource_type: "auto" }, (error, result) => {
            if (error)
                reject(error);
            else
                resolve(result);
        });
        upload.end(file.buffer);
    });
};
exports.uploadToCloudinary = uploadToCloudinary;
const deleteFromCloudinary = async (publicId) => {
    try {
        await cloudinary_config_1.default.uploader.destroy(publicId);
    }
    catch (error) {
        console.error("Error deleting from Cloudinary:", error);
    }
};
exports.deleteFromCloudinary = deleteFromCloudinary;
const getPublicIdFromUrl = (url) => {
    const parts = url.split("/");
    const filename = parts[parts.length - 1].split(".")[0];
    const folder = parts[parts.length - 2];
    return `${folder}/${filename}`;
};
exports.getPublicIdFromUrl = getPublicIdFromUrl;
//# sourceMappingURL=cloudinary.util.js.map
</file>

<file path="server/dist/utils/cloudinary.util.js.map">
{"version":3,"file":"cloudinary.util.js","sourceRoot":"","sources":["../../src/utils/cloudinary.util.ts"],"names":[],"mappings":";;;;;;AAAA,oFAAqD;AAM9C,MAAM,kBAAkB,GAAG,KAAK,EACrC,IAAyB,EACzB,SAAiB,kBAAkB,EACP,EAAE;IAC9B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,MAAM,MAAM,GAAG,2BAAU,CAAC,QAAQ,CAAC,aAAa,CAC9C,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,EACjC,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE;YAChB,IAAI,KAAK;gBAAE,MAAM,CAAC,KAAK,CAAC,CAAC;;gBACpB,OAAO,CAAC,MAAO,CAAC,CAAC;QACxB,CAAC,CACF,CAAC;QACF,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAdW,QAAA,kBAAkB,sBAc7B;AAKK,MAAM,oBAAoB,GAAG,KAAK,EAAE,QAAgB,EAAiB,EAAE;IAC5E,IAAI,CAAC;QACH,MAAM,2BAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO,CAAC,KAAK,CAAC,iCAAiC,EAAE,KAAK,CAAC,CAAC;IAC1D,CAAC;AACH,CAAC,CAAC;AANW,QAAA,oBAAoB,wBAM/B;AAKK,MAAM,kBAAkB,GAAG,CAAC,GAAW,EAAU,EAAE;IACxD,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC7B,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACvD,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvC,OAAO,GAAG,MAAM,IAAI,QAAQ,EAAE,CAAC;AACjC,CAAC,CAAC;AALW,QAAA,kBAAkB,sBAK7B"}
</file>

<file path="server/dist/utils/email.util.d.ts">
export declare const initializeEmailService: () => void;
export interface EmailOptions {
    to: string;
    subject: string;
    html: string;
    text?: string;
}
export declare const sendEmail: (options: EmailOptions) => Promise<void>;
export declare const sendVerificationEmail: (email: string, verificationToken: string, verificationLink: string, name?: string) => Promise<void>;
export declare const sendPasswordResetEmail: (email: string, resetToken: string, resetLink: string, name?: string) => Promise<void>;
export declare const sendWelcomeEmail: (email: string, name: string) => Promise<void>;
//# sourceMappingURL=email.util.d.ts.map
</file>

<file path="server/dist/utils/email.util.d.ts.map">
{"version":3,"file":"email.util.d.ts","sourceRoot":"","sources":["../../src/utils/email.util.ts"],"names":[],"mappings":"AAYA,eAAO,MAAM,sBAAsB,QAAO,IAezC,CAAC;AAKF,MAAM,WAAW,YAAY;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,MAAM,CAAC;CACf;AAKD,eAAO,MAAM,SAAS,GAAU,SAAS,YAAY,KAAG,OAAO,CAAC,IAAI,CAoBnE,CAAC;AAKF,eAAO,MAAM,qBAAqB,GAChC,OAAO,MAAM,EACb,mBAAmB,MAAM,EACzB,kBAAkB,MAAM,EACxB,OAAO,MAAM,KACZ,OAAO,CAAC,IAAI,CAWd,CAAC;AAKF,eAAO,MAAM,sBAAsB,GACjC,OAAO,MAAM,EACb,YAAY,MAAM,EAClB,WAAW,MAAM,EACjB,OAAO,MAAM,KACZ,OAAO,CAAC,IAAI,CAWd,CAAC;AAKF,eAAO,MAAM,gBAAgB,GAC3B,OAAO,MAAM,EACb,MAAM,MAAM,KACX,OAAO,CAAC,IAAI,CAQd,CAAC"}
</file>

<file path="server/dist/utils/email.util.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendWelcomeEmail = exports.sendPasswordResetEmail = exports.sendVerificationEmail = exports.sendEmail = exports.initializeEmailService = void 0;
const nodemailer_1 = __importDefault(require("nodemailer"));
const env_config_1 = require("../config/env.config");
const email_templates_1 = require("./templates/email.templates");
let transporter;
const initializeEmailService = () => {
    try {
        transporter = nodemailer_1.default.createTransport({
            service: env_config_1.config.EMAIL_SERVICE,
            auth: {
                user: env_config_1.config.EMAIL_USER,
                pass: env_config_1.config.EMAIL_PASSWORD,
            },
        });
        console.log("‚úÖ Email service initialized successfully");
    }
    catch (error) {
        console.error("‚ùå Failed to initialize email service:", error);
        throw new Error("Email service initialization failed");
    }
};
exports.initializeEmailService = initializeEmailService;
const sendEmail = async (options) => {
    try {
        if (!transporter) {
            (0, exports.initializeEmailService)();
        }
        const mailOptions = {
            from: env_config_1.config.EMAIL_FROM,
            to: options.to,
            subject: options.subject,
            html: options.html,
            text: options.text || "",
        };
        await transporter.sendMail(mailOptions);
        console.log(`‚úÖ Email sent to ${options.to}`);
    }
    catch (error) {
        console.error("‚ùå Failed to send email:", error);
        throw new Error("Failed to send email");
    }
};
exports.sendEmail = sendEmail;
const sendVerificationEmail = async (email, verificationToken, verificationLink, name) => {
    const html = email_templates_1.emailTemplates.verificationEmail(name || email.split("@")[0], verificationLink);
    await (0, exports.sendEmail)({
        to: email,
        subject: "Verify Your Email Address",
        html,
    });
};
exports.sendVerificationEmail = sendVerificationEmail;
const sendPasswordResetEmail = async (email, resetToken, resetLink, name) => {
    const html = email_templates_1.emailTemplates.passwordResetEmail(name || email.split("@")[0], resetLink);
    await (0, exports.sendEmail)({
        to: email,
        subject: "Password Reset Request",
        html,
    });
};
exports.sendPasswordResetEmail = sendPasswordResetEmail;
const sendWelcomeEmail = async (email, name) => {
    const html = email_templates_1.emailTemplates.welcomeEmail(name);
    await (0, exports.sendEmail)({
        to: email,
        subject: "Welcome to our platform",
        html,
    });
};
exports.sendWelcomeEmail = sendWelcomeEmail;
//# sourceMappingURL=email.util.js.map
</file>

<file path="server/dist/utils/email.util.js.map">
{"version":3,"file":"email.util.js","sourceRoot":"","sources":["../../src/utils/email.util.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/utils/jwt.util.d.ts">
export interface TokenPayload {
    userId: string;
    email: string;
    role?: string;
    iat?: number;
    exp?: number;
}
export interface DecodedToken extends TokenPayload {
    iat: number;
    exp: number;
}
export interface AuthTokens {
    accessToken: string;
    refreshToken: string;
}
export declare const generateAccessToken: (payload: Omit<TokenPayload, "iat" | "exp">) => string;
export declare const generateRefreshToken: (payload: Omit<TokenPayload, "iat" | "exp">) => string;
export declare const generateAuthTokens: (payload: Omit<TokenPayload, "iat" | "exp">) => AuthTokens;
export declare const verifyAccessToken: (token: string) => DecodedToken;
export declare const verifyRefreshToken: (token: string) => DecodedToken;
export declare const refreshAccessToken: (refreshToken: string) => AuthTokens;
export declare const decodeToken: (token: string) => DecodedToken | null;
//# sourceMappingURL=jwt.util.d.ts.map
</file>

<file path="server/dist/utils/jwt.util.d.ts.map">
{"version":3,"file":"jwt.util.d.ts","sourceRoot":"","sources":["../../src/utils/jwt.util.ts"],"names":[],"mappings":"AAMA,MAAM,WAAW,YAAY;IAC3B,MAAM,EAAE,MAAM,CAAC;IACf,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;CACd;AAED,MAAM,WAAW,YAAa,SAAQ,YAAY;IAChD,GAAG,EAAE,MAAM,CAAC;IACZ,GAAG,EAAE,MAAM,CAAC;CACb;AAED,MAAM,WAAW,UAAU;IACzB,WAAW,EAAE,MAAM,CAAC;IACpB,YAAY,EAAE,MAAM,CAAC;CACtB;AAKD,eAAO,MAAM,mBAAmB,GAAI,SAAS,IAAI,CAAC,YAAY,EAAE,KAAK,GAAG,KAAK,CAAC,KAAG,MAYhF,CAAC;AAKF,eAAO,MAAM,oBAAoB,GAAI,SAAS,IAAI,CAAC,YAAY,EAAE,KAAK,GAAG,KAAK,CAAC,KAAG,MAYjF,CAAC;AAKF,eAAO,MAAM,kBAAkB,GAAI,SAAS,IAAI,CAAC,YAAY,EAAE,KAAK,GAAG,KAAK,CAAC,KAAG,UAK/E,CAAC;AAKF,eAAO,MAAM,iBAAiB,GAAI,OAAO,MAAM,KAAG,YAejD,CAAC;AAKF,eAAO,MAAM,kBAAkB,GAAI,OAAO,MAAM,KAAG,YAelD,CAAC;AAKF,eAAO,MAAM,kBAAkB,GAAI,cAAc,MAAM,KAAG,UAYzD,CAAC;AAKF,eAAO,MAAM,WAAW,GAAI,OAAO,MAAM,KAAG,YAAY,GAAG,IAQ1D,CAAC"}
</file>

<file path="server/dist/utils/jwt.util.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeToken = exports.refreshAccessToken = exports.verifyRefreshToken = exports.verifyAccessToken = exports.generateAuthTokens = exports.generateRefreshToken = exports.generateAccessToken = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const env_config_1 = require("../config/env.config");
const generateAccessToken = (payload) => {
    try {
        const signOptions = {
            expiresIn: env_config_1.config.JWT_EXPIRE,
            algorithm: "HS256",
        };
        const token = jsonwebtoken_1.default.sign(payload, env_config_1.config.JWT_SECRET, signOptions);
        return token;
    }
    catch (error) {
        console.error("‚ùå Error generating access token:", error);
        throw new Error("Failed to generate access token");
    }
};
exports.generateAccessToken = generateAccessToken;
const generateRefreshToken = (payload) => {
    try {
        const signOptions = {
            expiresIn: env_config_1.config.JWT_REFRESH_EXPIRE,
            algorithm: "HS256",
        };
        const token = jsonwebtoken_1.default.sign(payload, env_config_1.config.JWT_REFRESH_SECRET, signOptions);
        return token;
    }
    catch (error) {
        console.error("‚ùå Error generating refresh token:", error);
        throw new Error("Failed to generate refresh token");
    }
};
exports.generateRefreshToken = generateRefreshToken;
const generateAuthTokens = (payload) => {
    return {
        accessToken: (0, exports.generateAccessToken)(payload),
        refreshToken: (0, exports.generateRefreshToken)(payload),
    };
};
exports.generateAuthTokens = generateAuthTokens;
const verifyAccessToken = (token) => {
    try {
        const verifyOptions = {
            algorithms: ["HS256"],
        };
        const decoded = jsonwebtoken_1.default.verify(token, env_config_1.config.JWT_SECRET, verifyOptions);
        return decoded;
    }
    catch (error) {
        if (error instanceof jsonwebtoken_1.default.TokenExpiredError) {
            throw new Error("Access token has expired");
        }
        else if (error instanceof jsonwebtoken_1.default.JsonWebTokenError) {
            throw new Error("Invalid access token");
        }
        throw error;
    }
};
exports.verifyAccessToken = verifyAccessToken;
const verifyRefreshToken = (token) => {
    try {
        const verifyOptions = {
            algorithms: ["HS256"],
        };
        const decoded = jsonwebtoken_1.default.verify(token, env_config_1.config.JWT_REFRESH_SECRET, verifyOptions);
        return decoded;
    }
    catch (error) {
        if (error instanceof jsonwebtoken_1.default.TokenExpiredError) {
            throw new Error("Refresh token has expired");
        }
        else if (error instanceof jsonwebtoken_1.default.JsonWebTokenError) {
            throw new Error("Invalid refresh token");
        }
        throw error;
    }
};
exports.verifyRefreshToken = verifyRefreshToken;
const refreshAccessToken = (refreshToken) => {
    try {
        const decoded = (0, exports.verifyRefreshToken)(refreshToken);
        const newTokens = (0, exports.generateAuthTokens)({
            userId: decoded.userId,
            email: decoded.email,
        });
        return newTokens;
    }
    catch (error) {
        console.error("‚ùå Error refreshing token:", error);
        throw new Error("Failed to refresh access token");
    }
};
exports.refreshAccessToken = refreshAccessToken;
const decodeToken = (token) => {
    try {
        const decoded = jsonwebtoken_1.default.decode(token);
        return decoded;
    }
    catch (error) {
        console.error("‚ùå Error decoding token:", error);
        return null;
    }
};
exports.decodeToken = decodeToken;
//# sourceMappingURL=jwt.util.js.map
</file>

<file path="server/dist/utils/jwt.util.js.map">
{"version":3,"file":"jwt.util.js","sourceRoot":"","sources":["../../src/utils/jwt.util.ts"],"names":[],"mappings":"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"}
</file>

<file path="server/dist/utils/response.util.d.ts">
import { Response } from "express";
export interface ApiResponse<T = any> {
    success: boolean;
    message: string;
    data: T | null;
    timestamp: string;
}
export declare const sendResponse: <T = any>(res: Response, statusCode: number, message: string, data?: T | null) => Response;
export declare const sendError: (res: Response, statusCode: number, message: string, error?: any) => Response;
//# sourceMappingURL=response.util.d.ts.map
</file>

<file path="server/dist/utils/response.util.d.ts.map">
{"version":3,"file":"response.util.d.ts","sourceRoot":"","sources":["../../src/utils/response.util.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AAEnC,MAAM,WAAW,WAAW,CAAC,CAAC,GAAG,GAAG;IAClC,OAAO,EAAE,OAAO,CAAC;IACjB,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;IACf,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,eAAO,MAAM,YAAY,GAAI,CAAC,GAAG,GAAG,EAClC,KAAK,QAAQ,EACb,YAAY,MAAM,EAClB,SAAS,MAAM,EACf,OAAM,CAAC,GAAG,IAAW,KACpB,QASF,CAAC;AAEF,eAAO,MAAM,SAAS,GACpB,KAAK,QAAQ,EACb,YAAY,MAAM,EAClB,SAAS,MAAM,EACf,QAAQ,GAAG,KACV,QASF,CAAC"}
</file>

<file path="server/dist/utils/response.util.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendError = exports.sendResponse = void 0;
const sendResponse = (res, statusCode, message, data = null) => {
    const response = {
        success: statusCode >= 200 && statusCode < 300,
        message,
        data,
        timestamp: new Date().toISOString(),
    };
    return res.status(statusCode).json(response);
};
exports.sendResponse = sendResponse;
const sendError = (res, statusCode, message, error) => {
    const response = {
        success: false,
        message,
        data: error || null,
        timestamp: new Date().toISOString(),
    };
    return res.status(statusCode).json(response);
};
exports.sendError = sendError;
//# sourceMappingURL=response.util.js.map
</file>

<file path="server/dist/utils/response.util.js.map">
{"version":3,"file":"response.util.js","sourceRoot":"","sources":["../../src/utils/response.util.ts"],"names":[],"mappings":";;;AASO,MAAM,YAAY,GAAG,CAC1B,GAAa,EACb,UAAkB,EAClB,OAAe,EACf,OAAiB,IAAI,EACX,EAAE;IACZ,MAAM,QAAQ,GAAmB;QAC/B,OAAO,EAAE,UAAU,IAAI,GAAG,IAAI,UAAU,GAAG,GAAG;QAC9C,OAAO;QACP,IAAI;QACJ,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;KACpC,CAAC;IAEF,OAAO,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/C,CAAC,CAAC;AAdW,QAAA,YAAY,gBAcvB;AAEK,MAAM,SAAS,GAAG,CACvB,GAAa,EACb,UAAkB,EAClB,OAAe,EACf,KAAW,EACD,EAAE;IACZ,MAAM,QAAQ,GAAgB;QAC5B,OAAO,EAAE,KAAK;QACd,OAAO;QACP,IAAI,EAAE,KAAK,IAAI,IAAI;QACnB,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;KACpC,CAAC;IAEF,OAAO,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/C,CAAC,CAAC;AAdW,QAAA,SAAS,aAcpB"}
</file>

<file path="server/dist/utils/templates/email.templates.d.ts">
export declare const emailTemplates: {
    verificationEmail: (name: string, verificationLink: string) => string;
    welcomeEmail: (name: string) => string;
    passwordResetEmail: (name: string, resetLink: string) => string;
};
//# sourceMappingURL=email.templates.d.ts.map
</file>

<file path="server/dist/utils/templates/email.templates.d.ts.map">
{"version":3,"file":"email.templates.d.ts","sourceRoot":"","sources":["../../../src/utils/templates/email.templates.ts"],"names":[],"mappings":"AAKA,eAAO,MAAM,cAAc;8BAIC,MAAM,oBAAoB,MAAM,KAAG,MAAM;yBA4I9C,MAAM,KAAG,MAAM;+BA6HT,MAAM,aAAa,MAAM,KAAG,MAAM;CA8I9D,CAAC"}
</file>

<file path="server/dist/utils/templates/email.templates.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.emailTemplates = void 0;
exports.emailTemplates = {
    verificationEmail: (name, verificationLink) => `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Email Verification</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica',
            'Arial', sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          background-color: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background-color: #f9f9f9;
          padding: 40px 20px;
          text-align: center;
          border-bottom: 1px solid #e0e0e0;
        }
        .header h1 {
          font-size: 28px;
          color: #333333;
          font-weight: 600;
        }
        .content {
          padding: 40px 20px;
        }
        .content p {
          color: #666666;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 20px;
        }
        .content strong {
          color: #333333;
        }
        .button-container {
          text-align: center;
          margin: 30px 0;
        }
        .button {
          display: inline-block;
          padding: 14px 40px;
          background-color: #333333;
          color: #ffffff;
          text-decoration: none;
          border-radius: 6px;
          font-size: 16px;
          font-weight: 600;
          transition: background-color 0.3s ease;
        }
        .button:hover {
          background-color: #1a1a1a;
        }
        .link-section {
          background-color: #f9f9f9;
          padding: 20px;
          border-radius: 6px;
          margin-top: 20px;
          border-left: 4px solid #333333;
        }
        .link-section p {
          margin-bottom: 10px;
          font-size: 14px;
        }
        .link-section a {
          color: #333333;
          word-break: break-all;
          text-decoration: none;
        }
        .footer {
          background-color: #f9f9f9;
          padding: 20px;
          text-align: center;
          border-top: 1px solid #e0e0e0;
          font-size: 12px;
          color: #999999;
        }
        .footer p {
          margin-bottom: 8px;
        }
        .expiry-warning {
          color: #d9534f;
          font-size: 12px;
          margin-top: 10px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Verify Your Email</h1>
        </div>
        <div class="content">
          <p>Hi <strong>${name}</strong>,</p>
          <p>Thank you for registering! To complete your account setup, please verify your email address by clicking the button below.</p>
          
          <div class="button-container">
            <a href="${verificationLink}" class="button">Verify Email Address</a>
          </div>
          
          <p>Or copy and paste this link in your browser:</p>
          <div class="link-section">
            <a href="${verificationLink}">${verificationLink}</a>
            <p class="expiry-warning">This link will expire in 24 hours.</p>
          </div>
          
          <p style="margin-top: 30px; font-size: 14px; color: #999999;">
            If you didn't create this account, please ignore this email or contact support.
          </p>
        </div>
        <div class="footer">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
          <p>Need help? Contact our support team</p>
        </div>
      </div>
    </body>
    </html>
  `,
    welcomeEmail: (name) => `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Welcome</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica',
            'Arial', sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          background-color: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background-color: #f9f9f9;
          padding: 40px 20px;
          text-align: center;
          border-bottom: 1px solid #e0e0e0;
        }
        .header h1 {
          font-size: 28px;
          color: #333333;
          font-weight: 600;
        }
        .content {
          padding: 40px 20px;
        }
        .content p {
          color: #666666;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 20px;
        }
        .content strong {
          color: #333333;
        }
        .features {
          list-style: none;
          padding: 20px 0;
        }
        .features li {
          padding: 12px 0;
          color: #666666;
          border-bottom: 1px solid #f0f0f0;
          display: flex;
          align-items: center;
        }
        .features li:last-child {
          border-bottom: none;
        }
        .features li::before {
          content: "‚úì";
          color: #333333;
          font-weight: bold;
          margin-right: 12px;
          font-size: 18px;
        }
        .footer {
          background-color: #f9f9f9;
          padding: 20px;
          text-align: center;
          border-top: 1px solid #e0e0e0;
          font-size: 12px;
          color: #999999;
        }
        .footer p {
          margin-bottom: 8px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Welcome!</h1>
        </div>
        <div class="content">
          <p>Hi <strong>${name}</strong>,</p>
          <p>Your email has been verified and your account is now active. Welcome to our community!</p>
          
          <p>You can now:</p>
          <ul class="features">
            <li>Log in to your account</li>
            <li>Start using our services</li>
            <li>Connect with other users</li>
            <li>Access exclusive features</li>
          </ul>
          
          <p style="margin-top: 30px;">
            If you have any questions or need assistance, please don't hesitate to contact our support team.
          </p>
          
          <p style="margin-top: 20px;">
            Happy to have you on board!<br>
            <strong>The Team</strong>
          </p>
        </div>
        <div class="footer">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
          <p>Need help? Contact our support team</p>
        </div>
      </div>
    </body>
    </html>
  `,
    passwordResetEmail: (name, resetLink) => `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Password Reset Request</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica',
            'Arial', sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          background-color: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background-color: #f9f9f9;
          padding: 40px 20px;
          text-align: center;
          border-bottom: 1px solid #e0e0e0;
        }
        .header h1 {
          font-size: 28px;
          color: #333333;
          font-weight: 600;
        }
        .content {
          padding: 40px 20px;
        }
        .content p {
          color: #666666;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 20px;
        }
        .content strong {
          color: #333333;
        }
        .button-container {
          text-align: center;
          margin: 30px 0;
        }
        .button {
          display: inline-block;
          padding: 14px 40px;
          background-color: #333333;
          color: #ffffff;
          text-decoration: none;
          border-radius: 6px;
          font-size: 16px;
          font-weight: 600;
          transition: background-color 0.3s ease;
        }
        .button:hover {
          background-color: #1a1a1a;
        }
        .link-section {
          background-color: #f9f9f9;
          padding: 20px;
          border-radius: 6px;
          margin-top: 20px;
          border-left: 4px solid #333333;
        }
        .link-section p {
          margin-bottom: 10px;
          font-size: 14px;
        }
        .link-section a {
          color: #333333;
          word-break: break-all;
          text-decoration: none;
        }
        .warning {
          background-color: #fef5f5;
          padding: 15px;
          border-left: 4px solid #d9534f;
          margin-top: 20px;
          border-radius: 4px;
        }
        .warning p {
          color: #c9302c;
          font-size: 14px;
        }
        .footer {
          background-color: #f9f9f9;
          padding: 20px;
          text-align: center;
          border-top: 1px solid #e0e0e0;
          font-size: 12px;
          color: #999999;
        }
        .footer p {
          margin-bottom: 8px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Reset Your Password</h1>
        </div>
        <div class="content">
          <p>Hi <strong>${name}</strong>,</p>
          <p>We received a request to reset your password. Click the button below to create a new password.</p>
          
          <div class="button-container">
            <a href="${resetLink}" class="button">Reset Password</a>
          </div>
          
          <p>Or copy and paste this link in your browser:</p>
          <div class="link-section">
            <a href="${resetLink}">${resetLink}</a>
            <p style="margin-top: 10px; font-size: 12px; color: #999999;">This link will expire in 1 hour.</p>
          </div>
          
          <div class="warning">
            <p><strong>‚ö† Security Notice:</strong> If you didn't request this password reset, please ignore this email or contact support immediately.</p>
          </div>
        </div>
        <div class="footer">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
          <p>Need help? Contact our support team</p>
        </div>
      </div>
    </body>
    </html>
  `,
};
//# sourceMappingURL=email.templates.js.map
</file>

<file path="server/dist/utils/templates/email.templates.js.map">
{"version":3,"file":"email.templates.js","sourceRoot":"","sources":["../../../src/utils/templates/email.templates.ts"],"names":[],"mappings":";;;AAKa,QAAA,cAAc,GAAG;IAI5B,iBAAiB,EAAE,CAAC,IAAY,EAAE,gBAAwB,EAAU,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA+G/C,IAAI;;;;uBAIP,gBAAgB;;;;;uBAKhB,gBAAgB,KAAK,gBAAgB;;;;;;;;;;;;;;;GAezD;IAKD,YAAY,EAAE,CAAC,IAAY,EAAU,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA6FhB,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2B3B;IAKD,kBAAkB,EAAE,CAAC,IAAY,EAAE,SAAiB,EAAU,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAqHzC,IAAI;;;;uBAIP,SAAS;;;;;uBAKT,SAAS,KAAK,SAAS;;;;;;;;;;;;;;;GAe3C;CACF,CAAC"}
</file>

<file path="server/package.json">
{
  "name": "server",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "watch": "tsc -w",
    "lint": "eslint src --ext .ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@prisma/client": "^6.19.0",
    "bcrypt": "^6.0.0",
    "cloudinary": "^2.8.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "express-session": "^1.18.2",
    "express-validator": "^7.3.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.10",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "prisma": "^6.19.0",
    "sharp": "^0.34.5",
    "socket.io": "^4.8.1",
    "uuid": "^13.0.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cookie-parser": "^1.4.3",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/express-session": "^1.18.2",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/multer": "^2.0.0",
    "@types/node": "^24.10.1",
    "@types/nodemailer": "^7.0.4",
    "@types/passport": "^1.0.17",
    "@types/passport-google-oauth20": "^2.0.17",
    "nodemon": "^3.1.11",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="server/prisma/migrations/20251124110710_add_refresh_token/migration.sql">
-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT,
    "avatar" TEXT,
    "bio" TEXT,
    "status" TEXT NOT NULL DEFAULT 'offline',
    "emailVerified" BOOLEAN NOT NULL DEFAULT false,
    "refreshToken" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "email_verifications" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "email_verifications_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "sessions" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "refreshToken" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "sessions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "friend_requests" (
    "id" TEXT NOT NULL,
    "senderId" TEXT NOT NULL,
    "receiverId" TEXT NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'pending',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "friend_requests_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "friends" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "friendId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "friends_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "conversations" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "type" TEXT NOT NULL DEFAULT 'direct',
    "createdBy" TEXT NOT NULL,
    "lastMessageAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "conversations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "conversation_participants" (
    "id" TEXT NOT NULL,
    "conversationId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "joinedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "conversation_participants_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "messages" (
    "id" TEXT NOT NULL,
    "conversationId" TEXT NOT NULL,
    "senderId" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "fileUrl" TEXT,
    "fileType" TEXT,
    "isEdited" BOOLEAN NOT NULL DEFAULT false,
    "editedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "messages_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE INDEX "users_email_idx" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "email_verifications_token_key" ON "email_verifications"("token");

-- CreateIndex
CREATE INDEX "email_verifications_userId_idx" ON "email_verifications"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "sessions_refreshToken_key" ON "sessions"("refreshToken");

-- CreateIndex
CREATE INDEX "sessions_userId_idx" ON "sessions"("userId");

-- CreateIndex
CREATE INDEX "friend_requests_senderId_idx" ON "friend_requests"("senderId");

-- CreateIndex
CREATE INDEX "friend_requests_receiverId_idx" ON "friend_requests"("receiverId");

-- CreateIndex
CREATE UNIQUE INDEX "friend_requests_senderId_receiverId_key" ON "friend_requests"("senderId", "receiverId");

-- CreateIndex
CREATE INDEX "friends_userId_idx" ON "friends"("userId");

-- CreateIndex
CREATE INDEX "friends_friendId_idx" ON "friends"("friendId");

-- CreateIndex
CREATE UNIQUE INDEX "friends_userId_friendId_key" ON "friends"("userId", "friendId");

-- CreateIndex
CREATE INDEX "conversations_createdBy_idx" ON "conversations"("createdBy");

-- CreateIndex
CREATE INDEX "conversation_participants_conversationId_idx" ON "conversation_participants"("conversationId");

-- CreateIndex
CREATE UNIQUE INDEX "conversation_participants_conversationId_userId_key" ON "conversation_participants"("conversationId", "userId");

-- CreateIndex
CREATE INDEX "messages_conversationId_idx" ON "messages"("conversationId");

-- CreateIndex
CREATE INDEX "messages_senderId_idx" ON "messages"("senderId");

-- AddForeignKey
ALTER TABLE "email_verifications" ADD CONSTRAINT "email_verifications_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "sessions" ADD CONSTRAINT "sessions_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "friend_requests" ADD CONSTRAINT "friend_requests_senderId_fkey" FOREIGN KEY ("senderId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "friend_requests" ADD CONSTRAINT "friend_requests_receiverId_fkey" FOREIGN KEY ("receiverId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "friends" ADD CONSTRAINT "friends_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "friends" ADD CONSTRAINT "friends_friendId_fkey" FOREIGN KEY ("friendId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "conversations" ADD CONSTRAINT "conversations_createdBy_fkey" FOREIGN KEY ("createdBy") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "conversation_participants" ADD CONSTRAINT "conversation_participants_conversationId_fkey" FOREIGN KEY ("conversationId") REFERENCES "conversations"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "messages" ADD CONSTRAINT "messages_conversationId_fkey" FOREIGN KEY ("conversationId") REFERENCES "conversations"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "messages" ADD CONSTRAINT "messages_senderId_fkey" FOREIGN KEY ("senderId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="server/prisma/migrations/20251125084108_add_password_reset_model/migration.sql">
-- CreateTable
CREATE TABLE "password_resets" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "password_resets_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "password_resets_token_key" ON "password_resets"("token");

-- CreateIndex
CREATE INDEX "password_resets_userId_idx" ON "password_resets"("userId");

-- AddForeignKey
ALTER TABLE "password_resets" ADD CONSTRAINT "password_resets_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="server/prisma/migrations/20251125085636_add_user_role/migration.sql">
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'USER');

-- AlterTable
ALTER TABLE "users" ADD COLUMN     "role" "UserRole" NOT NULL DEFAULT 'USER';
</file>

<file path="server/prisma/migrations/20251126085837_add_google_oauth/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[googleId]` on the table `users` will be added. If there are existing duplicate values, this will fail.

*/
-- AlterTable
ALTER TABLE "users" ADD COLUMN     "googleId" TEXT,
ALTER COLUMN "password" DROP NOT NULL;

-- CreateIndex
CREATE UNIQUE INDEX "users_googleId_key" ON "users"("googleId");
</file>

<file path="server/prisma/migrations/20251213091718_add_chat_system/migration.sql">
/*
  Warnings:

  - You are about to drop the column `createdBy` on the `conversations` table. All the data in the column will be lost.
  - The `type` column on the `conversations` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - You are about to drop the column `fileType` on the `messages` table. All the data in the column will be lost.
  - You are about to drop the column `fileUrl` on the `messages` table. All the data in the column will be lost.
  - Added the required column `createdById` to the `conversations` table without a default value. This is not possible if the table is not empty.

*/
-- CreateEnum
CREATE TYPE "ConversationType" AS ENUM ('PRIVATE', 'GROUP');

-- CreateEnum
CREATE TYPE "ParticipantRole" AS ENUM ('ADMIN', 'MODERATOR', 'MEMBER');

-- CreateEnum
CREATE TYPE "MessageType" AS ENUM ('TEXT', 'IMAGE', 'VIDEO', 'FILE', 'SYSTEM_MESSAGE');

-- CreateEnum
CREATE TYPE "MessageStatus" AS ENUM ('SENT', 'DELIVERED', 'READ', 'FAILED');

-- CreateEnum
CREATE TYPE "CallType" AS ENUM ('AUDIO', 'VIDEO');

-- CreateEnum
CREATE TYPE "CallStatus" AS ENUM ('INITIATING', 'RINGING', 'ACTIVE', 'ENDED', 'DECLINED', 'MISSED', 'CANCELED');

-- DropForeignKey
ALTER TABLE "conversations" DROP CONSTRAINT "conversations_createdBy_fkey";

-- DropForeignKey
ALTER TABLE "friends" DROP CONSTRAINT "friends_friendId_fkey";

-- DropIndex
DROP INDEX "conversations_createdBy_idx";

-- AlterTable
ALTER TABLE "conversation_participants" ADD COLUMN     "isArchived" BOOLEAN NOT NULL DEFAULT false,
ADD COLUMN     "isMuted" BOOLEAN NOT NULL DEFAULT false,
ADD COLUMN     "lastReadAt" TIMESTAMP(3),
ADD COLUMN     "leftAt" TIMESTAMP(3),
ADD COLUMN     "role" "ParticipantRole" NOT NULL DEFAULT 'MEMBER';

-- AlterTable
ALTER TABLE "conversations" DROP COLUMN "createdBy",
ADD COLUMN     "avatar" TEXT,
ADD COLUMN     "createdById" TEXT NOT NULL,
ADD COLUMN     "description" TEXT,
ADD COLUMN     "isArchived" BOOLEAN NOT NULL DEFAULT false,
DROP COLUMN "type",
ADD COLUMN     "type" "ConversationType" NOT NULL DEFAULT 'PRIVATE';

-- AlterTable
ALTER TABLE "messages" DROP COLUMN "fileType",
DROP COLUMN "fileUrl",
ADD COLUMN     "editedContent" TEXT,
ADD COLUMN     "mediaUrls" TEXT[],
ADD COLUMN     "status" "MessageStatus" NOT NULL DEFAULT 'SENT',
ADD COLUMN     "type" "MessageType" NOT NULL DEFAULT 'TEXT';

-- CreateTable
CREATE TABLE "message_reads" (
    "id" TEXT NOT NULL,
    "messageId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "readAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "message_reads_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "message_reactions" (
    "id" TEXT NOT NULL,
    "messageId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "emoji" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "message_reactions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "calls" (
    "id" TEXT NOT NULL,
    "conversationId" TEXT NOT NULL,
    "callerId" TEXT NOT NULL,
    "receiverId" TEXT,
    "type" "CallType" NOT NULL DEFAULT 'AUDIO',
    "status" "CallStatus" NOT NULL DEFAULT 'INITIATING',
    "duration" INTEGER,
    "participants" TEXT[],
    "startedAt" TIMESTAMP(3),
    "endedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "calls_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "message_reads_userId_idx" ON "message_reads"("userId");

-- CreateIndex
CREATE INDEX "message_reads_messageId_idx" ON "message_reads"("messageId");

-- CreateIndex
CREATE UNIQUE INDEX "message_reads_messageId_userId_key" ON "message_reads"("messageId", "userId");

-- CreateIndex
CREATE INDEX "message_reactions_messageId_idx" ON "message_reactions"("messageId");

-- CreateIndex
CREATE INDEX "message_reactions_userId_idx" ON "message_reactions"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "message_reactions_messageId_userId_emoji_key" ON "message_reactions"("messageId", "userId", "emoji");

-- CreateIndex
CREATE INDEX "calls_conversationId_idx" ON "calls"("conversationId");

-- CreateIndex
CREATE INDEX "calls_callerId_idx" ON "calls"("callerId");

-- CreateIndex
CREATE INDEX "calls_receiverId_idx" ON "calls"("receiverId");

-- CreateIndex
CREATE INDEX "calls_createdAt_idx" ON "calls"("createdAt");

-- CreateIndex
CREATE INDEX "conversation_participants_userId_idx" ON "conversation_participants"("userId");

-- CreateIndex
CREATE INDEX "conversations_type_idx" ON "conversations"("type");

-- CreateIndex
CREATE INDEX "conversations_createdById_idx" ON "conversations"("createdById");

-- CreateIndex
CREATE INDEX "conversations_createdAt_idx" ON "conversations"("createdAt");

-- CreateIndex
CREATE INDEX "messages_createdAt_idx" ON "messages"("createdAt");

-- AddForeignKey
ALTER TABLE "conversations" ADD CONSTRAINT "conversations_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "conversation_participants" ADD CONSTRAINT "conversation_participants_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "message_reads" ADD CONSTRAINT "message_reads_messageId_fkey" FOREIGN KEY ("messageId") REFERENCES "messages"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "message_reads" ADD CONSTRAINT "message_reads_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "message_reactions" ADD CONSTRAINT "message_reactions_messageId_fkey" FOREIGN KEY ("messageId") REFERENCES "messages"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "message_reactions" ADD CONSTRAINT "message_reactions_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "calls" ADD CONSTRAINT "calls_conversationId_fkey" FOREIGN KEY ("conversationId") REFERENCES "conversations"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "calls" ADD CONSTRAINT "calls_callerId_fkey" FOREIGN KEY ("callerId") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "calls" ADD CONSTRAINT "calls_receiverId_fkey" FOREIGN KEY ("receiverId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="server/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="server/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  USER
}

enum ConversationType {
  PRIVATE
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  SYSTEM_MESSAGE
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  FAILED
}

enum CallType {
  AUDIO
  VIDEO
}

enum CallStatus {
  INITIATING
  RINGING
  ACTIVE
  ENDED
  DECLINED
  MISSED
  CANCELED
}

// User Model
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String?
  name      String?
  avatar    String?
  bio       String?
  role      UserRole @default(USER)
  status    String   @default("offline") // online, offline, away
  emailVerified Boolean @default(false)
  refreshToken String?
  googleId  String?  @unique // For Google OAuth
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - Authentication
  emailVerifications EmailVerification[]
  sessions      Session[]
  passwordResets PasswordReset[]
  
  // Relations - Friends
  sentRequests  FriendRequest[] @relation("sentRequests")
  receivedRequests FriendRequest[] @relation("receivedRequests")
  friends       Friend[] @relation("user")
  
  // Relations - Chat & Messages
  conversationParticipants ConversationParticipant[]
  sentMessages Message[]
  messageReads MessageRead[]
  messageReactions MessageReaction[]
  
  // Relations - Calls
  calledCalls Call[] @relation("callerCalls")
  receivedCalls Call[] @relation("receiverCalls")

  @@index([email])
  @@map("users")
}

// Email Verification Model
model EmailVerification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("email_verifications")
}

// Password Reset Model
model PasswordReset {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("password_resets")
}

// Session/Refresh Token Model
model Session {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@index([userId])
  @@map("sessions")
}

// Friend Request Model
model FriendRequest {
  id        String   @id @default(cuid())
  senderId  String
  sender    User     @relation("sentRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId String
  receiver  User     @relation("receivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)
  status    String   @default("pending") // pending, accepted, rejected
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@map("friend_requests")
}

// Friend Model
model Friend {
  id       String   @id @default(cuid())
  userId   String
  user     User     @relation("user", fields: [userId], references: [id], onDelete: Cascade)
  friendId String
  createdAt DateTime @default(now())

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@map("friends")
}

// Conversation/Chat Model (Private chats only between 2 friends)
model Conversation {
  id        String   @id @default(cuid())
  
  // Relations
  participants ConversationParticipant[]
  messages  Message[]
  calls     Call[]
  
  // Metadata
  isArchived Boolean @default(false)
  lastMessageAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Indexes
  @@index([createdAt])
  @@map("conversations")
}

// Conversation Participants Model (for private chats between 2 friends)
model ConversationParticipant {
  id             String   @id @default(cuid())
  
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  userId         String
  user           User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Individual user settings
  isArchived     Boolean @default(false)
  isMuted        Boolean @default(false)
  lastReadAt     DateTime?
  
  // Metadata
  joinedAt       DateTime @default(now())
  
  // Ensure one entry per user per conversation
  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
  @@map("conversation_participants")
}

// Message Model
model Message {
  id             String   @id @default(cuid())
  
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  senderId       String
  sender         User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  // Message content
  content        String
  type           MessageType @default(TEXT)
  
  // Media/attachments
  mediaUrls      String[] // JSON array of media URLs
  
  // Message status
  status         MessageStatus @default(SENT)
  
  // Read receipts
  readBy         MessageRead[]
  
  // Reactions
  reactions      MessageReaction[]
  
  // Edit history
  isEdited       Boolean @default(false)
  editedAt       DateTime?
  editedContent  String? // Keep original for edit history
  
  // Metadata
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Indexes
  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
  @@map("messages")
}

// Message Read Receipt Model
model MessageRead {
  id             String   @id @default(cuid())
  
  messageId      String
  message        Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  userId         String
  user           User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  readAt         DateTime @default(now())
  
  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
  @@map("message_reads")
}

// Message Reaction Model
model MessageReaction {
  id             String   @id @default(cuid())
  
  messageId      String
  message        Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  userId         String
  user           User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  emoji          String // e.g., "üëç", "‚ù§Ô∏è", "üòÇ"
  
  createdAt      DateTime @default(now())
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("message_reactions")
}

// Call Model (for video/audio calls)
model Call {
  id             String   @id @default(cuid())
  
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  callerId       String
  caller         User @relation("callerCalls", fields: [callerId], references: [id], onDelete: Cascade)
  
  receiverId     String?
  receiver       User? @relation("receiverCalls", fields: [receiverId], references: [id], onDelete: SetNull)
  
  // Call details
  type           CallType @default(AUDIO)
  status         CallStatus @default(INITIATING)
  duration       Int? // Duration in seconds
  
  // Metadata
  startedAt      DateTime?
  endedAt        DateTime?
  createdAt      DateTime @default(now())
  
  @@index([conversationId])
  @@index([callerId])
  @@index([receiverId])
  @@index([createdAt])
  @@map("calls")
}
</file>

<file path="server/README.md">
# üéâ Server Setup Complete!

## ‚úÖ What's Running

Your Chat App backend server is **now running** on:
- **URL:** http://localhost:5000
- **Mode:** Development (hot reload enabled)
- **WebSocket:** Ready for real-time communication

---

## üìä Complete Setup Summary

### ‚úÖ Completed Tasks

1. **Core Server Setup**
   - ‚úÖ Express.js application configured
   - ‚úÖ HTTP/Socket.IO server initialized
   - ‚úÖ Environment configuration system
   - ‚úÖ Error handling middleware
   - ‚úÖ Security middleware (CORS, Helmet)

2. **Authentication System**
   - ‚úÖ JWT token generation (Access + Refresh)
   - ‚úÖ Token verification & validation
   - ‚úÖ Authentication middleware
   - ‚úÖ 15-minute access tokens
   - ‚úÖ 7-day refresh tokens

3. **Email Service**
   - ‚úÖ Nodemailer integration (Gmail)
   - ‚úÖ Email verification service
   - ‚úÖ Password reset email template
   - ‚úÖ Welcome email template
   - ‚úÖ Custom email support

4. **Database Setup**
   - ‚úÖ Prisma ORM configured
   - ‚úÖ Complete database schema designed
   - ‚úÖ User relationships configured
   - ‚úÖ Email verification tracking
   - ‚úÖ Session management model
   - ‚úÖ Real-time messaging schema

5. **WebSocket Real-time Communication**
   - ‚úÖ Socket.IO initialized
   - ‚úÖ Room-based messaging
   - ‚úÖ User presence tracking
   - ‚úÖ Real-time event handling

6. **Development Tools**
   - ‚úÖ TypeScript configuration
   - ‚úÖ NPM scripts (dev, build, start, watch)
   - ‚úÖ ts-node for direct execution
   - ‚úÖ ESLint ready

---

## üìÅ Files Created/Modified

### New Files
```
server/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ utils/jwt.util.ts              ‚ú® NEW
‚îÇ   ‚îú‚îÄ‚îÄ middleware/auth.middleware.ts  ‚ú® NEW
‚îÇ   ‚îî‚îÄ‚îÄ services/email.service.ts      ‚ú® NEW
‚îú‚îÄ‚îÄ prisma/schema.prisma               ‚ú® NEW
‚îú‚îÄ‚îÄ JWT_EMAIL_SETUP.md                 ‚ú® NEW
‚îú‚îÄ‚îÄ SETUP_COMPLETE.md                  ‚ú® NEW
‚îî‚îÄ‚îÄ RUNNING_GUIDE.md                   ‚ú® NEW
```

### Modified Files
```
server/
‚îú‚îÄ‚îÄ .env                               üìù Updated with email credentials
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app.ts                         üìù Complete Express setup
‚îÇ   ‚îú‚îÄ‚îÄ server.ts                      üìù HTTP server with Socket.IO
‚îÇ   ‚îú‚îÄ‚îÄ config/env.config.ts           üìù Added email variables
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validate.middleware.ts     üìù Fixed Zod issues
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ error.middleware.ts        üìù Fixed Prisma error handling
‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json                  üìù Fixed for Node.js backend
‚îî‚îÄ‚îÄ package.json                       üìù Added dev scripts
```

---

## üöÄ Quick Start

### Currently Running:
```bash
npm run dev
# Server is live at http://localhost:5000
```

### Test the Server:
```bash
# In another terminal
curl http://localhost:5000/api/health
```

Expected response:
```json
{
  "success": true,
  "message": "Server is running",
  "timestamp": "2025-11-23T12:00:00.000Z"
}
```

---

## üóÑÔ∏è Database Setup (Optional but Recommended)

### PostgreSQL Setup:
```bash
# 1. Install PostgreSQL
# 2. Create database
createdb chatdb

# 3. Update .env with your credentials
# DATABASE_URL="postgresql://user:password@localhost:5432/chatdb?schema=public"

# 4. Run migrations
npx prisma migrate dev --name init

# 5. View database GUI
npx prisma studio
```

Once connected, the server will automatically use the database for authentication, messages, and real-time features.

---

## üìñ Documentation

1. **RUNNING_GUIDE.md** - How to run the server, database setup, troubleshooting
2. **JWT_EMAIL_SETUP.md** - Complete authentication flow, email examples
3. **SETUP_COMPLETE.md** - Quick reference guide

---

## üîê Security Features Implemented

‚úÖ **Access Tokens** - 15 minutes (short-lived)
‚úÖ **Refresh Tokens** - 7 days (long-lived)
‚úÖ **Separate Secrets** - Different keys for each token
‚úÖ **JWT Verification** - HS256 algorithm
‚úÖ **Error Handling** - Proper error messages
‚úÖ **Email Verification** - Verify users before access
‚úÖ **CORS Protection** - Only allow trusted origins
‚úÖ **Helmet Security** - HTTP security headers
‚úÖ **Password Hashing** - Bcrypt integration ready

---

## üéØ Architecture Overview

```
Client (Next.js Frontend)
        ‚Üì
   HTTP/WebSocket
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Express Server (Port 5000)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Middleware:                      ‚îÇ
‚îÇ ‚Ä¢ CORS & Helmet                  ‚îÇ
‚îÇ ‚Ä¢ Body Parser                    ‚îÇ
‚îÇ ‚Ä¢ Error Handling                 ‚îÇ
‚îÇ ‚Ä¢ JWT Authentication             ‚îÇ
‚îÇ ‚Ä¢ Input Validation (Zod)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Socket.IO (Real-time)           ‚îÇ
‚îÇ ‚Ä¢ Room-based messaging           ‚îÇ
‚îÇ ‚Ä¢ User presence                  ‚îÇ
‚îÇ ‚Ä¢ Event broadcasting             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Services:                        ‚îÇ
‚îÇ ‚Ä¢ Email Service (Nodemailer)     ‚îÇ
‚îÇ ‚Ä¢ JWT Service                    ‚îÇ
‚îÇ ‚Ä¢ Database (Prisma ORM)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì
   PostgreSQL Database
   (Optional but recommended)
```

---

## üìù Available Endpoints

### Health Check (No Auth Required)
```
GET /api/health
```

### Protected Endpoints (Require JWT Token)
```
Authorization: Bearer <accessToken>
```

Example:
```bash
curl http://localhost:5000/api/profile \
  -H "Authorization: Bearer eyJhbGc..."
```

---

## üõ†Ô∏è Common Development Commands

```bash
# Start server
npm run dev

# Compile TypeScript (watch mode)
npm run watch

# Build for production
npm run build

# Run production build
npm start

# Generate Prisma client
npx prisma generate

# Run database migrations
npx prisma migrate dev

# Open Prisma Studio
npx prisma studio

# Lint code
npm run lint
```

---

## üîó Integration with Frontend

When you're ready to connect the Next.js frontend:

1. **Update CLIENT_URL in .env**
   ```dotenv
   CLIENT_URL=http://localhost:3000
   ```

2. **In Next.js app, connect to backend:**
   ```typescript
   const API_BASE = 'http://localhost:5000/api'
   const WS_URL = 'http://localhost:5000'
   ```

3. **Example API call:**
   ```typescript
   const response = await fetch(`${API_BASE}/login`, {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify({ email, password })
   })
   const { accessToken, refreshToken } = await response.json()
   ```

4. **WebSocket connection:**
   ```typescript
   import io from 'socket.io-client'
   const socket = io(WS_URL)
   ```

---

## ‚ú® Features Ready to Implement

Now that the base is set up, you can create:

1. **Authentication Endpoints**
   - POST /api/auth/register
   - POST /api/auth/login
   - POST /api/auth/refresh
   - GET /api/auth/verify

2. **User Endpoints**
   - GET /api/users/:id
   - PUT /api/users/:id
   - DELETE /api/users/:id

3. **Chat Endpoints**
   - POST /api/conversations
   - GET /api/conversations
   - POST /api/messages
   - GET /api/messages/:conversationId

4. **Real-time Features**
   - Live messaging
   - User presence
   - Typing indicators
   - Read receipts

---

## üéì Learning Resources

- **Express.js:** https://expressjs.com
- **Socket.IO:** https://socket.io/docs
- **Prisma ORM:** https://www.prisma.io/docs
- **JWT:** https://jwt.io
- **TypeScript:** https://www.typescriptlang.org/docs

---

## üìû Support & Next Steps

### If you encounter issues:
1. Check RUNNING_GUIDE.md for troubleshooting
2. Ensure Node.js version is 16+
3. Run `npm install` to install dependencies
4. Check that port 5000 is not in use

### Next development priorities:
1. ‚úÖ Set up PostgreSQL
2. ‚úÖ Create auth routes (register, login)
3. ‚úÖ Create user routes
4. ‚úÖ Create chat/message routes
5. ‚úÖ Test with Postman
6. ‚úÖ Connect frontend

---

## üéâ Summary

Your Chat App backend is **fully configured and running!**

- **Server Status:** ‚úÖ Running on port 5000
- **WebSocket:** ‚úÖ Ready for real-time communication
- **Authentication:** ‚úÖ JWT system configured
- **Email Service:** ‚úÖ Ready to send verification emails
- **Database:** ‚úÖ Schema designed, ready to connect

**You're ready to start building API endpoints!** üöÄ

---

Happy coding! üíª
</file>

<file path="server/src/app.ts">
import express, { Express, Request, Response, NextFunction } from "express";
import cors from "cors";
import helmet from "helmet";
import cookieParser from "cookie-parser";
import session from "express-session";
import passport from "passport";
import { config, validateEnv } from "./config/env.config";
import { errorHandler, notFound } from "./middleware/error.middleware";
import authRoutes from "./routes/auth.route";
import googleAuthRoutes from "./routes/google-auth.route";
import userRoutes from "./routes/user.route";
import friendRoutes from "./routes/friend.route";
import conversationRoutes from "./routes/conversation.route";
import messageRoutes from "./routes/message.route";
import callRoutes from "./routes/call.route";
import "./config/google-auth.config"; 

export const app: Express = express();

validateEnv();

// Security Middleware
app.use(helmet());

// CORS Configuration
app.use(
  cors({
    origin: config.CLIENT_URL,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);

// Body Parser Middleware
app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ limit: "10kb", extended: true }));
// Cookie parser (for refresh token cookie)
app.use(cookieParser());

/**
 * Session Configuration for OAuth
 * 
 * Express-session stores user session data in memory
 * When user logs in via Google, we store their user ID in the session
 * This persists authentication across page reloads during OAuth flow
 * 
 * For production, replace MemoryStore with a database store (Redis, MongoDB, etc)
 */
app.use(
  session({
    secret: config.JWT_SECRET, // Use same secret as JWT for consistency
    resave: false, // Don't save session if unmodified
    saveUninitialized: false, // Don't create session until modified
    cookie: {
      secure: config.NODE_ENV === "production", // HTTPS only in production
      httpOnly: true, // Prevent client-side JS from accessing session cookie
      sameSite: "strict", // CSRF protection
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    },
  })
);

/**
 * Passport Middleware
 * 
 * These middleware handle:
 * 1. passport.initialize() - Initializes Passport
 * 2. passport.session() - Restores user from session on each request
 */
app.use(passport.initialize());
app.use(passport.session());

/**
 * Health Check Route
 */
app.get("/api/health", (req: Request, res: Response) => {
  res.status(200).json({
    success: true,
    message: "Server is running",
    timestamp: new Date().toISOString(),
  });
});

/**
 * API Routes
 */
// Authentication Routes (traditional email/password)
app.use("/api/v1/auth", authRoutes);

// Google OAuth Routes
app.use("/api/v1/auth", googleAuthRoutes);

// User Routes
app.use("/api/v1/users", userRoutes);

// Friend Routes
app.use("/api/v1/friends", friendRoutes);

// Conversation Routes (Chat)
app.use("/api/v1/conversations", conversationRoutes);

// Message Routes
app.use("/api/v1/messages", messageRoutes);

// Call Routes (Audio/Video calls)
app.use("/api/v1/calls", callRoutes);

/**
 * 404 Handler - Not Found
 */
app.use(notFound);

/**
 * Global Error Handler Middleware
 */
app.use(errorHandler);

export default app;
</file>

<file path="server/src/config/cloudinary.config.ts">
import { v2 as cloudinary } from "cloudinary";
import { config } from "./env.config";

cloudinary.config({
  cloud_name: config.CLOUDINARY_CLOUD_NAME,
  api_key: config.CLOUDINARY_API_KEY,
  api_secret: config.CLOUDINARY_API_SECRET,
});

export default cloudinary;
</file>

<file path="server/src/config/db.ts">
import { PrismaClient } from "@prisma/client";

// Extend NodeJS global type
declare global {
  var prisma: PrismaClient | undefined;
}

// Create Prisma Client instance
const prisma =
  global.prisma ||
  new PrismaClient({
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

// Prevent multiple instances in development
if (process.env.NODE_ENV !== "production") {
  global.prisma = prisma;
}

/**
 * Connect to database
 */
export const connectDB = async () => {
  try {
    await prisma.$connect();
    console.log("‚úÖ Database connected successfully");
  } catch (error) {
    console.error("‚ùå Database connection failed:", error);
    process.exit(1);
  }
};

/**
 * Disconnect from database
 */
export const disconnectDB = async () => {
  try {
    await prisma.$disconnect();
    console.log("‚úÖ Database disconnected successfully");
  } catch (error) {
    console.error("‚ùå Database disconnection failed:", error);
  }
};

/**
 * Health check for database
 */
export const checkDBHealth = async (): Promise<boolean> => {
  try {
    await prisma.$queryRaw`SELECT 1`;
    return true;
  } catch (error) {
    console.error("‚ùå Database health check failed:", error);
    return false;
  }
};

export default prisma;
</file>

<file path="server/src/config/env.config.ts">
import dotenv from "dotenv";

dotenv.config();

/**
 * Environment Configuration
 */
export const config = {
  // Server
  NODE_ENV: process.env.NODE_ENV || "development",
  PORT: parseInt(process.env.PORT || "5000", 10),
  SERVER_URL: process.env.SERVER_URL || "http://localhost:5000",
  CLIENT_URL: process.env.CLIENT_URL || "http://localhost:3000",

  // Database
  DATABASE_URL: process.env.DATABASE_URL,

  // JWT
  JWT_SECRET: process.env.JWT_SECRET || "your-super-secret-jwt-key",
  JWT_EXPIRE: process.env.JWT_EXPIRE || "7d",
  JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET || "your-refresh-secret",
  JWT_REFRESH_EXPIRE: process.env.JWT_REFRESH_EXPIRE || "30d",

  // File Upload
  MAX_FILE_SIZE: parseInt(process.env.MAX_FILE_SIZE || "52428800", 10), // 50MB
  UPLOAD_DIR: process.env.UPLOAD_DIR || "./uploads",

  // Bcrypt
  BCRYPT_ROUNDS: parseInt(process.env.BCRYPT_ROUNDS || "10", 10),

  // Email Service
  EMAIL_SERVICE: process.env.EMAIL_SERVICE || "gmail",
  EMAIL_USER: process.env.EMAIL_USER,
  EMAIL_PASSWORD: process.env.EMAIL_PASSWORD,
  EMAIL_FROM: process.env.EMAIL_FROM || "noreply@chatapp.com",
  VERIFICATION_EXPIRY: process.env.VERIFICATION_EXPIRY || "24h",

  // OAuth
  GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
  GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,

  // Add to existing config
  CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
  CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
  CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!,
};

/**
 * Validate required environment variables
 */
export const validateEnv = () => {
  const required = ["DATABASE_URL", "JWT_SECRET"];
  const missing = required.filter((key) => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missing.join(", ")}`
    );
  }

  console.log("‚úÖ Environment variables validated");
};
</file>

<file path="server/src/config/google-auth.config.ts">
import passport from "passport";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import prisma from "./db";
import { config } from "./env.config";

// Validate Google credentials
if (!config.GOOGLE_CLIENT_ID || !config.GOOGLE_CLIENT_SECRET) {
  console.warn("‚ö†Ô∏è  Google OAuth credentials not configured. Google authentication will not work.");
}

passport.use(
  new GoogleStrategy(
    {
      clientID: config.GOOGLE_CLIENT_ID || "not-configured",
      clientSecret: config.GOOGLE_CLIENT_SECRET || "not-configured",
      callbackURL: `${config.SERVER_URL}/api/v1/auth/google/callback`,
      passReqToCallback: false,
      scope: ["email", "profile"],
    },
    async (accessToken: string, refreshToken: string | undefined, profile: any, done: any) => {
      try {
        // Extract user info from Google profile
        const googleId = profile.id;
        const email = profile.emails?.[0]?.value;
        const name = profile.displayName;
        const avatar = profile.photos?.[0]?.value;

        if (!email) {
          return done(new Error("No email provided by Google"));
        }

        // Check if user already exists
        let user = await prisma.user.findUnique({
          where: { email },
        });

        if (user) {
          // User exists - update Google ID if not already set
          if (!user.googleId) {
            user = await prisma.user.update({
              where: { email },
              data: { googleId },
            });
          }
        } else {
          // Create new user from Google profile
          // Email is auto-verified for Google accounts
          user = await prisma.user.create({
            data: {
              email,
              name: name || email.split("@")[0],
              avatar: avatar || null,
              googleId,
              emailVerified: true, // Google email is trusted
              role: "USER", // Default role
            },
          });
        }
        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }
  )
);

passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id: string, done) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        avatar: true,
      },
    });

    done(null, user);
  } catch (error) {
    done(error);
  }
});

export default passport;
</file>

<file path="server/src/controllers/auth.controller.ts">
import { Request, Response } from "express";
import { z } from "zod";
import { AuthService } from "../services/auth.service";
import { registerSchema, loginSchema, resendVerificationSchema, forgotPasswordSchema, resetPasswordSchema } from "../dto/auth.dto";
import { asyncHandler } from "../middleware/error.middleware";

const authService = new AuthService();

export const register = asyncHandler(async (req: Request, res: Response) => {
  const parse = registerSchema.safeParse(req.body);
  if (!parse.success) {
    const errors = z.treeifyError(parse.error);
    return res.status(400).json({ success: false, errors });
  }

  const result = await authService.register(parse.data);

  return res.status(201).json({
    success: true,
    message: "User registered successfully. Please verify your email.",
    data: {
      user: result.user,
      verificationToken: result.verificationToken,
    },
  });
});

export const login = asyncHandler(async (req: Request, res: Response) => {
  const parse = loginSchema.safeParse(req.body);
  if (!parse.success) {
    const errors = z.treeifyError(parse.error);
    return res.status(400).json({ success: false, errors });
  }

  const result = await authService.login(parse.data);

  // Set refresh token as httpOnly cookie (for security - cannot be accessed by JavaScript)
  res.cookie("refreshToken", result.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days (matches JWT_REFRESH_EXPIRE)
  });

  // Return access token in response body - client will store it
  return res.status(200).json({
    success: true,
    message: "Login successful",
    data: {
      user: result.user,
      accessToken: result.accessToken,
    },
  });
});

export const verifyEmail = asyncHandler(async (req: Request, res: Response) => {
  const { token } = req.query;

  if (!token || typeof token !== "string") {
    return res.status(400).json({
      success: false,
      message: "Verification token is required",
    });
  }

  const result = await authService.verifyEmail(token);

  return res.status(200).json({
    success: true,
    message: result.message,
    data: result.data,
  });
});

export const resendVerification = asyncHandler(async (req: Request, res: Response) => {
  const parse = resendVerificationSchema.safeParse(req.body);
  if (!parse.success) {
    const errors = z.treeifyError(parse.error);
    return res.status(400).json({ success: false, errors });
  }

  const result = await authService.resendVerification(parse.data.email);

  return res.status(200).json({
    success: true,
    message: result.message,
  });
});

export const forgotPassword = asyncHandler(async (req: Request, res: Response) => {
  const parse = forgotPasswordSchema.safeParse(req.body);
  if (!parse.success) {
    const errors = z.treeifyError(parse.error);
    return res.status(400).json({ success: false, errors });
  }

  const result = await authService.forgotPassword(parse.data.email);

  return res.status(200).json({
    success: true,
    message: result.message,
  });
});

export const resetPassword = asyncHandler(async (req: Request, res: Response) => {
  const parse = resetPasswordSchema.safeParse(req.body);
  if (!parse.success) {
    const errors = z.treeifyError(parse.error);
    return res.status(400).json({ success: false, errors });
  }

  const result = await authService.resetPassword(parse.data.token, parse.data.password);

  return res.status(200).json({
    success: true,
    message: result.message,
    data: result.data,
  });
});

export const refreshTokens = asyncHandler(async (req: Request, res: Response) => {
  const refreshToken = req.cookies?.refreshToken;

  const result = await authService.refreshTokens(refreshToken);

  res.cookie("refreshToken", result.tokens.refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  return res.status(200).json({
    success: true,
    message: "Tokens refreshed",
    data: { accessToken: result.tokens.accessToken },
  });
});

export const logout = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;

  if (!userId) {
    return res.status(401).json({
      success: false,
      message: "User not authenticated",
    });
  }

  await authService.logout(userId);

  res.clearCookie("refreshToken");

  return res.status(200).json({
    success: true,
    message: "Logged out successfully",
  });
});
</file>

<file path="server/src/controllers/call.controller.ts">
import { Request, Response } from "express";
import { callService } from "../services/call.service";
import { sendResponse } from "../utils/response.util";
import { BadRequestError, NotFoundError, AuthorizationError } from "../types/error.types";
import { asyncHandler } from "../middleware/error.middleware";

// Initiate a call
export const initiateCall = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId, receiverId, callType } = req.body;

  if (!conversationId || !receiverId || !callType) {
    throw new BadRequestError(
      "conversationId, receiverId, and callType are required"
    );
  }

  if (!["AUDIO", "VIDEO"].includes(callType)) {
    throw new BadRequestError("callType must be AUDIO or VIDEO");
  }

  const call = await callService.initiateCall(
    conversationId,
    userId,
    receiverId,
    callType
  );

  sendResponse(res, 201, "Call initiated", call);
});

// Update call status
export const updateCallStatus = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { callId, status } = req.body;

  if (!callId || !status) {
    throw new BadRequestError("callId and status are required");
  }

  const validStatuses = [
    "INITIATING",
    "RINGING",
    "ACTIVE",
    "ENDED",
    "DECLINED",
    "MISSED",
    "CANCELED",
  ];
  if (!validStatuses.includes(status)) {
    throw new BadRequestError(
      `status must be one of: ${validStatuses.join(", ")}`
    );
  }

  const call = await callService.updateCallStatus(callId, status);

  sendResponse(res, 200, "Call status updated", call);
});

// End a call
export const endCall = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { callId } = req.body;

  if (!callId) {
    throw new BadRequestError("callId is required");
  }

  const call = await callService.endCall(callId);

  sendResponse(res, 200, "Call ended", call);
});

// Decline a call
export const declineCall = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { callId } = req.body;

  if (!callId) {
    throw new BadRequestError("callId is required");
  }

  const call = await callService.declineCall(callId);

  sendResponse(res, 200, "Call declined", call);
});

// Get active call for a conversation
export const getActiveCall = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = req.params;

  if (!conversationId) {
    throw new BadRequestError("conversationId is required");
  }

  const call = await callService.getActiveCall(conversationId);

  if (!call) {
    sendResponse(res, 200, "No active call", null);
    return;
  }

  sendResponse(res, 200, "Active call retrieved", call);
});

// Get call history
export const getCallHistory = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = req.params;
  const limit = Number(req.query.limit) || 20;
  const page = Number(req.query.page) || 1;
  const skip = (page - 1) * limit;

  if (!conversationId) {
    throw new BadRequestError("conversationId is required");
  }

  const calls = await callService.getCallHistory(
    conversationId,
    userId,
    limit,
    skip
  );

  sendResponse(res, 200, "Call history retrieved", calls);
});

// Miss a call
export const missCall = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { callId } = req.body;

  if (!callId) {
    throw new BadRequestError("callId is required");
  }

  const call = await callService.missCall(callId);

  sendResponse(res, 200, "Call marked as missed", call);
});
</file>

<file path="server/src/controllers/conversation.controller.ts">
import { Request, Response, NextFunction } from "express";
import { conversationService } from "../services/conversation.service";
import { messageService } from "../services/message.service";
import {
  getOrCreateConversationSchema,
  archiveConversationSchema,
  unarchiveConversationSchema,
  deleteConversationSchema,
  getUserConversationsQuerySchema,
  getConversationSchema,
} from "../dto/conversation.dto";
import { sendResponse } from "../utils/response.util";
import { BadRequestError, NotFoundError, AuthorizationError } from "../types/error.types";
import { asyncHandler } from "../middleware/error.middleware";

// Get or create a conversation with a friend
export const getOrCreateConversation = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const { friendId } = getOrCreateConversationSchema.parse(req.body);

    if (friendId === userId) {
      throw new BadRequestError("Cannot start conversation with yourself");
    }

    const conversation = await conversationService.getOrCreateConversation(
      userId,
      friendId
    );

    sendResponse(res, 200, "Conversation retrieved or created", conversation);
  }
);

// Get all conversations for the user
export const getUserConversations = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const query = getUserConversationsQuerySchema.parse(req.query || {});
    const limit = query.limit || 20;
    const page = query.page || 1;
    const skip = (page - 1) * limit;
    const search = query.search;

    const conversations = await conversationService.getUserConversations(
      userId,
      limit,
      skip,
      search
    );

    sendResponse(res, 200, "Conversations retrieved", conversations);
  }
);

// Get a single conversation
export const getConversation = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = getConversationSchema.parse(req.params);

  const conversation = await conversationService.getConversation(
    conversationId,
    userId
  );

  if (!conversation) {
    throw new NotFoundError("Conversation not found");
  }

  // Auto-mark all messages as read when user opens conversation
  await messageService.markMessagesAsRead(conversationId, userId);

  sendResponse(res, 200, "Conversation retrieved", conversation);
});

// Get the other user in a conversation
export const getOtherUser = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = getConversationSchema.parse(req.params);

  const otherUser = await conversationService.getOtherUser(conversationId, userId);

  if (!otherUser) {
    throw new NotFoundError("User not found in this conversation");
  }

  sendResponse(res, 200, "Other user retrieved", otherUser);
});

// Archive a conversation
export const archiveConversation = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = archiveConversationSchema.parse(req.body || {});

  const conversation = await conversationService.archiveConversation(
    conversationId,
    userId
  );

  sendResponse(res, 200, "Conversation archived", conversation);
});

// Unarchive a conversation
export const unarchiveConversation = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const { conversationId } = unarchiveConversationSchema.parse(req.body || {});

    const conversation = await conversationService.unarchiveConversation(
      conversationId,
      userId
    );

    sendResponse(res, 200, "Conversation unarchived", conversation);
  }
);

// Delete a conversation
export const deleteConversation = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = deleteConversationSchema.parse(req.body || {});

  await conversationService.deleteConversation(conversationId, userId);

  sendResponse(res, 204, "Conversation deleted", null);
});
</file>

<file path="server/src/controllers/friend.controller.ts">
import { Request, Response } from "express";
import { asyncHandler } from "../middleware/error.middleware";
import {
  sendFriendRequest,
  acceptFriendRequest,
  rejectFriendRequest,
  cancelFriendRequest,
  getFriendRequests,
  getFriendRequestsCount,
  getFriends,
  getFriendsCount,
  removeFriend,
} from "../services/friend.service";
import {
  sendFriendRequestSchema,
  getFriendRequestsQuerySchema,
  getFriendsQuerySchema,
} from "../dto/friend.dto";

/**
 * Send a friend request
 * POST /api/v1/friends/request
 */
export const sendFriendRequestHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    // Validate request body
    const validationResult = sendFriendRequestSchema.safeParse(req.body);

    if (!validationResult.success) {
      res.status(400).json({
        message: "Validation failed",
        errors: validationResult.error.flatten().fieldErrors,
      });
      return;
    }

    const { receiverId } = validationResult.data;

    const friendRequest = await sendFriendRequest(userId, receiverId);

    res.status(201).json({
      message: "Friend request sent successfully",
      data: friendRequest,
    });
  }
);

/**
 * Accept a friend request
 * PATCH /api/v1/friends/request/:requestId/accept
 */
export const acceptFriendRequestHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    const { requestId } = req.params;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    const result = await acceptFriendRequest(requestId, userId);

    res.status(200).json({
      message: "Friend request accepted successfully",
      data: result,
    });
  }
);

/**
 * Reject a friend request
 * PATCH /api/v1/friends/request/:requestId/reject
 */
export const rejectFriendRequestHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    const { requestId } = req.params;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    const result = await rejectFriendRequest(requestId, userId);

    res.status(200).json({
      message: "Friend request rejected successfully",
      data: result,
    });
  }
);

/**
 * Cancel a sent friend request
 * DELETE /api/v1/friends/request/:requestId
 */
export const cancelFriendRequestHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    const { requestId } = req.params;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    const result = await cancelFriendRequest(requestId, userId);

    res.status(200).json(result);
  }
);

/**
 * Get friend requests (pending or sent)
 * GET /api/v1/friends/requests?type=pending
 * GET /api/v1/friends/requests?type=sent
 */
export const getFriendRequestsHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    // Validate query parameters
    const validationResult = getFriendRequestsQuerySchema.safeParse(req.query);

    if (!validationResult.success) {
      res.status(400).json({
        message: "Validation failed",
        errors: validationResult.error.flatten().fieldErrors,
      });
      return;
    }

    const { type } = validationResult.data;
    const limit = parseInt(validationResult.data.limit, 10);
    const page = parseInt(validationResult.data.page, 10);
    const skip = (page - 1) * limit;

    const requests = await getFriendRequests(userId, type, limit, skip);
    const total = await getFriendRequestsCount(userId, type);

    const message =
      type === "pending"
        ? "Pending friend requests retrieved successfully"
        : "Sent friend requests retrieved successfully";

    res.status(200).json({
      message,
      data: {
        requests,
        type,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit),
        },
      },
    });
  }
);

/**
 * Get all friends
 * GET /api/v1/friends
 */
export const getFriendsHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    // Validate query parameters
    const validationResult = getFriendsQuerySchema.safeParse(req.query);

    if (!validationResult.success) {
      res.status(400).json({
        message: "Validation failed",
        errors: validationResult.error.flatten().fieldErrors,
      });
      return;
    }

    const limit = parseInt(validationResult.data.limit, 10);
    const page = parseInt(validationResult.data.page, 10);
    const skip = (page - 1) * limit;
    const search = validationResult.data.search;

    const friends = await getFriends(userId, limit, skip, search);
    const total = await getFriendsCount(userId, search);

    res.status(200).json({
      message: "Friends retrieved successfully",
      data: {
        friends,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit),
        },
      },
    });
  }
);

/**
 * Remove a friend
 * DELETE /api/v1/friends/:friendId
 */
export const removeFriendHandler = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    const { friendId } = req.params;

    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    const result = await removeFriend(userId, friendId);

    res.status(200).json(result);
  }
);
</file>

<file path="server/src/controllers/google-auth.controller.ts">
import { Request, Response } from "express";
import { generateAuthTokens } from "../utils/jwt.util";
import { config } from "../config/env.config";
import { asyncHandler } from "../middleware/error.middleware";

export const googleCallback = async (req: Request, res: Response): Promise<void> => {
  try {
    const googleUser = (req as any).user as
      | { id: string; email: string; name?: string; avatar?: string; role?: string }
      | undefined;

    if (!googleUser || !googleUser.id || !googleUser.email) {
      res.status(401).json({
        success: false,
        message: "Authentication failed",
      });
      return;
    }

    const tokens = generateAuthTokens({
      userId: googleUser.id,
      email: googleUser.email,
      role: googleUser.role || "USER",
    });

    res.cookie("refreshToken", tokens.refreshToken, {
      httpOnly: true,
      secure: config.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 30 * 24 * 60 * 60 * 1000,
    });

    const redirectUrl = `${config.CLIENT_URL}/google-callback?token=${tokens.accessToken}&user=${encodeURIComponent(
      JSON.stringify({
        id: googleUser.id,
        email: googleUser.email,
        name: googleUser.name || "",
        avatar: googleUser.avatar || "",
        role: googleUser.role || "USER",
      })
    )}`;

    res.redirect(redirectUrl);
  } catch (error) {
    console.error("Google callback error:", error);
    res.redirect(
      `${config.CLIENT_URL}/auth/error?message=Authentication failed`
    );
  }
};

export const googleAuth = (req: Request, res: Response): void => {
  res.json({
    success: true,
    message: "Redirecting to Google login...",
  });
};

export const googleLogout = asyncHandler(async (req: Request, res: Response): Promise<void> => {
  const userId = req.user?.userId;

  if (!userId) {
    res.status(401).json({
      success: false,
      message: "Not authenticated",
    });
    return;
  }

  res.clearCookie("refreshToken");

  res.status(200).json({
    success: true,
    message: "Logged out successfully",
  });
});
</file>

<file path="server/src/controllers/message.controller.ts">
import { Request, Response } from "express";
import { messageService } from "../services/message.service";
import {
  sendMessageSchema,
  editMessageSchema,
  deleteMessageSchema,
  markAsReadSchema,
  reactToMessageSchema,
  removeReactionSchema,
} from "../dto/message.dto";
import { sendResponse } from "../utils/response.util";
import { BadRequestError, AuthorizationError } from "../types/error.types";
import { asyncHandler } from "../middleware/error.middleware";

// Send a message
export const sendMessage = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const payload = sendMessageSchema.parse(req.body);

  const message = await messageService.sendMessage(
    payload.conversationId,
    userId,
    payload.content,
    payload.type,
    payload.mediaUrls
  );

  sendResponse(res, 201, "Message sent", message);
});

// Get messages in a conversation
export const getMessages = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const { conversationId } = req.params;
  const limit = Number(req.query.limit) || 20;
  const page = Number(req.query.page) || 1;
  const skip = (page - 1) * limit;

  const messages = await messageService.getMessages(
    conversationId,
    limit,
    skip
  );

  sendResponse(res, 200, "Messages retrieved", messages);
});

// Edit a message
export const editMessage = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const payload = editMessageSchema.parse(req.body);

  const message = await messageService.editMessage(
    payload.messageId,
    userId,
    payload.newContent
  );

  sendResponse(res, 200, "Message edited", message);
});

// Delete a message (soft delete)
export const deleteMessage = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const payload = deleteMessageSchema.parse(req.body);

    await messageService.deleteMessage(payload.messageId, userId);

    sendResponse(res, 204, "Message deleted", null);
  }
);

// Mark messages as read
export const markAsRead = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;
  if (!userId) {
    throw new AuthorizationError("Unauthorized");
  }

  const payload = markAsReadSchema.parse(req.body);

  await messageService.markMessagesAsRead(payload.conversationId, userId);

  sendResponse(res, 200, "Messages marked as read", null);
});

// Get read receipts for a message
export const getReadReceipts = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const { messageId } = req.params;

    const receipts = await messageService.getMessageReadReceipts(messageId);

    sendResponse(res, 200, "Read receipts retrieved", receipts);
  }
);

// React to a message
export const reactToMessage = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const payload = reactToMessageSchema.parse(req.body);

    const reaction = await messageService.reactToMessage(
      payload.messageId,
      userId,
      payload.emoji
    );

    sendResponse(res, 201, "Reaction added", reaction);
  }
);

// Remove reaction from a message
export const removeReaction = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const payload = removeReactionSchema.parse(req.body);

    await messageService.removeReaction(
      payload.messageId,
      userId,
      payload.emoji
    );

    sendResponse(res, 204, "Reaction removed", null);
  }
);

// Get all reactions for a message
export const getReactions = asyncHandler(
  async (req: Request, res: Response) => {
    const { messageId } = req.params;

    const reactions = await messageService.getMessageReactions(messageId);

    sendResponse(res, 200, "Reactions retrieved", reactions);
  }
);

// Search messages
export const searchMessages = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
      throw new AuthorizationError("Unauthorized");
    }

    const { conversationId, q } = req.query;

    if (!q || typeof q !== "string") {
      throw new BadRequestError("Search query required");
    }

    if (!conversationId || typeof conversationId !== "string") {
      throw new BadRequestError("Conversation ID required");
    }

    const messages = await messageService.searchMessages(conversationId, q);

    sendResponse(res, 200, "Messages found", messages);
  }
);
</file>

<file path="server/src/controllers/user.controller.ts">
import { Request, Response } from "express";
import { updateProfileSchema, searchUsersSchema } from "../dto/user.dto";
import {
  getUserProfile,
  getUserById,
  updateUserProfile,
  uploadUserAvatar,
  searchUsers,
  deleteUserAccount,
  updateUserStatus,
  getAllUsers,
  getTotalUsersCount,
} from "../services/user.service";
import { asyncHandler } from "../middleware/error.middleware";

/**
 * Get current user's profile
 */
export const getProfile = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;

  if (!userId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  const user = await getUserProfile(userId);

  res.status(200).json({
    message: "Profile retrieved successfully",
    user,
  });
});

/**
 * Get user by ID (public profile)
 */
export const getUserByIdHandler = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  const user = await getUserById(id);

  res.status(200).json({
    message: "User retrieved successfully",
    user,
  });
});

/**
 * Update user profile
 */
export const updateProfile = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;

  if (!userId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  // Validate request body
  const validationResult = updateProfileSchema.safeParse(req.body);

  if (!validationResult.success) {
    res.status(400).json({
      message: "Validation failed",
      errors: validationResult.error.flatten().fieldErrors,
    });
    return;
  }

  const updatedUser = await updateUserProfile(userId, validationResult.data);

  res.status(200).json({
    message: "Profile updated successfully",
    user: updatedUser,
  });
});

/**
 * Upload user avatar
 */
export const uploadAvatar = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;

  if (!userId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  if (!req.file) {
    res.status(400).json({ message: "No file uploaded" });
    return;
  }

  const updatedUser = await uploadUserAvatar(userId, req.file);

  res.status(200).json({
    message: "Avatar uploaded successfully",
    user: updatedUser,
  });
});

/**
 * Search users
 */
export const searchUsersHandler = asyncHandler(async (req: Request, res: Response) => {
  // Validate query parameters
  const validationResult = searchUsersSchema.safeParse(req.query);

  if (!validationResult.success) {
    res.status(400).json({
      message: "Validation failed",
      errors: validationResult.error.flatten().fieldErrors,
    });
    return;
  }

  const { query, limit } = validationResult.data;
  const limitNumber = limit ? parseInt(limit, 10) : 10;

  const users = await searchUsers(query, limitNumber);

  res.status(200).json({
    message: "Users found",
    count: users.length,
    users,
  });
});

/**
 * Update user status
 */
export const updateStatus = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;

  if (!userId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  const { status } = req.body;

  if (!status) {
    res.status(400).json({ message: "Status is required" });
    return;
  }

  const updatedUser = await updateUserStatus(userId, status);

  res.status(200).json({
    message: "Status updated successfully",
    user: updatedUser,
  });
});

/**
 * Delete user account
 */
export const deleteAccount = asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user?.userId;

  if (!userId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  await deleteUserAccount(userId);

  res.status(200).json({
    message: "Account deleted successfully",
  });
});

/**
 * Get all users (Admin only)
 */
export const getAllUsersHandler = asyncHandler(async (req: Request, res: Response) => {
  const limit = parseInt(req.query.limit as string) || 10;
  const page = parseInt(req.query.page as string) || 1;
  const skip = (page - 1) * limit;

  const users = await getAllUsers(limit, skip);
  const total = await getTotalUsersCount();

  res.status(200).json({
    message: "All users retrieved successfully",
    data: {
      users,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit),
      },
    },
  });
});
</file>

<file path="server/src/dto/auth.dto.ts">
import { z } from "zod";

export const registerSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

export type RegisterDTO = z.infer<typeof registerSchema>;

export const loginSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

export type LoginDTO = z.infer<typeof loginSchema>;

// Resend verification (by email)
export const resendVerificationSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
});
export type ResendVerificationDTO = z.infer<typeof resendVerificationSchema>;

// Forgot password (request reset link)
export const forgotPasswordSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
});
export type ForgotPasswordDTO = z.infer<typeof forgotPasswordSchema>;

// Reset password (use token from email + new password)
export const resetPasswordSchema = z.object({
  token: z.string().min(10, "Invalid token"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});
export type ResetPasswordDTO = z.infer<typeof resetPasswordSchema>;
</file>

<file path="server/src/dto/conversation.dto.ts">
import { z } from "zod";

/**
 * Create Private Conversation DTO
 */
export const createPrivateConversationSchema = z.object({
  participantId: z.string().cuid("Invalid participant ID"),
});

export const getOrCreateConversationSchema = z.object({
  friendId: z.string().cuid("Invalid friend ID"),
});

export type CreatePrivateConversationDTO = z.infer<typeof createPrivateConversationSchema>;

/**
 * Archive Conversation DTO
 */
export const archiveConversationSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
});

export type ArchiveConversationDTO = z.infer<typeof archiveConversationSchema>;

/**
 * Unarchive Conversation DTO
 */
export const unarchiveConversationSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
});

export type UnarchiveConversationDTO = z.infer<typeof unarchiveConversationSchema>;

/**
 * Delete Conversation DTO
 */
export const deleteConversationSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
});

export type DeleteConversationDTO = z.infer<typeof deleteConversationSchema>;

/**
 * Create Group Conversation DTO
 */
export const createGroupConversationSchema = z.object({
  name: z.string().min(1, "Group name is required").max(100, "Group name too long"),
  description: z.string().max(500, "Description too long").optional(),
  avatar: z.string().url("Invalid avatar URL").optional(),
  memberIds: z.array(z.string().cuid()).min(2, "At least 2 members required"),
});

export type CreateGroupConversationDTO = z.infer<typeof createGroupConversationSchema>;

/**
 * Update Group Conversation DTO
 */
export const updateGroupConversationSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
  avatar: z.string().url().optional(),
});

export type UpdateGroupConversationDTO = z.infer<typeof updateGroupConversationSchema>;

/**
 * Add Member to Group DTO
 */
export const addMemberSchema = z.object({
  memberId: z.string().cuid("Invalid member ID"),
});

export type AddMemberDTO = z.infer<typeof addMemberSchema>;

/**
 * Update Member Role DTO
 */
export const updateMemberRoleSchema = z.object({
  memberId: z.string().cuid("Invalid member ID"),
  role: z.enum(["ADMIN", "MODERATOR", "MEMBER"]),
});

export type UpdateMemberRoleDTO = z.infer<typeof updateMemberRoleSchema>;

/**
 * Update User Conversation Settings DTO
 */
export const updateConversationSettingsSchema = z.object({
  isArchived: z.boolean().optional(),
  isMuted: z.boolean().optional(),
});

export type UpdateConversationSettingsDTO = z.infer<typeof updateConversationSettingsSchema>;

/**
 * Get Conversations Query DTO
 */
export const getConversationsQuerySchema = z.object({
  type: z.enum(["PRIVATE", "GROUP", "ALL"]).default("ALL"),
  limit: z.string().default("20").transform(Number),
  page: z.string().default("1").transform(Number),
  archived: z.enum(["true", "false"]).default("false"),
  search: z.string().optional(),
});

export const getUserConversationsQuerySchema = z.object({
  limit: z.coerce.number().optional(),
  page: z.coerce.number().optional(),
  search: z.string().optional(),
});

export type GetConversationsQueryDTO = z.infer<typeof getConversationsQuerySchema>;

/**
 * Conversation ID DTO
 */
export const conversationIdSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
});

export const getConversationSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
});

export type ConversationIdDTO = z.infer<typeof conversationIdSchema>;
</file>

<file path="server/src/dto/friend.dto.ts">
import { z } from "zod";

/**
 * Send Friend Request DTO
 * Used when sending a friend request to another user
 */
export const sendFriendRequestSchema = z.object({
  receiverId: z.string().min(1, "Receiver ID is required"),
});

export type SendFriendRequestDTO = z.infer<typeof sendFriendRequestSchema>;

/**
 * Friend Request ID Param DTO
 * Used for accept/reject/cancel operations
 */
export const friendRequestIdSchema = z.object({
  requestId: z.string().min(1, "Request ID is required"),
});

export type FriendRequestIdDTO = z.infer<typeof friendRequestIdSchema>;

/**
 * Remove Friend DTO
 * Used when removing a friend
 */
export const removeFriendSchema = z.object({
  friendId: z.string().min(1, "Friend ID is required"),
});

export type RemoveFriendDTO = z.infer<typeof removeFriendSchema>;

/**
 * Get Friend Requests Query DTO
 * Used for pagination when fetching friend requests
 */
export const getFriendRequestsQuerySchema = z.object({
  type: z.enum(["pending", "sent"]).default("pending"),
  limit: z.string().optional().default("10"),
  page: z.string().optional().default("1"),
});

export type GetFriendRequestsQueryDTO = z.infer<typeof getFriendRequestsQuerySchema>;

/**
 * Get Friends Query DTO
 * Used for pagination when fetching friends list
 */
export const getFriendsQuerySchema = z.object({
  limit: z.string().optional().default("10"),
  page: z.string().optional().default("1"),
  search: z.string().optional(),
});

export type GetFriendsQueryDTO = z.infer<typeof getFriendsQuerySchema>;
</file>

<file path="server/src/dto/message.dto.ts">
import { z } from "zod";

/**
 * Send Message DTO
 */
export const sendMessageSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
  content: z.string().min(1, "Message cannot be empty").max(5000, "Message too long"),
  type: z.enum(["TEXT", "IMAGE", "VIDEO", "FILE", "SYSTEM_MESSAGE"]).default("TEXT"),
  mediaUrls: z.array(z.string().url()).optional(),
});

export type SendMessageDTO = z.infer<typeof sendMessageSchema>;

/**
 * Edit Message DTO
 */
export const editMessageSchema = z.object({
  messageId: z.string().cuid("Invalid message ID"),
  newContent: z.string().min(1, "Message cannot be empty").max(5000, "Message too long"),
});

export type EditMessageDTO = z.infer<typeof editMessageSchema>;

/**
 * Delete Message DTO
 */
export const deleteMessageSchema = z.object({
  messageId: z.string().cuid("Invalid message ID"),
});

export type DeleteMessageDTO = z.infer<typeof deleteMessageSchema>;

/**
 * Mark as Read DTO
 */
export const markAsReadSchema = z.object({
  conversationId: z.string().cuid("Invalid conversation ID"),
});

export type MarkAsReadDTO = z.infer<typeof markAsReadSchema>;

/**
 * React to Message DTO
 */
export const reactToMessageSchema = z.object({
  messageId: z.string().cuid("Invalid message ID"),
  emoji: z.string().emoji("Must be a valid emoji"),
});

export type ReactToMessageDTO = z.infer<typeof reactToMessageSchema>;

/**
 * Remove Reaction DTO
 */
export const removeReactionSchema = z.object({
  messageId: z.string().cuid("Invalid message ID"),
  emoji: z.string().emoji("Must be a valid emoji"),
});

export type RemoveReactionDTO = z.infer<typeof removeReactionSchema>;

/**
 * Get Messages Query DTO
 */
export const getMessagesQuerySchema = z.object({
  limit: z.string().default("50").transform(Number),
  page: z.string().default("1").transform(Number),
  fromDate: z.string().datetime().optional(),
  toDate: z.string().datetime().optional(),
});

export type GetMessagesQueryDTO = z.infer<typeof getMessagesQuerySchema>;

/**
 * Mark Message Read DTO
 */
export const markMessageReadSchema = z.object({
  messageIds: z.array(z.string().cuid()).min(1, "At least one message ID required"),
});

export type MarkMessageReadDTO = z.infer<typeof markMessageReadSchema>;

/**
 * Message ID Param DTO
 */
export const messageIdSchema = z.object({
  messageId: z.string().cuid("Invalid message ID"),
});

export type MessageIdDTO = z.infer<typeof messageIdSchema>;
</file>

<file path="server/src/dto/user.dto.ts">
import { z } from "zod";

export const updateProfileSchema = z.object({
  name: z.string().min(2).max(50).optional(),
  bio: z.string().max(200).optional(),
  status: z.enum(["online", "offline", "away"]).optional(),
});

export type UpdateProfileDTO = z.infer<typeof updateProfileSchema>;

export const searchUsersSchema = z.object({
  query: z.string().min(1),
  limit: z.string().optional(),
});

export type SearchUsersDTO = z.infer<typeof searchUsersSchema>;
</file>

<file path="server/src/middleware/auth.middleware.ts">
import { Request, Response, NextFunction } from "express";
import { verifyAccessToken } from "../utils/jwt.util";
import { AuthenticationError } from "../types/error.types";

/**
 * Extend Passport User type to include custom fields
 */
declare global {
  namespace Express {
    interface User {
      userId?: string;
      email?: string;
      role?: string;
    }
  }
}

/**
 * Authenticate Access Token Middleware
 */
export const authenticate = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  try {
    const authHeader = req.headers.authorization;
    console.log("üîç Auth Header:", authHeader); // Debug log

    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      throw new AuthenticationError("No token provided");
    }

    const token = authHeader.slice(7);
    console.log("üîç Token:", token); // Debug log

    const decoded = verifyAccessToken(token);
    console.log("üîç Decoded:", decoded); // Debug log

    req.user = {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role || "USER",
    };

    next();
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("‚ùå Auth Error:", errorMessage); // Debug log
    res.status(401).json({
      success: false,
      message: "Unauthorized",
      error: errorMessage,
    });
  }
};

/**
 * Optional Authenticate - Doesn't throw error if token missing
 */
export const optionalAuthenticate = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  try {
    const authHeader = req.headers.authorization;

    if (authHeader && authHeader.startsWith("Bearer ")) {
      const token = authHeader.slice(7);
      const decoded = verifyAccessToken(token);

      req.user = {
        userId: decoded.userId,
        email: decoded.email,
        role: decoded.role || "USER",
      };
    }

    next();
  } catch (error) {
    // Continue without authentication if token is invalid
    next();
  }
};

/**
 * Check if user is authenticated
 */
export const isAuthenticated = (req: Request): boolean => {
  return !!(req.user && req.user.userId);
};

/**
 * Authorize by role
 */
export const authorize = (...allowedRoles: string[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        success: false,
        message: "Not authenticated",
      });
      return;
    }

    if (!allowedRoles.includes(req.user.role || "USER")) {
      res.status(403).json({
        success: false,
        message:
          "Insufficient permissions. Required roles: " +
          allowedRoles.join(", "),
      });
      return;
    }

    next();
  };
};
</file>

<file path="server/src/middleware/error.middleware.ts">
import { Request, Response, NextFunction } from "express";
import { AppError } from "../types/error.types";
import { ZodError } from "zod";

/**
 * Error Response Interface
 */
interface ErrorResponse {
  success: false;
  message: string;
  statusCode: number;
  errors?: Array<{ field: string; message: string }>;
  stack?: string;
}

/**
 * Handle Prisma Errors
 */
const handlePrismaError = (error: unknown): ErrorResponse => {
  // Type guard for Prisma errors
  if (typeof error !== 'object' || error === null) {
    return {
      success: false,
      message: "Database operation failed",
      statusCode: 500,
    };
  }

  const prismaError = error as Record<string, unknown>;
  // Check for Prisma error codes
  if (prismaError.code) {
    switch (prismaError.code as string) {
      case "P2002":
        // Unique constraint violation
        const field = ((prismaError.meta as any)?.target as string[])?.join(", ") || "field";
        return {
          success: false,
          message: `${field} already exists`,
          statusCode: 409,
        };

      case "P2025":
        // Record not found
        return {
          success: false,
          message: "Record not found",
          statusCode: 404,
        };

      case "P2003":
        // Foreign key constraint violation
        return {
          success: false,
          message: "Related record not found",
          statusCode: 400,
        };

      case "P2014":
        // Invalid ID
        return {
          success: false,
          message: "Invalid ID provided",
          statusCode: 400,
        };

      default:
        return {
          success: false,
          message: "Database operation failed",
          statusCode: 500,
        };
    }
  }

  return {
    success: false,
    message: "Database operation failed",
    statusCode: 500,
  };
};

/**
 * Handle Zod Validation Errors
 */
const handleZodError = (error: ZodError): ErrorResponse => {
  const errors = error.issues.map((issue) => ({
    field: issue.path.join("."),
    message: issue.message,
  }));

  return {
    success: false,
    message: "Validation failed",
    statusCode: 400,
    errors,
  };
};

/**
 * Global Error Handler Middleware
 */
export const errorHandler = (
  error: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error("‚ùå Error:", error);

  let response: ErrorResponse = {
    success: false,
    message: error.message || "Internal server error",
    statusCode: 500,
  };

  // Handle custom AppError
  if (error instanceof AppError) {
    response = {
      success: false,
      message: error.message,
      statusCode: error.statusCode,
    };
  }
  // Handle Prisma errors (check by name property)
  else if (
    (error instanceof Error && error.name === "PrismaClientKnownRequestError") ||
    (typeof error === 'object' && error !== null && 'code' in error)
  ) {
    response = handlePrismaError(error);
  }
  // Handle Zod validation errors
  else if (error instanceof ZodError) {
    response = handleZodError(error);
  }
  // Handle JWT errors
  else if (error.name === "JsonWebTokenError") {
    response = {
      success: false,
      message: "Invalid token",
      statusCode: 401,
    };
  } else if (error.name === "TokenExpiredError") {
    response = {
      success: false,
      message: "Token expired",
      statusCode: 401,
    };
  }
  // Handle Multer file upload errors
  else if (error.name === "MulterError") {
    response = {
      success: false,
      message: `File upload error: ${error.message}`,
      statusCode: 400,
    };
  }

  // Include stack trace in development
  if (process.env.NODE_ENV === "development") {
    response.stack = error.stack;
  }

  return res.status(response.statusCode).json(response);
};

/**
 * Handle 404 - Route Not Found
 */
export const notFound = (req: Request, res: Response, next: NextFunction) => {
  const error = new AppError(`Route ${req.originalUrl} not found`, 404);
  next(error);
};

/**
 * Async Handler Wrapper - Catches async errors
 */
export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
</file>

<file path="server/src/middleware/upload.middleware.ts">
import multer from "multer";

// Store files in memory (buffer) for Cloudinary upload
const storage = multer.memoryStorage();

// File filter - only images
const fileFilter = (
  req: Express.Request,
  file: Express.Multer.File,
  cb: multer.FileFilterCallback
) => {
  if (file.mimetype.startsWith("image/")) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

export const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
});
</file>

<file path="server/src/middleware/validate.middleware.ts">
import { Request, Response, NextFunction } from "express";
import { ZodType, ZodError } from "zod";

/**
 * Middleware to validate request data using Zod schemas
 */
export const validate = (schema: ZodType) => {
  return async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      // Validate request body
      const validatedData = await schema.parseAsync(req.body);

      // Replace request body with validated data
      req.body = validatedData;

      next();
    } catch (error) {
      if (error instanceof ZodError) {
        // Format Zod errors
        const errors = error.issues.map((issue) => ({
          field: issue.path.join("."),
          message: issue.message,
        }));

        res.status(400).json({
          success: false,
          message: "Validation failed",
          errors,
        });
        return;
      }

      // Handle unexpected errors
      res.status(500).json({
        success: false,
        message: "Internal server error during validation",
      });
    }
  };
};

/**
 * Validate query parameters
 */
export const validateQuery = (schema: ZodType) => {
  return async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const validatedData = await schema.parseAsync(req.query);
      req.query = validatedData as Record<string, any>;
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.issues.map((issue) => ({
          field: issue.path.join("."),
          message: issue.message,
        }));

        res.status(400).json({
          success: false,
          message: "Query validation failed",
          errors,
        });
        return;
      }

      res.status(500).json({
        success: false,
        message: "Internal server error during validation",
      });
    }
  };
};

/**
 * Validate route parameters
 */
export const validateParams = (schema: ZodType) => {
  return async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const validatedData = await schema.parseAsync(req.params);
      req.params = validatedData as Record<string, any>;
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.issues.map((issue) => ({
          field: issue.path.join("."),
          message: issue.message,
        }));

        res.status(400).json({
          success: false,
          message: "Params validation failed",
          errors,
        });
        return;
      }

      res.status(500).json({
        success: false,
        message: "Internal server error during validation",
      });
    }
  };
};
</file>

<file path="server/src/routes/auth.route.ts">
import { Router } from "express";
import {
  register,
  login,
  verifyEmail,
  resendVerification,
  forgotPassword,
  resetPassword,
  refreshTokens,
  logout,
} from "../controllers/auth.controller";
import { authenticate } from "../middleware/auth.middleware";

const router = Router();

/**
 * Public Routes
 */
router.post("/register", register);
router.post("/login", login);
router.get("/verify-email", verifyEmail);
router.post("/resend-verification", resendVerification);
router.post("/forgot-password", forgotPassword);
router.post("/reset-password", resetPassword);
router.post("/refresh-tokens", refreshTokens);

/**
 * Protected Routes (require auth middleware)
 */
router.post("/logout", authenticate, logout);

export default router;
</file>

<file path="server/src/routes/call.route.ts">
import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware";
import {
  initiateCall,
  updateCallStatus,
  endCall,
  declineCall,
  getActiveCall,
  getCallHistory,
  missCall,
} from "../controllers/call.controller";

const router = Router();

/**
 * All routes require authentication
 */

// Initiate a call
router.post("/", authenticate, initiateCall);

// Update call status
router.patch("/status", authenticate, updateCallStatus);

// End call
router.patch("/end", authenticate, endCall);

// Decline call
router.patch("/decline", authenticate, declineCall);

// Miss call
router.patch("/miss", authenticate, missCall);

// Get call history (specific route before dynamic)
router.get("/:conversationId/history", authenticate, getCallHistory);

// Get active call in conversation (dynamic route last)
router.get("/:conversationId", authenticate, getActiveCall);

export default router;
</file>

<file path="server/src/routes/conversation.route.ts">
import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware";
import {
  getOrCreateConversation,
  getUserConversations,
  getConversation,
  getOtherUser,
  archiveConversation,
  unarchiveConversation,
  deleteConversation,
} from "../controllers/conversation.controller";

const router = Router();

/**
 * All routes require authentication
 */

// Create or get existing conversation with a friend
router.post("/", authenticate, getOrCreateConversation);

// Get all conversations for the user
router.get("/", authenticate, getUserConversations);

// Archive conversation
router.patch("/archive", authenticate, archiveConversation);

// Unarchive conversation
router.patch("/unarchive", authenticate, unarchiveConversation);

// Delete conversation
router.delete("/", authenticate, deleteConversation);

// Get other user in conversation (specific route before dynamic)
router.get("/:conversationId/user", authenticate, getOtherUser);

// Get single conversation (dynamic route last)
router.get("/:conversationId", authenticate, getConversation);

export default router;
</file>

<file path="server/src/routes/friend.route.ts">
import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware";
import {
  sendFriendRequestHandler,
  acceptFriendRequestHandler,
  rejectFriendRequestHandler,
  cancelFriendRequestHandler,
  getFriendRequestsHandler,
  getFriendsHandler,
  removeFriendHandler,
} from "../controllers/friend.controller";

const router = Router();

/**
 * All routes require authentication
 */

// Friend request routes (specific routes first)
router.post("/request", authenticate, sendFriendRequestHandler);
router.patch("/request/:requestId/accept", authenticate, acceptFriendRequestHandler);
router.patch("/request/:requestId/reject", authenticate, rejectFriendRequestHandler);
router.delete("/request/:requestId", authenticate, cancelFriendRequestHandler);

// Get friend requests (with type filter: pending or sent)
router.get("/requests", authenticate, getFriendRequestsHandler);

// Friends list
router.get("/", authenticate, getFriendsHandler);

// Remove friend (dynamic route last)
router.delete("/:friendId", authenticate, removeFriendHandler);

export default router;
</file>

<file path="server/src/routes/google-auth.route.ts">
import { Router } from "express";
import passport from "passport";
import {
  googleCallback,
  googleAuth,
} from "../controllers/google-auth.controller";

const router = Router();

/**
 * Google OAuth Routes
 * 
 * These routes handle the complete Google OAuth 2.0 flow
 */

/**
 * Step 1: Initiate Google OAuth Login
 * 
 * Client flow:
 * 1. User clicks "Sign in with Google" button on frontend
 * 2. Frontend redirects user to this endpoint: GET /api/v1/auth/google
 * 3. Passport middleware intercepts and redirects to Google login page
 * 
 * What happens:
 * - User sees Google login screen
 * - User logs in with their Google account
 * - Google asks for permissions (email, profile)
 */
router.get(
  "/google",
  passport.authenticate("google", {
    scope: ["email", "profile"],
    accessType: "offline",
    prompt: "consent",
  })
);

/**
 * Step 2: Google OAuth Callback
 * 
 * This URL is registered in Google Cloud Console as the callback URL
 * Google redirects here after successful authentication
 * 
 * URL: GET /api/v1/auth/google/callback?code=<authorization_code>
 * 
 * What happens:
 * 1. Passport intercepts the request and exchanges the code for user profile
 * 2. googleStrategy verifies the code and calls verifyCallback with user profile
 * 3. verifyCallback finds or creates user in database
 * 4. Passport calls serializeUser() to store user.id in session
 * 5. googleCallback handler generates JWT tokens
 * 6. User is redirected to frontend with access token in URL
 */
router.get(
  "/google/callback",
  passport.authenticate("google", {
    failureRedirect: "/api/v1/auth/error",
    session: true,
  }),
  googleCallback
);

export default router;
</file>

<file path="server/src/routes/message.route.ts">
import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware";
import {
  sendMessage,
  getMessages,
  editMessage,
  deleteMessage,
  markAsRead,
  getReadReceipts,
  reactToMessage,
  removeReaction,
  getReactions,
  searchMessages,
} from "../controllers/message.controller";

// REORDER specific routes BEFORE dynamic routes

const router = Router();

// ‚úÖ SPECIFIC ROUTES FIRST
router.post("/mark-as-read", authenticate, markAsRead);
router.get("/search", authenticate, searchMessages);
router.post("/react", authenticate, reactToMessage);
router.delete("/react", authenticate, removeReaction);
router.patch("/edit", authenticate, editMessage);

// ‚úÖ THEN PARAMETERIZED ROUTES
router.get("/:messageId/reactions", authenticate, getReactions);
router.get("/:messageId/read-receipts", authenticate, getReadReceipts);

// ‚úÖ FINALLY GENERIC ROUTES
router.post("/", authenticate, sendMessage);
router.delete("/", authenticate, deleteMessage);
router.get("/:conversationId", authenticate, getMessages);

export default router;
</file>

<file path="server/src/routes/user.route.ts">
import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware";
import { authorize } from "../middleware/auth.middleware";
import { upload } from "../middleware/upload.middleware";
import {
  getProfile,
  getUserByIdHandler,
  updateProfile,
  uploadAvatar,
  searchUsersHandler,
  updateStatus,
  deleteAccount,
  getAllUsersHandler,
} from "../controllers/user.controller";

const router = Router();

/**
 * User Routes
 * IMPORTANT: Static/specific routes MUST come BEFORE dynamic routes (:id)
 */

/**
 * GET /api/v1/users/profile
 * Get current user's profile
 * Requires: Authentication
 */
router.get("/profile", authenticate, getProfile);

/**
 * PATCH /api/v1/users/profile
 * Update current user's profile (name, bio, status)
 * Requires: Authentication
 */
router.patch("/profile", authenticate, updateProfile);

/**
 * POST /api/v1/users/avatar
 * Upload user avatar
 * Requires: Authentication
 * Body: FormData with "avatar" file field
 */
router.post("/avatar", authenticate, upload.single("avatar"), uploadAvatar);

/**
 * PATCH /api/v1/users/status
 * Update user online status
 * Requires: Authentication
 * Body: { status: "online" | "offline" | "away" }
 */
router.patch("/status", authenticate, updateStatus);

/**
 * DELETE /api/v1/users/profile
 * Delete user account
 * Requires: Authentication
 */
router.delete("/profile", authenticate, deleteAccount);

/**
 * GET /api/v1/users/search
 * Search users by name or email
 * Query: ?query=searchTerm&limit=10
 */
router.get("/search", authenticate, searchUsersHandler);

/**
 * GET /api/v1/users/admin/all
 * Get all users (Admin only)
 * Query: ?page=1&limit=10
 * Requires: Authentication + ADMIN role
 * MUST come BEFORE /:id route
 */
router.get("/admin/all", authenticate, authorize("ADMIN"), getAllUsersHandler);

/**
 * GET /api/v1/users/:id
 * Get public user profile by ID
 * MUST come LAST (after all static routes)
 */
router.get("/:id", authenticate, getUserByIdHandler);

export default router;
</file>

<file path="server/src/server.ts">
import http from "http";
import { Server as SocketIOServer } from "socket.io";
import { app } from "./app";
import { config } from "./config/env.config";
import { PrismaClient } from "@prisma/client";
import { setupChatSocket } from "./socket/chat.socket";
import { verifyAccessToken } from "./utils/jwt.util";

/**
 * Initialize Prisma Client
 */
const prisma = new PrismaClient();

/**
 * Create HTTP Server
 */
const server = http.createServer(app);

/**
 * Initialize Socket.IO
 */
export const io = new SocketIOServer(server, {
  cors: {
    origin: config.CLIENT_URL,
    methods: ["GET", "POST"],
    credentials: true,
  },
});

/**
 * Socket.IO Middleware - Extract userId from JWT token
 */
io.use((socket, next) => {
  try {
    // Get token from auth header or auth.token
    let token = socket.handshake.auth.token;
    
    if (!token && socket.handshake.headers.authorization) {
      // Extract token from "Bearer <token>" format
      const authHeader = socket.handshake.headers.authorization;
      token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : authHeader;
    }

    if (!token) {
      return next(new Error("No token provided"));
    }

    // Verify and decode token
    const decoded = verifyAccessToken(token);
    
    if (!decoded.userId) {
      return next(new Error("userId not found in token"));
    }

    // Add userId to socket.data for later use
    socket.data.userId = decoded.userId;
    socket.data.email = decoded.email;
    socket.data.role = decoded.role;

    next();
  } catch (error: any) {
    console.error("‚ùå Socket.IO Auth Error:", error.message);
    return next(new Error(`Authentication failed: ${error.message}`));
  }
});

/**
 * Initialize Chat Socket Handlers
 */
setupChatSocket(io);

/**
 * Database Connection
 */
const connectDatabase = async () => {
  try {
    await prisma.$connect();
    console.log("‚úÖ Database connected successfully");
    return true;
  } catch (error) {
    console.warn("‚ö†Ô∏è  Database connection failed. Running in offline mode.");
    console.warn("   Make sure PostgreSQL is running at localhost:5432");
    return false;
  }
};

/**
 * Graceful Shutdown
 */
const gracefulShutdown = async () => {
  console.log("\nüõë Shutting down gracefully...");

  // Close Socket.IO connections
  io.close();

  // Close HTTP server
  server.close(() => {
    console.log("‚úÖ HTTP server closed");
  });

  // Disconnect Prisma
  await prisma.$disconnect();
  console.log("‚úÖ Database disconnected");

  process.exit(0);
};

/**
 * Shutdown Signals
 */
process.on("SIGINT", gracefulShutdown);
process.on("SIGTERM", gracefulShutdown);

/**
 * Unhandled Promise Rejection
 */
process.on("unhandledRejection", (reason, promise) => {
  console.error("‚ùå Unhandled Rejection at:", promise, "reason:", reason);
});

/**
 * Start Server
 */
const startServer = async () => {
  try {
    // Attempt to connect to database (optional)
    const dbConnected = await connectDatabase();

    // Start listening
    server.listen(config.PORT, () => {
      console.log(
        `üöÄ Server running on http://localhost:${config.PORT} in ${config.NODE_ENV} mode`
      );
      console.log(`üì° WebSocket server initialized with Socket.IO`);
      if (dbConnected) {
        console.log("‚úÖ Database is connected");
      } else {
        console.log("‚ö†Ô∏è  Running without database (offline mode)");
      }
    });
  } catch (error) {
    console.error("‚ùå Failed to start server:", error);
    process.exit(1);
  }
};

// Start the server
startServer();

export { server, prisma };
</file>

<file path="server/src/services/auth.service.ts">
import bcrypt from "bcrypt";
import prisma from "../config/db";
import { RegisterDTO, LoginDTO } from "../dto/auth.dto";
import { generateAccessToken, generateRefreshToken, verifyRefreshToken, generateAuthTokens } from "../utils/jwt.util";
import { ConflictError, AuthenticationError, BadRequestError, NotFoundError } from "../types/error.types";
import crypto from "crypto";
import { sendVerificationEmail, sendPasswordResetEmail, sendWelcomeEmail } from "../utils/email.util";

export class AuthService {
  async register(data: RegisterDTO) {
    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new ConflictError("Email already registered");
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(
      data.password,
      parseInt(process.env.BCRYPT_ROUNDS || "10")
    );

    // Create user (role defaults to USER)
    const user = await prisma.user.create({
      data: {
        name: data.name,
        email: data.email,
        password: hashedPassword,
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
      },
    });

    // Generate verification token
    const verificationToken = crypto.randomBytes(32).toString("hex");
    const verificationTokenHash = crypto
      .createHash("sha256")
      .update(verificationToken)
      .digest("hex");

    // Create email verification record
    await prisma.emailVerification.create({
      data: {
        userId: user.id,
        token: verificationTokenHash,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
      },
    });

    // Send verification email
    const verificationLink = `${process.env.CLIENT_URL}/verify-email?token=${verificationToken}`;
    await sendVerificationEmail(user.email, verificationToken, verificationLink, user.name || undefined);

    return {
      user,
      verificationToken,
    };
  }

  async login(data: LoginDTO) {
    // Find user by email
    const user = await prisma.user.findUnique({
      where: { email: data.email },
      select: {
        id: true,
        email: true,
        password: true,
        name: true,
        role: true,
        createdAt: true,
      },
    });

    if (!user) {
      throw new AuthenticationError("Invalid email or password");
    }

    // Compare password
    if (!user.password) {
      throw new AuthenticationError("Invalid email or password");
    }
    const isPasswordValid = await bcrypt.compare(data.password, user.password);

    if (!isPasswordValid) {
      throw new AuthenticationError("Invalid email or password");
    }

    // Generate tokens
    const accessToken = generateAccessToken({
      userId: user.id,
      email: user.email,
      role: user.role,
    });
    const refreshToken = generateRefreshToken({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    // Update refresh token in database
    await prisma.user.update({
      where: { id: user.id },
      data: { refreshToken },
    });

    return {
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        createdAt: user.createdAt,
      },
      accessToken,
      refreshToken,
    };
  }

  async verifyEmail(token: string) {
    // Hash the token to match with DB
    const tokenHash = crypto.createHash("sha256").update(token).digest("hex");

    // Find verification record
    const verification = await prisma.emailVerification.findUnique({
      where: { token: tokenHash },
    });

    if (!verification) {
      throw new BadRequestError("Invalid verification token");
    }

    // Check if token expired
    if (verification.expiresAt < new Date()) {
      throw new BadRequestError("Verification token has expired");
    }

    // Update user to verified
    const user = await prisma.user.update({
      where: { id: verification.userId },
      data: { emailVerified: true },
      select: {
        id: true,
        name: true,
        email: true,
        createdAt: true,
      },
    });

    // Delete verification record
    await prisma.emailVerification.delete({
      where: { id: verification.id },
    });

    return {
      success: true,
      message: "Email verified successfully. You can now login.",
      data: { user },
    };
  }

  async resendVerification(email: string) {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) throw new NotFoundError("User not found");
    if (user.emailVerified) throw new BadRequestError("Email already verified");

    // Remove old tokens
    await prisma.emailVerification.deleteMany({ where: { userId: user.id } });

    // Create new verification token
    const verificationToken = crypto.randomBytes(32).toString("hex");
    const verificationTokenHash = crypto.createHash("sha256").update(verificationToken).digest("hex");

    await prisma.emailVerification.create({
      data: {
        userId: user.id,
        token: verificationTokenHash,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
      },
    });

    const verificationLink = `${process.env.CLIENT_URL}/verify-email?token=${verificationToken}`;
    await sendVerificationEmail(user.email, verificationToken, verificationLink, user.name || undefined);

    return { success: true, message: "Verification email resent" };
  }

  async forgotPassword(email: string) {
    const user = await prisma.user.findUnique({ where: { email } });
    // Do not reveal whether user exists
    if (!user) return { success: true, message: "If that email exists, a reset link has been sent" };
    if (!user.emailVerified) throw new BadRequestError("Email is not verified");

    // Delete existing resets
    await prisma.passwordReset.deleteMany({ where: { userId: user.id } });

    const resetToken = crypto.randomBytes(32).toString("hex");
    const resetTokenHash = crypto.createHash("sha256").update(resetToken).digest("hex");

    await prisma.passwordReset.create({
      data: {
        userId: user.id,
        token: resetTokenHash,
        expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
      },
    });

    const resetLink = `${process.env.CLIENT_URL}/reset-password?token=${resetToken}`;
    await sendPasswordResetEmail(user.email, resetToken, resetLink, user.name || undefined);

    return { success: true, message: "If that email exists, a reset link has been sent" };
  }

  async resetPassword(token: string, newPassword: string) {
    const tokenHash = crypto.createHash("sha256").update(token).digest("hex");

    const reset = await prisma.passwordReset.findUnique({ where: { token: tokenHash } });
    if (!reset) throw new BadRequestError("Invalid or expired reset token");
    if (reset.expiresAt < new Date()) throw new BadRequestError("Reset token has expired");

    const hashed = await bcrypt.hash(newPassword, parseInt(process.env.BCRYPT_ROUNDS || "10"));

    // Update user password and clear refresh token
    const user = await prisma.user.update({
      where: { id: reset.userId },
      data: { password: hashed, refreshToken: null },
      select: { id: true, name: true, email: true, createdAt: true },
    });

    // Remove all password reset records for this user
    await prisma.passwordReset.deleteMany({ where: { userId: reset.userId } });

    // Optionally send welcome/confirmation email
    await sendWelcomeEmail(user.email, user.name || user.email.split("@")[0]);

    return { success: true, message: "Password has been reset. Please login with your new password.", data: { user } };
  }

  async refreshTokens(refreshToken: string) {
    if (!refreshToken) throw new AuthenticationError("Refresh token missing");
    // verify refresh token
    const decoded = verifyRefreshToken(refreshToken);

    // Make sure token matches what we have stored for the user
    const dbUser = await prisma.user.findUnique({ where: { id: decoded.userId } });
    if (!dbUser || !dbUser.refreshToken) throw new AuthenticationError("Invalid session");
    if (dbUser.refreshToken !== refreshToken) throw new AuthenticationError("Invalid refresh token");

    // Generate new tokens
    const tokens = generateAuthTokens({ userId: decoded.userId, email: decoded.email });

    // Update stored refresh token
    await prisma.user.update({ where: { id: decoded.userId }, data: { refreshToken: tokens.refreshToken } });

    return { success: true, tokens };
  }

  async logout(userId: string) {
    // Remove stored refresh token
    await prisma.user.update({ where: { id: userId }, data: { refreshToken: null } });
    return { success: true, message: "Logged out" };
  }
}
</file>

<file path="server/src/services/call.service.ts">
import prisma from "../config/db";
import { CallType, CallStatus } from "@prisma/client";
import {
  NotFoundError,
  BadRequestError,
  AuthorizationError,
} from "../types/error.types";

export class CallService {
  /**
   * Initiate a call
   */
  async initiateCall(
    conversationId: string,
    callerId: string,
    receiverId: string,
    callType: "AUDIO" | "VIDEO"
  ) {
    // Check if conversation exists
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    // Check if both users are in the conversation
    const callerParticipant = conversation.participants.find(
      (p) => p.userId === callerId
    );
    const receiverParticipant = conversation.participants.find(
      (p) => p.userId === receiverId
    );

    if (!callerParticipant || !receiverParticipant) {
      throw new AuthorizationError("Both users must be in the conversation");
    }

    // Check if there's already an active call
    const activeCall = await prisma.call.findFirst({
      where: {
        conversationId,
        status: {
          in: ["INITIATING", "RINGING", "ACTIVE"],
        },
      },
    });

    if (activeCall) {
      throw new BadRequestError("There is already an active call in this conversation");
    }

    // Create new call
    const call = await prisma.call.create({
      data: {
        conversationId,
        callerId,
        receiverId,
        type: callType as CallType,
        status: "INITIATING" as CallStatus,
        startedAt: new Date(),
      },
    });

    return call;
  }

  /**
   * Update call status
   */
  async updateCallStatus(callId: string, status: CallStatus) {
    const call = await prisma.call.findUnique({
      where: { id: callId },
    });

    if (!call) {
      throw new NotFoundError("Call not found");
    }

    // Validate state transitions
    const validTransitions: Record<CallStatus, CallStatus[]> = {
      INITIATING: ["RINGING", "CANCELED"],
      RINGING: ["ACTIVE", "DECLINED", "MISSED"],
      ACTIVE: ["ENDED"],
      ENDED: [],
      DECLINED: [],
      MISSED: [],
      CANCELED: [],
    };

    if (!validTransitions[call.status].includes(status)) {
      throw new BadRequestError(
        `Cannot transition from ${call.status} to ${status}`
      );
    }

    const updateData: any = {
      status,
    };

    if (status === "ACTIVE") {
      updateData.startedAt = new Date();
    } else if (status === "ENDED") {
      updateData.endedAt = new Date();
      if (call.startedAt) {
        const duration = Math.floor(
          (new Date().getTime() - call.startedAt.getTime()) / 1000
        );
        updateData.duration = duration;
      }
    }

    const updated = await prisma.call.update({
      where: { id: callId },
      data: updateData,
    });

    return updated;
  }

  /**
   * End a call
   */
  async endCall(callId: string) {
    const call = await prisma.call.findUnique({
      where: { id: callId },
    });

    if (!call) {
      throw new NotFoundError("Call not found");
    }

    const endedAt = new Date();
    let duration = 0;

    if (call.startedAt) {
      duration = Math.floor(
        (endedAt.getTime() - call.startedAt.getTime()) / 1000
      );
    }

    const updated = await prisma.call.update({
      where: { id: callId },
      data: {
        status: "ENDED" as CallStatus,
        endedAt,
        duration,
      },
    });

    return updated;
  }

  /**
   * Decline a call
   */
  async declineCall(callId: string) {
    const call = await prisma.call.findUnique({
      where: { id: callId },
    });

    if (!call) {
      throw new NotFoundError("Call not found");
    }

    if (call.status !== "RINGING") {
      throw new BadRequestError("Can only decline a ringing call");
    }

    const updated = await prisma.call.update({
      where: { id: callId },
      data: {
        status: "DECLINED" as CallStatus,
        endedAt: new Date(),
      },
    });

    return updated;
  }

  /**
   * Mark a call as missed
   */
  async missCall(callId: string) {
    const call = await prisma.call.findUnique({
      where: { id: callId },
    });

    if (!call) {
      throw new NotFoundError("Call not found");
    }

    if (!["INITIATING", "RINGING"].includes(call.status)) {
      throw new BadRequestError("Call must be ringing to mark as missed");
    }

    const updated = await prisma.call.update({
      where: { id: callId },
      data: {
        status: "MISSED" as CallStatus,
        endedAt: new Date(),
      },
    });

    return updated;
  }

  /**
   * Get active call in a conversation
   */
  async getActiveCall(conversationId: string) {
    const call = await prisma.call.findFirst({
      where: {
        conversationId,
        status: {
          in: ["INITIATING", "RINGING", "ACTIVE"],
        },
      },
    });

    return call || null;
  }

  /**
   * Get call history
   */
  async getCallHistory(
    conversationId: string,
    userId: string,
    limit: number = 20,
    skip: number = 0
  ) {
    // Check if user is in the conversation
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const isParticipant = conversation.participants.some((p) => p.userId === userId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not a member of this conversation");
    }

    const calls = await prisma.call.findMany({
      where: {
        conversationId,
      },
      orderBy: {
        startedAt: "desc",
      },
      take: limit,
      skip,
    });

    return calls;
  }
}

// Export singleton instance
export const callService = new CallService();
</file>

<file path="server/src/services/conversation.service.ts">
import prisma from "../config/db";
import {
  NotFoundError,
  BadRequestError,
  AuthorizationError,
} from "../types/error.types";

export class ConversationService {
  /**
   * Get or create a private conversation between two friends
   */
  async getOrCreateConversation(userId: string, friendId: string) {
    // Check if friend exists
    const friend = await prisma.user.findUnique({
      where: { id: friendId },
    });

    if (!friend) {
      throw new NotFoundError("Friend not found");
    }

    // Check if they're friends
    const friendship = await prisma.friend.findFirst({
      where: {
        OR: [
          { userId, friendId },
          { userId: friendId, friendId: userId },
        ],
      },
    });

    if (!friendship) {
      throw new BadRequestError("You must be friends to create a conversation");
    }

    // Check if conversation already exists
    const existingConversation = await prisma.conversation.findFirst({
      where: {
        participants: {
          every: {
            userId: { in: [userId, friendId] },
          },
        },
      },
      include: {
        participants: {
          include: {
            user: { select: { id: true, name: true, email: true, avatar: true } },
          },
        },
        messages: { take: 1, orderBy: { createdAt: "desc" } },
      },
    });

    if (existingConversation) {
      return existingConversation;
    }

    // Create new private conversation
    const conversation = await prisma.conversation.create({
      data: {
        participants: {
          createMany: {
            data: [
              { userId },
              { userId: friendId },
            ],
          },
        },
      },
      include: {
        participants: {
          include: {
            user: { select: { id: true, name: true, email: true, avatar: true } },
          },
        },
        messages: { take: 1, orderBy: { createdAt: "desc" } },
      },
    });

    return conversation;
  }

  /**
   * Get all conversations for the user
   */
  async getUserConversations(
    userId: string,
    limit: number = 20,
    skip: number = 0,
    search?: string
  ) {
    const conversations = await prisma.conversation.findMany({
      where: {
        participants: {
          some: { userId },
        },
        AND: search
          ? {
              participants: {
                some: {
                  user: {
                    name: { contains: search, mode: "insensitive" },
                  },
                },
              },
            }
          : {},
      },
      include: {
        participants: {
          include: {
            user: { select: { id: true, name: true, email: true, avatar: true, status: true } },
          },
        },
        messages: { take: 1, orderBy: { createdAt: "desc" } },
      },
      orderBy: {
        lastMessageAt: "desc",
      },
      take: limit,
      skip,
    });

    return conversations;
  }

  /**
   * Get a conversation by ID
   */
  async getConversation(conversationId: string, userId: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: {
          include: {
            user: { select: { id: true, name: true, email: true, avatar: true, status: true } },
          },
        },
        messages: {
          take: 50,
          orderBy: { createdAt: "desc" },
          include: { sender: { select: { id: true, name: true, avatar: true } } },
        },
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    // Check if user is part of conversation
    const isParticipant = conversation.participants.some((p) => p.userId === userId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not part of this conversation");
    }

    return conversation;
  }

  /**
   * Get the other user in a private conversation
   */
  async getOtherUser(conversationId: string, userId: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: {
          include: {
            user: { select: { id: true, name: true, email: true, avatar: true, status: true } },
          },
        },
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const participant = conversation.participants.find((p) => p.userId === userId);
    if (!participant) {
      throw new AuthorizationError("You are not part of this conversation");
    }

    const otherParticipant = conversation.participants.find((p) => p.userId !== userId);
    if (!otherParticipant) {
      throw new NotFoundError("Other user not found in conversation");
    }

    return otherParticipant.user;
  }

  /**
   * Archive a conversation
   */
  async archiveConversation(conversationId: string, userId: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const isParticipant = conversation.participants.some((p) => p.userId === userId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not part of this conversation");
    }

    // Archive for this user only
    const updated = await prisma.conversationParticipant.update({
      where: {
        conversationId_userId: {
          conversationId,
          userId,
        },
      },
      data: { isArchived: true },
    });

    return updated;
  }

  /**
   * Unarchive a conversation
   */
  async unarchiveConversation(conversationId: string, userId: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const isParticipant = conversation.participants.some((p) => p.userId === userId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not part of this conversation");
    }

    // Unarchive for this user only
    const updated = await prisma.conversationParticipant.update({
      where: {
        conversationId_userId: {
          conversationId,
          userId,
        },
      },
      data: { isArchived: false },
    });

    return updated;
  }

  /**
   * Delete a conversation
   */
  async deleteConversation(conversationId: string, userId: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const isParticipant = conversation.participants.some((p) => p.userId === userId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not part of this conversation");
    }

    // Delete all related messages and their data
    await prisma.messageReaction.deleteMany({
      where: {
        message: { conversationId },
      },
    });

    await prisma.messageRead.deleteMany({
      where: {
        message: { conversationId },
      },
    });

    await prisma.message.deleteMany({
      where: { conversationId },
    });

    await prisma.call.deleteMany({
      where: { conversationId },
    });

    // Delete conversation participants
    await prisma.conversationParticipant.deleteMany({
      where: { conversationId },
    });

    // Delete conversation
    await prisma.conversation.delete({
      where: { id: conversationId },
    });
  }

  /**
   * Update conversation's last message timestamp
   */
  async updateConversationLastMessage(conversationId: string) {
    const updated = await prisma.conversation.update({
      where: { id: conversationId },
      data: { lastMessageAt: new Date() },
    });

    return updated;
  }
}

// Export singleton instance
export const conversationService = new ConversationService();
</file>

<file path="server/src/services/email.service.ts">
import nodemailer, { Transporter } from "nodemailer";
import { config } from "../config/env.config";

/**
 * Email Transporter Configuration
 */
let transporter: Transporter;

/**
 * Initialize Email Transporter
 */
export const initializeEmailService = (): void => {
  try {
    transporter = nodemailer.createTransport({
      service: config.EMAIL_SERVICE,
      auth: {
        user: config.EMAIL_USER,
        pass: config.EMAIL_PASSWORD,
      },
    });

    console.log("‚úÖ Email service initialized successfully");
  } catch (error) {
    console.error("‚ùå Failed to initialize email service:", error);
    throw new Error("Email service initialization failed");
  }
};

/**
 * Email Options Interface
 */
export interface EmailOptions {
  to: string;
  subject: string;
  html: string;
  text?: string;
}

/**
 * Send Email
 */
export const sendEmail = async (options: EmailOptions): Promise<void> => {
  try {
    if (!transporter) {
      initializeEmailService();
    }

    const mailOptions = {
      from: config.EMAIL_FROM,
      to: options.to,
      subject: options.subject,
      html: options.html,
      text: options.text || options.html,
    };

    const info = await transporter.sendMail(mailOptions);
    console.log(`‚úÖ Email sent: ${info.messageId}`);
  } catch (error) {
    console.error("‚ùå Failed to send email:", error);
    throw new Error("Failed to send email");
  }
};

/**
 * Send Email Verification Link
 */
export const sendVerificationEmail = async (
  email: string,
  verificationToken: string,
  verificationUrl: string
): Promise<void> => {
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Email Verification</h2>
      <p>Thank you for signing up! Please verify your email address by clicking the link below:</p>
      <p style="margin: 30px 0;">
        <a href="${verificationUrl}" style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
          Verify Email
        </a>
      </p>
      <p>Or copy and paste this link in your browser:</p>
      <p style="word-break: break-all; color: #666;">${verificationUrl}</p>
      <p style="color: #999; font-size: 12px;">This verification link will expire in ${config.VERIFICATION_EXPIRY}.</p>
      <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;" />
      <p style="color: #999; font-size: 12px;">If you didn't create this account, please ignore this email.</p>
    </div>
  `;

  await sendEmail({
    to: email,
    subject: "Verify Your Email Address",
    html,
  });
};

/**
 * Send Password Reset Email
 */
export const sendPasswordResetEmail = async (
  email: string,
  resetToken: string,
  resetUrl: string
): Promise<void> => {
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Reset Your Password</h2>
      <p>We received a request to reset your password. Click the link below to create a new password:</p>
      <p style="margin: 30px 0;">
        <a href="${resetUrl}" style="background-color: #28a745; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
          Reset Password
        </a>
      </p>
      <p>Or copy and paste this link in your browser:</p>
      <p style="word-break: break-all; color: #666;">${resetUrl}</p>
      <p style="color: #999; font-size: 12px;">This reset link will expire in 1 hour.</p>
      <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;" />
      <p style="color: #999; font-size: 12px;">If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
    </div>
  `;

  await sendEmail({
    to: email,
    subject: "Reset Your Password",
    html,
  });
};

/**
 * Send Welcome Email
 */
export const sendWelcomeEmail = async (
  email: string,
  name: string
): Promise<void> => {
  const html = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Welcome to Chat App!</h2>
      <p>Hi ${name},</p>
      <p>Thank you for joining our community! We're excited to have you on board.</p>
      <p>You can now:</p>
      <ul style="color: #666;">
        <li>Connect with friends and colleagues</li>
        <li>Send and receive messages in real-time</li>
        <li>Create and manage your profile</li>
      </ul>
      <p>If you have any questions or need assistance, feel free to reach out to our support team.</p>
      <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;" />
      <p style="color: #999; font-size: 12px;">¬© 2025 Chat App. All rights reserved.</p>
    </div>
  `;

  await sendEmail({
    to: email,
    subject: "Welcome to Chat App!",
    html,
  });
};

/**
 * Verify Email Transporter Connection
 */
export const verifyEmailService = async (): Promise<boolean> => {
  try {
    if (!transporter) {
      initializeEmailService();
    }
    await transporter.verify();
    console.log("‚úÖ Email service verified");
    return true;
  } catch (error) {
    console.error("‚ùå Email service verification failed:", error);
    return false;
  }
};
</file>

<file path="server/src/services/friend.service.ts">
import prisma from "../config/db";
import { NotFoundError, BadRequestError } from "../types/error.types";
import { Prisma } from "@prisma/client";

/**
 * Friend Service
 * Handles all friend-related business logic
 */

/**
 * Send a friend request
 */
export async function sendFriendRequest(senderId: string, receiverId: string) {
  // Check if trying to send request to self
  if (senderId === receiverId) {
    throw new BadRequestError("You cannot send a friend request to yourself");
  }

  // Check if receiver exists
  const receiver = await prisma.user.findUnique({
    where: { id: receiverId },
  });

  if (!receiver) {
    throw new NotFoundError("User not found");
  }

  // Check if already friends
  const existingFriendship = await prisma.friend.findFirst({
    where: {
      OR: [
        { userId: senderId, friendId: receiverId },
        { userId: receiverId, friendId: senderId },
      ],
    },
  });

  if (existingFriendship) {
    throw new BadRequestError("You are already friends with this user");
  }

  // Check if there's an existing PENDING request
  const pendingRequest = await prisma.friendRequest.findFirst({
    where: {
      OR: [
        { senderId, receiverId, status: "PENDING" },
        { senderId: receiverId, receiverId: senderId, status: "PENDING" },
      ],
    },
  });

  if (pendingRequest) {
    if (pendingRequest.senderId === senderId) {
      throw new BadRequestError("Friend request already sent");
    } else {
      throw new BadRequestError(
        "This user has already sent you a friend request"
      );
    }
  }

  // Upsert: If request exists (REJECTED/ACCEPTED/CANCELLED), update to PENDING. Otherwise create new.
  // This allows resending after rejection or after removing a friend
  return prisma.friendRequest.upsert({
    where: {
      senderId_receiverId: { senderId, receiverId },
    },
    update: {
      status: "PENDING",
    },
    create: {
      senderId,
      receiverId,
      status: "PENDING",
    },
    include: {
      sender: {
        select: {
          id: true,
          name: true,
          email: true,
          avatar: true,
        },
      },
      receiver: {
        select: {
          id: true,
          name: true,
          email: true,
          avatar: true,
        },
      },
    },
  });
}

/**
 * Accept a friend request
 */
export async function acceptFriendRequest(requestId: string, userId: string) {
  // Find the friend request
  const request = await prisma.friendRequest.findUnique({
    where: { id: requestId },
  });

  if (!request) {
    throw new NotFoundError("Friend request not found");
  }

  // Check if user is the receiver
  if (request.receiverId !== userId) {
    throw new BadRequestError("You can only accept requests sent to you");
  }

  // Check if already accepted
  if (request.status === "ACCEPTED") {
    throw new BadRequestError("Friend request already accepted");
  }

  // Check if rejected
  if (request.status === "REJECTED") {
    throw new BadRequestError("Cannot accept a rejected friend request");
  }

  // Use transaction to update request and create friendship
  const result = await prisma.$transaction(async (tx) => {
    // Update friend request status
    const updatedRequest = await tx.friendRequest.update({
      where: { id: requestId },
      data: { status: "ACCEPTED" },
    });

    // Create friendship (bidirectional)
    const friendship = await tx.friend.create({
      data: {
        userId: request.senderId,
        friendId: request.receiverId,
      },
    });

    return { request: updatedRequest, friendship };
  });

  return result;
}

/**
 * Reject a friend request
 */
export async function rejectFriendRequest(requestId: string, userId: string) {
  // Find the friend request
  const request = await prisma.friendRequest.findUnique({
    where: { id: requestId },
  });

  if (!request) {
    throw new NotFoundError("Friend request not found");
  }

  // Check if user is the receiver
  if (request.receiverId !== userId) {
    throw new BadRequestError("You can only reject requests sent to you");
  }

  // Check if already rejected
  if (request.status === "REJECTED") {
    throw new BadRequestError("Friend request already rejected");
  }

  // Check if already accepted
  if (request.status === "ACCEPTED") {
    throw new BadRequestError("Cannot reject an accepted friend request");
  }

  // Update status to rejected
  return prisma.friendRequest.update({
    where: { id: requestId },
    data: { status: "REJECTED" },
  });
}

/**
 * Cancel a sent friend request
 */
export async function cancelFriendRequest(requestId: string, userId: string) {
  // Find the friend request
  const request = await prisma.friendRequest.findUnique({
    where: { id: requestId },
  });

  if (!request) {
    throw new NotFoundError("Friend request not found");
  }

  // Check if user is the sender
  if (request.senderId !== userId) {
    throw new BadRequestError("You can only cancel requests you sent");
  }

  // Check if already accepted
  if (request.status === "ACCEPTED") {
    throw new BadRequestError("Cannot cancel an accepted friend request");
  }

  // Delete the request
  await prisma.friendRequest.delete({
    where: { id: requestId },
  });

  return { message: "Friend request cancelled successfully" };
}

/**
 * Get friend requests (pending or sent)
 */
export async function getFriendRequests(
  userId: string,
  type: "pending" | "sent",
  limit: number,
  skip: number
) {
  const isPending = type === "pending";

  return prisma.friendRequest.findMany({
    where: {
      ...(isPending ? { receiverId: userId } : { senderId: userId }),
      status: "PENDING",
    },
    include: {
      ...(isPending
        ? {
            sender: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true,
                bio: true,
              },
            },
          }
        : {
            receiver: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true,
                bio: true,
              },
            },
          }),
    },
    orderBy: { createdAt: "desc" },
    take: limit,
    skip,
  });
}

/**
 * Get count of friend requests
 */
export async function getFriendRequestsCount(
  userId: string,
  type: "pending" | "sent"
) {
  const isPending = type === "pending";

  return prisma.friendRequest.count({
    where: {
      ...(isPending ? { receiverId: userId } : { senderId: userId }),
      status: "PENDING",
    },
  });
}

/**
 * Get all friends for a user
 */
export async function getFriends(
  userId: string,
  limit: number,
  skip: number,
  search?: string
) {
  // Get friend IDs where user is either userId or friendId
  const friendships = await prisma.friend.findMany({
    where: {
      OR: [{ userId }, { friendId: userId }],
    },
    select: {
      userId: true,
      friendId: true,
    },
  });

  // Extract friend IDs (exclude current user)
  const friendIds = friendships.map((f) =>
    f.userId === userId ? f.friendId : f.userId
  );

  // Build where clause for search
  const whereClause: Prisma.UserWhereInput = {
    id: { in: friendIds },
  };

  if (search) {
    whereClause.OR = [
      { name: { contains: search, mode: "insensitive" } },
      { email: { contains: search, mode: "insensitive" } },
    ];
  }

  // Get friend details
  return prisma.user.findMany({
    where: whereClause,
    select: {
      id: true,
      name: true,
      email: true,
      avatar: true,
      bio: true,
      status: true,
    },
    orderBy: { name: "asc" },
    take: limit,
    skip,
  });
}

/**
 * Get friends count
 */
export async function getFriendsCount(userId: string, search?: string) {
  const friendships = await prisma.friend.findMany({
    where: {
      OR: [{ userId }, { friendId: userId }],
    },
    select: {
      userId: true,
      friendId: true,
    },
  });

  const friendIds = friendships.map((f) =>
    f.userId === userId ? f.friendId : f.userId
  );

  const whereClause: Prisma.UserWhereInput = {
    id: { in: friendIds },
  };

  if (search) {
    whereClause.OR = [
      { name: { contains: search, mode: "insensitive" } },
      { email: { contains: search, mode: "insensitive" } },
    ];
  }

  return prisma.user.count({ where: whereClause });
}

/**
 * Remove a friend
 */
export async function removeFriend(userId: string, friendId: string) {
  // Check if friendship exists
  const friendship = await prisma.friend.findFirst({
    where: {
      OR: [
        { userId, friendId },
        { userId: friendId, friendId: userId },
      ],
    },
  });

  if (!friendship) {
    throw new NotFoundError("Friendship not found");
  }

  // Delete the friendship
  await prisma.friend.delete({
    where: { id: friendship.id },
  });

  return { message: "Friend removed successfully" };
}
</file>

<file path="server/src/services/message.service.ts">
import prisma from "../config/db";
import { MessageType, MessageStatus } from "@prisma/client";
import {
  NotFoundError,
  BadRequestError,
  AuthorizationError,
} from "../types/error.types";

export class MessageService {
  /**
   * Send a message
   */
  async sendMessage(
    conversationId: string,
    senderId: string,
    content: string,
    type?: string,
    mediaUrls?: string[]
  ) {
    // Check if conversation exists and user is part of it
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const isParticipant = conversation.participants.some((p) => p.userId === senderId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not part of this conversation");
    }

    // Create message
    const message = await prisma.message.create({
      data: {
        conversationId,
        senderId,
        content,
        type: (type || "TEXT") as MessageType,
        mediaUrls: mediaUrls || [],
        status: "SENT" as MessageStatus,
      },
      include: {
        sender: { select: { id: true, name: true, avatar: true } },
      },
    });

    // Update conversation's last message time
    await prisma.conversation.update({
      where: { id: conversationId },
      data: { lastMessageAt: new Date() },
    });

    return message;
  }

  /**
   * Get messages from a conversation
   */
  async getMessages(
    conversationId: string,
    limit: number = 20,
    skip: number = 0
  ) {
    // Check if conversation exists
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const messages = await prisma.message.findMany({
      where: { conversationId },
      include: {
        sender: { select: { id: true, name: true, avatar: true } },
        readBy: { select: { userId: true, readAt: true } },
        reactions: { select: { emoji: true, userId: true } },
      },
      orderBy: { createdAt: "desc" },
      take: limit,
      skip,
    });

    return messages;
  }

  /**
   * Edit a message
   */
  async editMessage(messageId: string, userId: string, newContent: string) {
    const message = await prisma.message.findUnique({
      where: { id: messageId },
    });

    if (!message) {
      throw new NotFoundError("Message not found");
    }

    if (message.senderId !== userId) {
      throw new AuthorizationError("You can only edit your own messages");
    }

    // Check if message is editable (within 5 minutes)
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    if (message.createdAt < fiveMinutesAgo) {
      throw new BadRequestError("Message can only be edited within 5 minutes of sending");
    }

    const updated = await prisma.message.update({
      where: { id: messageId },
      data: {
        content: newContent,
        isEdited: true,
        editedAt: new Date(),
        editedContent: message.content,
      },
      include: {
        sender: { select: { id: true, name: true, avatar: true } },
        reactions: { select: { emoji: true, userId: true } },
      },
    });

    return updated;
  }

  /**
   * Delete a message
   */
  async deleteMessage(messageId: string, userId: string) {
    const message = await prisma.message.findUnique({
      where: { id: messageId },
    });

    if (!message) {
      throw new NotFoundError("Message not found");
    }

    if (message.senderId !== userId) {
      throw new AuthorizationError("You can only delete your own messages");
    }

    await prisma.message.delete({
      where: { id: messageId },
    });

    return { success: true, message: "Message deleted" };
  }

  /**
   * Mark messages as read
   */
  async markMessagesAsRead(conversationId: string, userId: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    // Get all unread messages from this conversation
    const unreadMessages = await prisma.message.findMany({
      where: {
        conversationId,
        senderId: { not: userId }, // Don't mark own messages
      },
      select: { id: true },
    });

    if (unreadMessages.length === 0) {
      return;
    }

    // Mark all as read
    await prisma.messageRead.createMany({
      data: unreadMessages.map((msg) => ({
        messageId: msg.id,
        userId,
        readAt: new Date(),
      })),
      skipDuplicates: true,
    });
  }

  /**
   * Get read receipts for a message
   */
  async getMessageReadReceipts(messageId: string) {
    const message = await prisma.message.findUnique({
      where: { id: messageId },
      include: {
        readBy: {
          include: {
            user: { select: { id: true, name: true, avatar: true } },
          },
        },
      },
    });

    if (!message) {
      throw new NotFoundError("Message not found");
    }

    return message.readBy;
  }

  /**
   * React to a message
   */
  async reactToMessage(messageId: string, userId: string, emoji: string) {
    const message = await prisma.message.findUnique({
      where: { id: messageId },
    });

    if (!message) {
      throw new NotFoundError("Message not found");
    }

    // Check if user is in the conversation
    const conversation = await prisma.conversation.findUnique({
      where: { id: message.conversationId },
      include: {
        participants: true,
      },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const isParticipant = conversation.participants.some((p) => p.userId === userId);
    if (!isParticipant) {
      throw new AuthorizationError("You are not a member of this conversation");
    }

    // Check if reaction already exists
    const existingReaction = await prisma.messageReaction.findUnique({
      where: {
        messageId_userId_emoji: {
          messageId,
          userId,
          emoji,
        },
      },
    });

    if (existingReaction) {
      // Remove reaction if it already exists (toggle)
      await prisma.messageReaction.delete({
        where: {
          messageId_userId_emoji: {
            messageId,
            userId,
            emoji,
          },
        },
      });
      return { removed: true };
    }

    // Add new reaction
    const reaction = await prisma.messageReaction.create({
      data: {
        messageId,
        userId,
        emoji,
      },
    });

    return reaction;
  }

  /**
   * Get all reactions for a message
   */
  async getMessageReactions(messageId: string) {
    const message = await prisma.message.findUnique({
      where: { id: messageId },
    });

    if (!message) {
      throw new NotFoundError("Message not found");
    }

    const reactions = await prisma.messageReaction.findMany({
      where: { messageId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            avatar: true,
          },
        },
      },
      orderBy: {
        createdAt: "asc",
      },
    });

    // Group reactions by emoji
    const grouped = reactions.reduce(
      (acc, reaction) => {
        if (!acc[reaction.emoji]) {
          acc[reaction.emoji] = [];
        }
        acc[reaction.emoji].push({
          userId: reaction.user.id,
          userName: reaction.user.name,
          userAvatar: reaction.user.avatar,
        });
        return acc;
      },
      {} as Record<string, Array<{ userId: string; userName: string | null; userAvatar: string | null }>>
    );

    return grouped;
  }

  /**
   * Remove user's reaction from a message
   */
  async removeReaction(messageId: string, userId: string, emoji: string) {
    const reaction = await prisma.messageReaction.findUnique({
      where: {
        messageId_userId_emoji: {
          messageId,
          userId,
          emoji,
        },
      },
    });

    if (!reaction) {
      throw new NotFoundError("Reaction not found");
    }

    await prisma.messageReaction.delete({
      where: { id: reaction.id },
    });

    return { success: true, message: "Reaction removed" };
  }

  /**
   * Search messages in a conversation
   */
  async searchMessages(conversationId: string, searchText: string) {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
    });

    if (!conversation) {
      throw new NotFoundError("Conversation not found");
    }

    const messages = await prisma.message.findMany({
      where: {
        conversationId,
        content: {
          contains: searchText,
          mode: "insensitive",
        },
      },
      include: {
        sender: { select: { id: true, name: true, avatar: true } },
        reactions: { select: { emoji: true, userId: true } },
      },
      orderBy: { createdAt: "desc" },
      take: 50,
    });

    return messages;
  }
}

// Export singleton instance
export const messageService = new MessageService();
</file>

<file path="server/src/services/user.service.ts">
import prisma from "../config/db";
import { uploadToCloudinary, deleteFromCloudinary, getPublicIdFromUrl } from "../utils/cloudinary.util";
import { UpdateProfileDTO } from "../dto/user.dto";

/**
 * Get user profile by ID
 */
export const getUserProfile = async (userId: string) => {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      email: true,
      name: true,
      avatar: true,
      bio: true,
      status: true,
      role: true,
      emailVerified: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  if (!user) {
    throw new Error("User not found");
  }

  return user;
};

/**
 * Get user by ID (public profile)
 */
export const getUserById = async (userId: string) => {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      name: true,
      avatar: true,
      bio: true,
      status: true,
      createdAt: true,
    },
  });

  if (!user) {
    throw new Error("User not found");
  }

  return user;
};

/**
 * Update user profile
 */
export const updateUserProfile = async (userId: string, data: UpdateProfileDTO) => {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      ...(data.name && { name: data.name }),
      ...(data.bio !== undefined && { bio: data.bio }),
      ...(data.status && { status: data.status }),
    },
    select: {
      id: true,
      email: true,
      name: true,
      avatar: true,
      bio: true,
      status: true,
      role: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Upload user avatar to Cloudinary
 */
export const uploadUserAvatar = async (userId: string, file: Express.Multer.File) => {
  if (!file) {
    throw new Error("No file provided");
  }

  // Get current user to delete old avatar if exists
  const currentUser = await prisma.user.findUnique({
    where: { id: userId },
    select: { avatar: true },
  });

  // Delete old avatar from Cloudinary if exists
  if (currentUser?.avatar) {
    try {
      const publicId = getPublicIdFromUrl(currentUser.avatar);
      await deleteFromCloudinary(publicId);
    } catch (error) {
      console.error("Error deleting old avatar:", error);
    }
  }

  // Upload new avatar
  const uploadResult = await uploadToCloudinary(file, "chat-app/avatars");

  // Update user with new avatar URL
  const updatedUser = await prisma.user.update({
    where: { id: userId },
    data: { avatar: uploadResult.secure_url },
    select: {
      id: true,
      email: true,
      name: true,
      avatar: true,
      bio: true,
      status: true,
      updatedAt: true,
    },
  });

  return updatedUser;
};

/**
 * Search users by name or email
 */
export const searchUsers = async (query: string, limit: number = 10) => {
  const users = await prisma.user.findMany({
    where: {
      OR: [
        { name: { contains: query, mode: "insensitive" } },
        { email: { contains: query, mode: "insensitive" } },
      ],
    },
    select: {
      id: true,
      name: true,
      email: true,
      avatar: true,
      bio: true,
      status: true,
    },
    take: limit,
  });

  return users;
};

/**
 * Delete user account
 */
export const deleteUserAccount = async (userId: string) => {
  // Delete old avatar if exists
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { avatar: true },
  });

  if (user?.avatar) {
    try {
      const publicId = getPublicIdFromUrl(user.avatar);
      await deleteFromCloudinary(publicId);
    } catch (error) {
      console.error("Error deleting avatar:", error);
    }
  }

  // Delete user (cascade delete will handle related records)
  await prisma.user.delete({
    where: { id: userId },
  });

  return { message: "Account deleted successfully" };
};

/**
 * Update user status (online, offline, away)
 */
export const updateUserStatus = async (userId: string, status: string) => {
  const validStatuses = ["online", "offline", "away"];

  if (!validStatuses.includes(status)) {
    throw new Error("Invalid status. Must be one of: online, offline, away");
  }

  const user = await prisma.user.update({
    where: { id: userId },
    data: { status },
    select: {
      id: true,
      status: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Get all users (Admin only)
 */
export const getAllUsers = async (limit: number = 10, skip: number = 0) => {
  const users = await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
      avatar: true,
      bio: true,
      role: true,
      status: true,
      createdAt: true,
    },
    take: limit,
    skip: skip,
    orderBy: { createdAt: "desc" },
  });

  return users;
};

/**
 * Get total users count
 */
export const getTotalUsersCount = async () => {
  return prisma.user.count();
};
</file>

<file path="server/src/socket/chat.socket.ts">
import { Server, Socket } from "socket.io";
import { messageService } from "../services/message.service";

export function setupChatSocket(io: Server) {
  io.on("connection", (socket: Socket) => {
    const userId = socket.data.userId;

    if (!userId) {
      socket.disconnect();
      return;
    }

    console.log(`‚úÖ User ${userId} connected - Socket: ${socket.id}`);

    /**
     * When user OPENS a conversation (joins the room)
     * AUTO-MARK all unread messages as read
     */
    socket.on("conversation:open", async (conversationId: string) => {
      try {
        console.log(`üìñ ${userId} opened conversation ${conversationId}`);

        // Join Socket.io room for this conversation
        socket.join(conversationId);

        // ‚úÖ AUTO-MARK all unread messages as READ
        await messageService.markMessagesAsRead(conversationId, userId);

        // Notify other user that messages are read
        socket.to(conversationId).emit("messages:read", {
          conversationId,
          userId,
          readAt: new Date(),
        });

        console.log(`‚úÖ Auto-marked messages as read for ${userId}`);
      } catch (error) {
        console.error("Error in conversation:open:", error);
        socket.emit("error", { message: "Failed to mark messages as read" });
      }
    });

    /**
     * When user LEAVES/CLOSES a conversation
     */
    socket.on("conversation:close", (conversationId: string) => {
      console.log(`üëã ${userId} closed conversation ${conversationId}`);
      socket.leave(conversationId);
    });

    /**
     * When a NEW MESSAGE is SENT
     * Save message and broadcast to conversation room
     * NOTE: Real-time only - no auto-mark here
     * Clients will mark as read via HTTP or conversation:open event
     */
    socket.on("message:send", async (data: any) => {
      try {
        const { conversationId, content, type = "TEXT", mediaUrls = [] } = data;

        console.log(`üì® Message from ${userId} in ${conversationId}`);

        // Save message to database
        const message = await messageService.sendMessage(
          conversationId,
          userId,
          content,
          type,
          mediaUrls
        );

        // Broadcast message to ALL users (including sender for confirmation)
        io.to(conversationId).emit("message:received", {
          id: message.id,
          conversationId,
          senderId: userId,
          content: message.content,
          type: message.type,
          status: "SENT",
          createdAt: message.createdAt,
          sender: {
            id: userId,
            name: message.sender?.name,
            avatar: message.sender?.avatar,
          },
        });

        console.log(`üì§ Message broadcasted to ${conversationId}`);
      } catch (error) {
        console.error("Error sending message:", error);
        socket.emit("error", { message: "Failed to send message" });
      }
    });

    /**
     * Socket.IO does NOT handle message:received
     * This is a real-time push event from server only
     * Clients acknowledge with HTTP POST /mark-as-read or via conversation:open
     */
    // Note: Removed message:received handler - this is server->client only

    /**
     * When a MESSAGE is EDITED
     * Broadcast edit to all users in conversation
     */
    socket.on("message:edit", async (data: any) => {
      try {
        const { messageId, conversationId, newContent } = data;

        console.log(`‚úèÔ∏è User ${userId} editing message ${messageId}`);

        // Update in database via service
        const updatedMessage = await messageService.editMessage(messageId, userId, newContent);

        // Broadcast edit to conversation
        io.to(conversationId).emit("message:edited", {
          messageId,
          conversationId,
          newContent: updatedMessage.content,
          isEdited: true,
          editedAt: updatedMessage.editedAt,
        });

        console.log(`‚úÖ Message edit broadcasted to ${conversationId}`);
      } catch (error) {
        console.error("Error editing message:", error);
        socket.emit("error", { message: "Failed to edit message" });
      }
    });

    /**
     * When a MESSAGE is DELETED
     * Broadcast deletion to all users in conversation
     */
    socket.on("message:delete", async (data: any) => {
      try {
        const { messageId, conversationId } = data;

        console.log(`üóëÔ∏è User ${userId} deleting message ${messageId}`);

        // Delete from database via service
        await messageService.deleteMessage(messageId, userId);

        // Broadcast deletion to conversation
        io.to(conversationId).emit("message:deleted", {
          messageId,
          conversationId,
        });

        console.log(`‚úÖ Message deletion broadcasted to ${conversationId}`);
      } catch (error) {
        console.error("Error deleting message:", error);
        socket.emit("error", { message: "Failed to delete message" });
      }
    });

    /**
     * Typing indicator - REAL-TIME ONLY (no database)
     */
    socket.on("typing:start", (conversationId: string) => {
      console.log(`‚å®Ô∏è ${userId} is typing in ${conversationId}`);
      socket.to(conversationId).emit("user:typing", {
        conversationId,
        userId,
        isTyping: true,
      });
    });

    socket.on("typing:stop", (conversationId: string) => {
      console.log(`‚å®Ô∏è ${userId} stopped typing in ${conversationId}`);
      socket.to(conversationId).emit("user:typing", {
        conversationId,
        userId,
        isTyping: false,
      });
    });

    /**
     * Message read receipt - REAL-TIME ONLY
     * Notify other users that messages are read
     */
    socket.on("message:read", (data: any) => {
      try {
        const { conversationId, messageIds } = data;

        console.log(`üëÅÔ∏è ${userId} read messages in ${conversationId}`);

        // Broadcast read receipt to other users
        socket.to(conversationId).emit("user:read-receipt", {
          conversationId,
          userId,
          messageIds,
          readAt: new Date(),
        });

        console.log(`‚úÖ Read receipt broadcasted to ${conversationId}`);
      } catch (error) {
        console.error("Error broadcasting read receipt:", error);
      }
    });

    /**
     * Message reactions - REAL-TIME + DATABASE
     * Broadcast reactions to all users in conversation
     */
    socket.on("message:react", async (data: any) => {
      try {
        const { messageId, conversationId, emoji } = data;

        console.log(`üòä ${userId} reacted with ${emoji} to message ${messageId}`);

        // Save/toggle reaction in database
        const reaction = await messageService.reactToMessage(messageId, userId, emoji);

        // Broadcast reaction to conversation
        io.to(conversationId).emit("message:reaction", {
          messageId,
          conversationId,
          userId,
          emoji,
          removed: (reaction as any).removed || false,
        });

        console.log(`‚úÖ Reaction broadcasted to ${conversationId}`);
      } catch (error) {
        console.error("Error reacting to message:", error);
        socket.emit("error", { message: "Failed to react to message" });
      }
    });

    /**
     * User comes online
     */
    socket.on("user:online", () => {
      console.log(`üü¢ ${userId} is online`);
      io.emit("user:status", { userId, status: "online" });
    });

    /**
     * User goes offline
     */
    socket.on("disconnect", () => {
      console.log(`üî¥ ${userId} disconnected`);
      io.emit("user:status", { userId, status: "offline" });
    });
  });
}
</file>

<file path="server/src/types/error.types.ts">
/**
 * Custom Error Types
 */

export class AppError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(message: string, statusCode: number = 500) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string = "Validation failed") {
    super(message, 400);
  }
}

export class BadRequestError extends AppError {
  constructor(message: string = "Bad request") {
    super(message, 400);
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = "Authentication failed") {
    super(message, 401);
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = "Access denied") {
    super(message, 403);
  }
}

export class NotFoundError extends AppError {
  constructor(message: string = "Resource not found") {
    super(message, 404);
  }
}

export class ConflictError extends AppError {
  constructor(message: string = "Resource already exists") {
    super(message, 409);
  }
}

export class DatabaseError extends AppError {
  constructor(message: string = "Database operation failed") {
    super(message, 500);
  }
}
</file>

<file path="server/src/utils/cloudinary.util.ts">
import cloudinary from "../config/cloudinary.config";
import { UploadApiResponse } from "cloudinary";

/**
 * Upload file to Cloudinary
 */
export const uploadToCloudinary = async (
  file: Express.Multer.File,
  folder: string = "chat-app/avatars"
): Promise<UploadApiResponse> => {
  return new Promise((resolve, reject) => {
    const upload = cloudinary.uploader.upload_stream(
      { folder, resource_type: "auto" },
      (error, result) => {
        if (error) reject(error);
        else resolve(result!);
      }
    );
    upload.end(file.buffer);
  });
};

/**
 * Delete file from Cloudinary by public ID
 */
export const deleteFromCloudinary = async (publicId: string): Promise<void> => {
  try {
    await cloudinary.uploader.destroy(publicId);
  } catch (error) {
    console.error("Error deleting from Cloudinary:", error);
  }
};

/**
 * Extract public ID from Cloudinary URL
 */
export const getPublicIdFromUrl = (url: string): string => {
  const parts = url.split("/");
  const filename = parts[parts.length - 1].split(".")[0];
  const folder = parts[parts.length - 2];
  return `${folder}/${filename}`;
};
</file>

<file path="server/src/utils/email.util.ts">
import nodemailer, { Transporter } from "nodemailer";
import { config } from "../config/env.config";
import { emailTemplates } from "./templates/email.templates";

/**
 * Email Transporter Configuration
 */
let transporter: Transporter;

/**
 * Initialize Email Transporter
 */
export const initializeEmailService = (): void => {
  try {
    transporter = nodemailer.createTransport({
      service: config.EMAIL_SERVICE,
      auth: {
        user: config.EMAIL_USER,
        pass: config.EMAIL_PASSWORD,
      },
    });

    console.log("‚úÖ Email service initialized successfully");
  } catch (error) {
    console.error("‚ùå Failed to initialize email service:", error);
    throw new Error("Email service initialization failed");
  }
};

/**
 * Email Options Interface
 */
export interface EmailOptions {
  to: string;
  subject: string;
  html: string;
  text?: string;
}

/**
 * Send Email
 */
export const sendEmail = async (options: EmailOptions): Promise<void> => {
  try {
    if (!transporter) {
      initializeEmailService();
    }

    const mailOptions = {
      from: config.EMAIL_FROM,
      to: options.to,
      subject: options.subject,
      html: options.html,
      text: options.text || "",
    };

    await transporter.sendMail(mailOptions);
    console.log(`‚úÖ Email sent to ${options.to}`);
  } catch (error) {
    console.error("‚ùå Failed to send email:", error);
    throw new Error("Failed to send email");
  }
};

/**
 * Send Verification Email
 */
export const sendVerificationEmail = async (
  email: string,
  verificationToken: string,
  verificationLink: string,
  name?: string
): Promise<void> => {
  const html = emailTemplates.verificationEmail(
    name || email.split("@")[0],
    verificationLink
  );

  await sendEmail({
    to: email,
    subject: "Verify Your Email Address",
    html,
  });
};

/**
 * Send Password Reset Email
 */
export const sendPasswordResetEmail = async (
  email: string,
  resetToken: string,
  resetLink: string,
  name?: string
): Promise<void> => {
  const html = emailTemplates.passwordResetEmail(
    name || email.split("@")[0],
    resetLink
  );

  await sendEmail({
    to: email,
    subject: "Password Reset Request",
    html,
  });
};

/**
 * Send Welcome Email
 */
export const sendWelcomeEmail = async (
  email: string,
  name: string
): Promise<void> => {
  const html = emailTemplates.welcomeEmail(name);

  await sendEmail({
    to: email,
    subject: "Welcome to our platform",
    html,
  });
};
</file>

<file path="server/src/utils/jwt.util.ts">
import jwt, { SignOptions, VerifyOptions } from "jsonwebtoken";
import { config } from "../config/env.config";

/**
 * JWT Token Types
 */
export interface TokenPayload {
  userId: string;
  email: string;
  role?: string;
  iat?: number;
  exp?: number;
}

export interface DecodedToken extends TokenPayload {
  iat: number;
  exp: number;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

/**
 * Generate Access Token (short-lived)
 */
export const generateAccessToken = (payload: Omit<TokenPayload, "iat" | "exp">): string => {
  try {
    const signOptions: SignOptions = {
      expiresIn: config.JWT_EXPIRE as any,
      algorithm: "HS256",
    };
    const token = jwt.sign(payload, config.JWT_SECRET as string, signOptions);
    return token;
  } catch (error) {
    console.error("‚ùå Error generating access token:", error);
    throw new Error("Failed to generate access token");
  }
};

/**
 * Generate Refresh Token (long-lived)
 */
export const generateRefreshToken = (payload: Omit<TokenPayload, "iat" | "exp">): string => {
  try {
    const signOptions: SignOptions = {
      expiresIn: config.JWT_REFRESH_EXPIRE as any,
      algorithm: "HS256",
    };
    const token = jwt.sign(payload, config.JWT_REFRESH_SECRET as string, signOptions);
    return token;
  } catch (error) {
    console.error("‚ùå Error generating refresh token:", error);
    throw new Error("Failed to generate refresh token");
  }
};

/**
 * Generate Both Access and Refresh Tokens
 */
export const generateAuthTokens = (payload: Omit<TokenPayload, "iat" | "exp">): AuthTokens => {
  return {
    accessToken: generateAccessToken(payload),
    refreshToken: generateRefreshToken(payload),
  };
};

/**
 * Verify Access Token
 */
export const verifyAccessToken = (token: string): DecodedToken => {
  try {
    const verifyOptions: VerifyOptions = {
      algorithms: ["HS256"],
    };
    const decoded = jwt.verify(token, config.JWT_SECRET as string, verifyOptions) as DecodedToken;
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new Error("Access token has expired");
    } else if (error instanceof jwt.JsonWebTokenError) {
      throw new Error("Invalid access token");
    }
    throw error;
  }
};

/**
 * Verify Refresh Token
 */
export const verifyRefreshToken = (token: string): DecodedToken => {
  try {
    const verifyOptions: VerifyOptions = {
      algorithms: ["HS256"],
    };
    const decoded = jwt.verify(token, config.JWT_REFRESH_SECRET as string, verifyOptions) as DecodedToken;
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new Error("Refresh token has expired");
    } else if (error instanceof jwt.JsonWebTokenError) {
      throw new Error("Invalid refresh token");
    }
    throw error;
  }
};

/**
 * Refresh Access Token using Refresh Token
 */
export const refreshAccessToken = (refreshToken: string): AuthTokens => {
  try {
    const decoded = verifyRefreshToken(refreshToken);
    const newTokens = generateAuthTokens({
      userId: decoded.userId,
      email: decoded.email,
    });
    return newTokens;
  } catch (error) {
    console.error("‚ùå Error refreshing token:", error);
    throw new Error("Failed to refresh access token");
  }
};

/**
 * Decode Token without Verification (for debugging)
 */
export const decodeToken = (token: string): DecodedToken | null => {
  try {
    const decoded = jwt.decode(token) as DecodedToken;
    return decoded;
  } catch (error) {
    console.error("‚ùå Error decoding token:", error);
    return null;
  }
};
</file>

<file path="server/src/utils/response.util.ts">
import { Response } from "express";

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data: T | null;
  timestamp: string;
}

export const sendResponse = <T = any>(
  res: Response,
  statusCode: number,
  message: string,
  data: T | null = null
): Response => {
  const response: ApiResponse<T> = {
    success: statusCode >= 200 && statusCode < 300,
    message,
    data,
    timestamp: new Date().toISOString(),
  };

  return res.status(statusCode).json(response);
};

export const sendError = (
  res: Response,
  statusCode: number,
  message: string,
  error?: any
): Response => {
  const response: ApiResponse = {
    success: false,
    message,
    data: error || null,
    timestamp: new Date().toISOString(),
  };

  return res.status(statusCode).json(response);
};
</file>

<file path="server/src/utils/templates/email.templates.ts">
/**
 * Email Templates
 * Clean, professional HTML email templates
 */

export const emailTemplates = {
  /**
   * Verification Email Template
   */
  verificationEmail: (name: string, verificationLink: string): string => `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Email Verification</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica',
            'Arial', sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          background-color: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background-color: #f9f9f9;
          padding: 40px 20px;
          text-align: center;
          border-bottom: 1px solid #e0e0e0;
        }
        .header h1 {
          font-size: 28px;
          color: #333333;
          font-weight: 600;
        }
        .content {
          padding: 40px 20px;
        }
        .content p {
          color: #666666;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 20px;
        }
        .content strong {
          color: #333333;
        }
        .button-container {
          text-align: center;
          margin: 30px 0;
        }
        .button {
          display: inline-block;
          padding: 14px 40px;
          background-color: #333333;
          color: #ffffff;
          text-decoration: none;
          border-radius: 6px;
          font-size: 16px;
          font-weight: 600;
          transition: background-color 0.3s ease;
        }
        .button:hover {
          background-color: #1a1a1a;
        }
        .link-section {
          background-color: #f9f9f9;
          padding: 20px;
          border-radius: 6px;
          margin-top: 20px;
          border-left: 4px solid #333333;
        }
        .link-section p {
          margin-bottom: 10px;
          font-size: 14px;
        }
        .link-section a {
          color: #333333;
          word-break: break-all;
          text-decoration: none;
        }
        .footer {
          background-color: #f9f9f9;
          padding: 20px;
          text-align: center;
          border-top: 1px solid #e0e0e0;
          font-size: 12px;
          color: #999999;
        }
        .footer p {
          margin-bottom: 8px;
        }
        .expiry-warning {
          color: #d9534f;
          font-size: 12px;
          margin-top: 10px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Verify Your Email</h1>
        </div>
        <div class="content">
          <p>Hi <strong>${name}</strong>,</p>
          <p>Thank you for registering! To complete your account setup, please verify your email address by clicking the button below.</p>
          
          <div class="button-container">
            <a href="${verificationLink}" class="button">Verify Email Address</a>
          </div>
          
          <p>Or copy and paste this link in your browser:</p>
          <div class="link-section">
            <a href="${verificationLink}">${verificationLink}</a>
            <p class="expiry-warning">This link will expire in 24 hours.</p>
          </div>
          
          <p style="margin-top: 30px; font-size: 14px; color: #999999;">
            If you didn't create this account, please ignore this email or contact support.
          </p>
        </div>
        <div class="footer">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
          <p>Need help? Contact our support team</p>
        </div>
      </div>
    </body>
    </html>
  `,

  /**
   * Welcome Email Template
   */
  welcomeEmail: (name: string): string => `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Welcome</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica',
            'Arial', sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          background-color: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background-color: #f9f9f9;
          padding: 40px 20px;
          text-align: center;
          border-bottom: 1px solid #e0e0e0;
        }
        .header h1 {
          font-size: 28px;
          color: #333333;
          font-weight: 600;
        }
        .content {
          padding: 40px 20px;
        }
        .content p {
          color: #666666;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 20px;
        }
        .content strong {
          color: #333333;
        }
        .features {
          list-style: none;
          padding: 20px 0;
        }
        .features li {
          padding: 12px 0;
          color: #666666;
          border-bottom: 1px solid #f0f0f0;
          display: flex;
          align-items: center;
        }
        .features li:last-child {
          border-bottom: none;
        }
        .features li::before {
          content: "‚úì";
          color: #333333;
          font-weight: bold;
          margin-right: 12px;
          font-size: 18px;
        }
        .footer {
          background-color: #f9f9f9;
          padding: 20px;
          text-align: center;
          border-top: 1px solid #e0e0e0;
          font-size: 12px;
          color: #999999;
        }
        .footer p {
          margin-bottom: 8px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Welcome!</h1>
        </div>
        <div class="content">
          <p>Hi <strong>${name}</strong>,</p>
          <p>Your email has been verified and your account is now active. Welcome to our community!</p>
          
          <p>You can now:</p>
          <ul class="features">
            <li>Log in to your account</li>
            <li>Start using our services</li>
            <li>Connect with other users</li>
            <li>Access exclusive features</li>
          </ul>
          
          <p style="margin-top: 30px;">
            If you have any questions or need assistance, please don't hesitate to contact our support team.
          </p>
          
          <p style="margin-top: 20px;">
            Happy to have you on board!<br>
            <strong>The Team</strong>
          </p>
        </div>
        <div class="footer">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
          <p>Need help? Contact our support team</p>
        </div>
      </div>
    </body>
    </html>
  `,

  /**
   * Password Reset Email Template
   */
  passwordResetEmail: (name: string, resetLink: string): string => `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Password Reset Request</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica',
            'Arial', sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          background-color: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background-color: #f9f9f9;
          padding: 40px 20px;
          text-align: center;
          border-bottom: 1px solid #e0e0e0;
        }
        .header h1 {
          font-size: 28px;
          color: #333333;
          font-weight: 600;
        }
        .content {
          padding: 40px 20px;
        }
        .content p {
          color: #666666;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 20px;
        }
        .content strong {
          color: #333333;
        }
        .button-container {
          text-align: center;
          margin: 30px 0;
        }
        .button {
          display: inline-block;
          padding: 14px 40px;
          background-color: #333333;
          color: #ffffff;
          text-decoration: none;
          border-radius: 6px;
          font-size: 16px;
          font-weight: 600;
          transition: background-color 0.3s ease;
        }
        .button:hover {
          background-color: #1a1a1a;
        }
        .link-section {
          background-color: #f9f9f9;
          padding: 20px;
          border-radius: 6px;
          margin-top: 20px;
          border-left: 4px solid #333333;
        }
        .link-section p {
          margin-bottom: 10px;
          font-size: 14px;
        }
        .link-section a {
          color: #333333;
          word-break: break-all;
          text-decoration: none;
        }
        .warning {
          background-color: #fef5f5;
          padding: 15px;
          border-left: 4px solid #d9534f;
          margin-top: 20px;
          border-radius: 4px;
        }
        .warning p {
          color: #c9302c;
          font-size: 14px;
        }
        .footer {
          background-color: #f9f9f9;
          padding: 20px;
          text-align: center;
          border-top: 1px solid #e0e0e0;
          font-size: 12px;
          color: #999999;
        }
        .footer p {
          margin-bottom: 8px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Reset Your Password</h1>
        </div>
        <div class="content">
          <p>Hi <strong>${name}</strong>,</p>
          <p>We received a request to reset your password. Click the button below to create a new password.</p>
          
          <div class="button-container">
            <a href="${resetLink}" class="button">Reset Password</a>
          </div>
          
          <p>Or copy and paste this link in your browser:</p>
          <div class="link-section">
            <a href="${resetLink}">${resetLink}</a>
            <p style="margin-top: 10px; font-size: 12px; color: #999999;">This link will expire in 1 hour.</p>
          </div>
          
          <div class="warning">
            <p><strong>‚ö† Security Notice:</strong> If you didn't request this password reset, please ignore this email or contact support immediately.</p>
          </div>
        </div>
        <div class="footer">
          <p>&copy; 2024 Your Application. All rights reserved.</p>
          <p>Need help? Contact our support team</p>
        </div>
      </div>
    </body>
    </html>
  `,
};
</file>

<file path="server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "baseUrl": ".",
    "paths": {
      "@services/*": ["src/services/*"],
      "@utils/*": ["src/utils/*"],
      "@controllers/*": ["src/controllers/*"],
      "@dto/*": ["src/dto/*"],
      "@middleware/*": ["src/middleware/*"],
      "@config/*": ["src/config/*"],
      "@types/*": ["src/types/*"]
    },
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

</files>
